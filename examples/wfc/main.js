/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/clipper-lib/clipper.js":
/*!*********************************************!*\
  !*** ./node_modules/clipper-lib/clipper.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*******************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.4.2                                                           *\n * Date      :  27 February 2017                                                *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2017                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.4.2.2                                                         *\n * Date      :  8 September 2017                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes   *\n * or floating point Clipper is released.                                       *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n\t\"use strict\";\n\tvar ClipperLib = {};\n\tClipperLib.version = '6.4.2.2';\n\n\t//UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\tClipperLib.use_lines = true;\n\n\t//ClipperLib.use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\tClipperLib.use_xyz = false;\n\n\tvar isNode = false;\n\tif ( true && module.exports)\n\t{\n\t\tmodule.exports = ClipperLib;\n\t\tisNode = true;\n\t}\n\telse\n\t{\n\t\tif (true) {\n\t\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\t}\n\t\tif (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t\telse self['ClipperLib'] = ClipperLib;\n\t}\n\tvar navigator_appName;\n\tif (!isNode)\n\t{\n\t\tvar nav = navigator.userAgent.toString().toLowerCase();\n\t\tnavigator_appName = navigator.appName;\n\t}\n\telse\n\t{\n\t\tvar nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t\tnavigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t}\n\t// Browser test to speedup performance critical functions\n\tvar browser = {};\n\n\tif (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\telse browser.chrome = 0;\n\tif (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\telse browser.chromium = 0;\n\tif (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\telse browser.safari = 0;\n\tif (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\telse browser.firefox = 0;\n\tif (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\telse browser.firefox17 = 0;\n\tif (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\telse browser.firefox15 = 0;\n\tif (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\telse browser.firefox3 = 0;\n\tif (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\telse browser.opera = 0;\n\tif (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\telse browser.msie10 = 0;\n\tif (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\telse browser.msie9 = 0;\n\tif (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\telse browser.msie8 = 0;\n\tif (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\telse browser.msie7 = 0;\n\tif (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\telse browser.msie = 0;\n\tClipperLib.biginteger_used = null;\n\n\t// Copyright (c) 2005  Tom Wu\n\t// All Rights Reserved.\n\t// See \"LICENSE\" for details.\n\t// Basic JavaScript BN library - subset useful for RSA encryption.\n\t// Bits per digit\n\tvar dbits;\n\t// JavaScript engine analysis\n\tvar canary = 0xdeadbeefcafe;\n\tvar j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t// (public) Constructor\n\t/**\n\t* @constructor\n\t*/\n\tfunction BigInteger(a, b, c)\n\t{\n\t\t// This test variable can be removed,\n\t\t// but at least for performance tests it is useful piece of knowledge\n\t\t// This is the only ClipperLib related variable in BigInteger library\n\t\tClipperLib.biginteger_used = 1;\n\t\tif (a != null)\n\t\t\tif (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t\t\telse if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t\telse if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t\telse this.fromString(a, b);\n\t}\n\t// return new, unset BigInteger\n\tfunction nbi()\n\t{\n\t\treturn new BigInteger(null, undefined, undefined);\n\t}\n\t// am: Compute w_j += (x*this_i), propagate carries,\n\t// c is initial carry, returns final carry.\n\t// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t// We need to select the fastest one that works in this environment.\n\t// am1: use a single mult and divide to get the high bits,\n\t// max digit bits should be 26 because\n\t// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\tfunction am1(i, x, w, j, c, n)\n\t{\n\t\twhile (--n >= 0)\n\t\t{\n\t\t\tvar v = x * this[i++] + w[j] + c;\n\t\t\tc = Math.floor(v / 0x4000000);\n\t\t\tw[j++] = v & 0x3ffffff;\n\t\t}\n\t\treturn c;\n\t}\n\t// am2 avoids a big mult-and-extract completely.\n\t// Max digit bits should be <= 30 because we do bitwise ops\n\t// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\tfunction am2(i, x, w, j, c, n)\n\t{\n\t\tvar xl = x & 0x7fff,\n\t\t\txh = x >> 15;\n\t\twhile (--n >= 0)\n\t\t{\n\t\t\tvar l = this[i] & 0x7fff;\n\t\t\tvar h = this[i++] >> 15;\n\t\t\tvar m = xh * l + h * xl;\n\t\t\tl = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t\t\tc = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t\t\tw[j++] = l & 0x3fffffff;\n\t\t}\n\t\treturn c;\n\t}\n\t// Alternately, set max digit bits to 28 since some\n\t// browsers slow down when dealing with 32-bit numbers.\n\tfunction am3(i, x, w, j, c, n)\n\t{\n\t\tvar xl = x & 0x3fff,\n\t\t\txh = x >> 14;\n\t\twhile (--n >= 0)\n\t\t{\n\t\t\tvar l = this[i] & 0x3fff;\n\t\t\tvar h = this[i++] >> 14;\n\t\t\tvar m = xh * l + h * xl;\n\t\t\tl = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t\t\tc = (l >> 28) + (m >> 14) + xh * h;\n\t\t\tw[j++] = l & 0xfffffff;\n\t\t}\n\t\treturn c;\n\t}\n\tif (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t{\n\t\tBigInteger.prototype.am = am2;\n\t\tdbits = 30;\n\t}\n\telse if (j_lm && (navigator_appName != \"Netscape\"))\n\t{\n\t\tBigInteger.prototype.am = am1;\n\t\tdbits = 26;\n\t}\n\telse\n\t{ // Mozilla/Netscape seems to prefer am3\n\t\tBigInteger.prototype.am = am3;\n\t\tdbits = 28;\n\t}\n\tBigInteger.prototype.DB = dbits;\n\tBigInteger.prototype.DM = ((1 << dbits) - 1);\n\tBigInteger.prototype.DV = (1 << dbits);\n\tvar BI_FP = 52;\n\tBigInteger.prototype.FV = Math.pow(2, BI_FP);\n\tBigInteger.prototype.F1 = BI_FP - dbits;\n\tBigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t// Digit conversions\n\tvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\tvar BI_RC = new Array();\n\tvar rr, vv;\n\trr = \"0\".charCodeAt(0);\n\tfor (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\trr = \"a\".charCodeAt(0);\n\tfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\trr = \"A\".charCodeAt(0);\n\tfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n\tfunction int2char(n)\n\t{\n\t\treturn BI_RM.charAt(n);\n\t}\n\n\tfunction intAt(s, i)\n\t{\n\t\tvar c = BI_RC[s.charCodeAt(i)];\n\t\treturn (c == null) ? -1 : c;\n\t}\n\t// (protected) copy this to r\n\tfunction bnpCopyTo(r)\n\t{\n\t\tfor (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t\tr.t = this.t;\n\t\tr.s = this.s;\n\t}\n\t// (protected) set from integer value x, -DV <= x < DV\n\tfunction bnpFromInt(x)\n\t{\n\t\tthis.t = 1;\n\t\tthis.s = (x < 0) ? -1 : 0;\n\t\tif (x > 0) this[0] = x;\n\t\telse if (x < -1) this[0] = x + this.DV;\n\t\telse this.t = 0;\n\t}\n\t// return bigint initialized to value\n\tfunction nbv(i)\n\t{\n\t\tvar r = nbi();\n\t\tr.fromInt(i);\n\t\treturn r;\n\t}\n\t// (protected) set from string and radix\n\tfunction bnpFromString(s, b)\n\t{\n\t\tvar k;\n\t\tif (b == 16) k = 4;\n\t\telse if (b == 8) k = 3;\n\t\telse if (b == 256) k = 8; // byte array\n\t\telse if (b == 2) k = 1;\n\t\telse if (b == 32) k = 5;\n\t\telse if (b == 4) k = 2;\n\t\telse\n\t\t{\n\t\t\tthis.fromRadix(s, b);\n\t\t\treturn;\n\t\t}\n\t\tthis.t = 0;\n\t\tthis.s = 0;\n\t\tvar i = s.length,\n\t\t\tmi = false,\n\t\t\tsh = 0;\n\t\twhile (--i >= 0)\n\t\t{\n\t\t\tvar x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t\t\tif (x < 0)\n\t\t\t{\n\t\t\t\tif (s.charAt(i) == \"-\") mi = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmi = false;\n\t\t\tif (sh == 0)\n\t\t\t\tthis[this.t++] = x;\n\t\t\telse if (sh + k > this.DB)\n\t\t\t{\n\t\t\t\tthis[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t\t\t\tthis[this.t++] = (x >> (this.DB - sh));\n\t\t\t}\n\t\t\telse\n\t\t\t\tthis[this.t - 1] |= x << sh;\n\t\t\tsh += k;\n\t\t\tif (sh >= this.DB) sh -= this.DB;\n\t\t}\n\t\tif (k == 8 && (s[0] & 0x80) != 0)\n\t\t{\n\t\t\tthis.s = -1;\n\t\t\tif (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t\t}\n\t\tthis.clamp();\n\t\tif (mi) BigInteger.ZERO.subTo(this, this);\n\t}\n\t// (protected) clamp off excess high words\n\tfunction bnpClamp()\n\t{\n\t\tvar c = this.s & this.DM;\n\t\twhile (this.t > 0 && this[this.t - 1] == c) --this.t;\n\t}\n\t// (public) return string representation in given radix\n\tfunction bnToString(b)\n\t{\n\t\tif (this.s < 0) return \"-\" + this.negate().toString(b);\n\t\tvar k;\n\t\tif (b == 16) k = 4;\n\t\telse if (b == 8) k = 3;\n\t\telse if (b == 2) k = 1;\n\t\telse if (b == 32) k = 5;\n\t\telse if (b == 4) k = 2;\n\t\telse return this.toRadix(b);\n\t\tvar km = (1 << k) - 1,\n\t\t\td, m = false,\n\t\t\tr = \"\",\n\t\t\ti = this.t;\n\t\tvar p = this.DB - (i * this.DB) % k;\n\t\tif (i-- > 0)\n\t\t{\n\t\t\tif (p < this.DB && (d = this[i] >> p) > 0)\n\t\t\t{\n\t\t\t\tm = true;\n\t\t\t\tr = int2char(d);\n\t\t\t}\n\t\t\twhile (i >= 0)\n\t\t\t{\n\t\t\t\tif (p < k)\n\t\t\t\t{\n\t\t\t\t\td = (this[i] & ((1 << p) - 1)) << (k - p);\n\t\t\t\t\td |= this[--i] >> (p += this.DB - k);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\td = (this[i] >> (p -= k)) & km;\n\t\t\t\t\tif (p <= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tp += this.DB;\n\t\t\t\t\t\t--i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d > 0) m = true;\n\t\t\t\tif (m) r += int2char(d);\n\t\t\t}\n\t\t}\n\t\treturn m ? r : \"0\";\n\t}\n\t// (public) -this\n\tfunction bnNegate()\n\t{\n\t\tvar r = nbi();\n\t\tBigInteger.ZERO.subTo(this, r);\n\t\treturn r;\n\t}\n\t// (public) |this|\n\tfunction bnAbs()\n\t{\n\t\treturn (this.s < 0) ? this.negate() : this;\n\t}\n\t// (public) return + if this > a, - if this < a, 0 if equal\n\tfunction bnCompareTo(a)\n\t{\n\t\tvar r = this.s - a.s;\n\t\tif (r != 0) return r;\n\t\tvar i = this.t;\n\t\tr = i - a.t;\n\t\tif (r != 0) return (this.s < 0) ? -r : r;\n\t\twhile (--i >= 0)\n\t\t\tif ((r = this[i] - a[i]) != 0) return r;\n\t\treturn 0;\n\t}\n\t// returns bit length of the integer x\n\tfunction nbits(x)\n\t{\n\t\tvar r = 1,\n\t\t\tt;\n\t\tif ((t = x >>> 16) != 0)\n\t\t{\n\t\t\tx = t;\n\t\t\tr += 16;\n\t\t}\n\t\tif ((t = x >> 8) != 0)\n\t\t{\n\t\t\tx = t;\n\t\t\tr += 8;\n\t\t}\n\t\tif ((t = x >> 4) != 0)\n\t\t{\n\t\t\tx = t;\n\t\t\tr += 4;\n\t\t}\n\t\tif ((t = x >> 2) != 0)\n\t\t{\n\t\t\tx = t;\n\t\t\tr += 2;\n\t\t}\n\t\tif ((t = x >> 1) != 0)\n\t\t{\n\t\t\tx = t;\n\t\t\tr += 1;\n\t\t}\n\t\treturn r;\n\t}\n\t// (public) return the number of bits in \"this\"\n\tfunction bnBitLength()\n\t{\n\t\tif (this.t <= 0) return 0;\n\t\treturn this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t}\n\t// (protected) r = this << n*DB\n\tfunction bnpDLShiftTo(n, r)\n\t{\n\t\tvar i;\n\t\tfor (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t\tfor (i = n - 1; i >= 0; --i) r[i] = 0;\n\t\tr.t = this.t + n;\n\t\tr.s = this.s;\n\t}\n\t// (protected) r = this >> n*DB\n\tfunction bnpDRShiftTo(n, r)\n\t{\n\t\tfor (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t\tr.t = Math.max(this.t - n, 0);\n\t\tr.s = this.s;\n\t}\n\t// (protected) r = this << n\n\tfunction bnpLShiftTo(n, r)\n\t{\n\t\tvar bs = n % this.DB;\n\t\tvar cbs = this.DB - bs;\n\t\tvar bm = (1 << cbs) - 1;\n\t\tvar ds = Math.floor(n / this.DB),\n\t\t\tc = (this.s << bs) & this.DM,\n\t\t\ti;\n\t\tfor (i = this.t - 1; i >= 0; --i)\n\t\t{\n\t\t\tr[i + ds + 1] = (this[i] >> cbs) | c;\n\t\t\tc = (this[i] & bm) << bs;\n\t\t}\n\t\tfor (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t\tr[ds] = c;\n\t\tr.t = this.t + ds + 1;\n\t\tr.s = this.s;\n\t\tr.clamp();\n\t}\n\t// (protected) r = this >> n\n\tfunction bnpRShiftTo(n, r)\n\t{\n\t\tr.s = this.s;\n\t\tvar ds = Math.floor(n / this.DB);\n\t\tif (ds >= this.t)\n\t\t{\n\t\t\tr.t = 0;\n\t\t\treturn;\n\t\t}\n\t\tvar bs = n % this.DB;\n\t\tvar cbs = this.DB - bs;\n\t\tvar bm = (1 << bs) - 1;\n\t\tr[0] = this[ds] >> bs;\n\t\tfor (var i = ds + 1; i < this.t; ++i)\n\t\t{\n\t\t\tr[i - ds - 1] |= (this[i] & bm) << cbs;\n\t\t\tr[i - ds] = this[i] >> bs;\n\t\t}\n\t\tif (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t\tr.t = this.t - ds;\n\t\tr.clamp();\n\t}\n\t// (protected) r = this - a\n\tfunction bnpSubTo(a, r)\n\t{\n\t\tvar i = 0,\n\t\t\tc = 0,\n\t\t\tm = Math.min(a.t, this.t);\n\t\twhile (i < m)\n\t\t{\n\t\t\tc += this[i] - a[i];\n\t\t\tr[i++] = c & this.DM;\n\t\t\tc >>= this.DB;\n\t\t}\n\t\tif (a.t < this.t)\n\t\t{\n\t\t\tc -= a.s;\n\t\t\twhile (i < this.t)\n\t\t\t{\n\t\t\t\tc += this[i];\n\t\t\t\tr[i++] = c & this.DM;\n\t\t\t\tc >>= this.DB;\n\t\t\t}\n\t\t\tc += this.s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc += this.s;\n\t\t\twhile (i < a.t)\n\t\t\t{\n\t\t\t\tc -= a[i];\n\t\t\t\tr[i++] = c & this.DM;\n\t\t\t\tc >>= this.DB;\n\t\t\t}\n\t\t\tc -= a.s;\n\t\t}\n\t\tr.s = (c < 0) ? -1 : 0;\n\t\tif (c < -1) r[i++] = this.DV + c;\n\t\telse if (c > 0) r[i++] = c;\n\t\tr.t = i;\n\t\tr.clamp();\n\t}\n\t// (protected) r = this * a, r != this,a (HAC 14.12)\n\t// \"this\" should be the larger one if appropriate.\n\tfunction bnpMultiplyTo(a, r)\n\t{\n\t\tvar x = this.abs(),\n\t\t\ty = a.abs();\n\t\tvar i = x.t;\n\t\tr.t = i + y.t;\n\t\twhile (--i >= 0) r[i] = 0;\n\t\tfor (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t\tr.s = 0;\n\t\tr.clamp();\n\t\tif (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t}\n\t// (protected) r = this^2, r != this (HAC 14.16)\n\tfunction bnpSquareTo(r)\n\t{\n\t\tvar x = this.abs();\n\t\tvar i = r.t = 2 * x.t;\n\t\twhile (--i >= 0) r[i] = 0;\n\t\tfor (i = 0; i < x.t - 1; ++i)\n\t\t{\n\t\t\tvar c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t\t\tif ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t\t\t{\n\t\t\t\tr[i + x.t] -= x.DV;\n\t\t\t\tr[i + x.t + 1] = 1;\n\t\t\t}\n\t\t}\n\t\tif (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t\tr.s = 0;\n\t\tr.clamp();\n\t}\n\t// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t// r != q, this != m.  q or r may be null.\n\tfunction bnpDivRemTo(m, q, r)\n\t{\n\t\tvar pm = m.abs();\n\t\tif (pm.t <= 0) return;\n\t\tvar pt = this.abs();\n\t\tif (pt.t < pm.t)\n\t\t{\n\t\t\tif (q != null) q.fromInt(0);\n\t\t\tif (r != null) this.copyTo(r);\n\t\t\treturn;\n\t\t}\n\t\tif (r == null) r = nbi();\n\t\tvar y = nbi(),\n\t\t\tts = this.s,\n\t\t\tms = m.s;\n\t\tvar nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t\tif (nsh > 0)\n\t\t{\n\t\t\tpm.lShiftTo(nsh, y);\n\t\t\tpt.lShiftTo(nsh, r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpm.copyTo(y);\n\t\t\tpt.copyTo(r);\n\t\t}\n\t\tvar ys = y.t;\n\t\tvar y0 = y[ys - 1];\n\t\tif (y0 == 0) return;\n\t\tvar yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t\tvar d1 = this.FV / yt,\n\t\t\td2 = (1 << this.F1) / yt,\n\t\t\te = 1 << this.F2;\n\t\tvar i = r.t,\n\t\t\tj = i - ys,\n\t\t\tt = (q == null) ? nbi() : q;\n\t\ty.dlShiftTo(j, t);\n\t\tif (r.compareTo(t) >= 0)\n\t\t{\n\t\t\tr[r.t++] = 1;\n\t\t\tr.subTo(t, r);\n\t\t}\n\t\tBigInteger.ONE.dlShiftTo(ys, t);\n\t\tt.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t\twhile (y.t < ys) y[y.t++] = 0;\n\t\twhile (--j >= 0)\n\t\t{\n\t\t\t// Estimate quotient digit\n\t\t\tvar qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t\t\tif ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t\t\t{ // Try it out\n\t\t\t\ty.dlShiftTo(j, t);\n\t\t\t\tr.subTo(t, r);\n\t\t\t\twhile (r[i] < --qd) r.subTo(t, r);\n\t\t\t}\n\t\t}\n\t\tif (q != null)\n\t\t{\n\t\t\tr.drShiftTo(ys, q);\n\t\t\tif (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t\t}\n\t\tr.t = ys;\n\t\tr.clamp();\n\t\tif (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t\tif (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t}\n\t// (public) this mod a\n\tfunction bnMod(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.abs().divRemTo(a, null, r);\n\t\tif (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t\treturn r;\n\t}\n\t// Modular reduction using \"classic\" algorithm\n\t/**\n\t* @constructor\n\t*/\n\tfunction Classic(m)\n\t{\n\t\tthis.m = m;\n\t}\n\n\tfunction cConvert(x)\n\t{\n\t\tif (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t\telse return x;\n\t}\n\n\tfunction cRevert(x)\n\t{\n\t\treturn x;\n\t}\n\n\tfunction cReduce(x)\n\t{\n\t\tx.divRemTo(this.m, null, x);\n\t}\n\n\tfunction cMulTo(x, y, r)\n\t{\n\t\tx.multiplyTo(y, r);\n\t\tthis.reduce(r);\n\t}\n\n\tfunction cSqrTo(x, r)\n\t{\n\t\tx.squareTo(r);\n\t\tthis.reduce(r);\n\t}\n\tClassic.prototype.convert = cConvert;\n\tClassic.prototype.revert = cRevert;\n\tClassic.prototype.reduce = cReduce;\n\tClassic.prototype.mulTo = cMulTo;\n\tClassic.prototype.sqrTo = cSqrTo;\n\t// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t// justification:\n\t//         xy == 1 (mod m)\n\t//         xy =  1+km\n\t//   xy(2-xy) = (1+km)(1-km)\n\t// x[y(2-xy)] = 1-k^2m^2\n\t// x[y(2-xy)] == 1 (mod m^2)\n\t// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t// JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\tfunction bnpInvDigit()\n\t{\n\t\tif (this.t < 1) return 0;\n\t\tvar x = this[0];\n\t\tif ((x & 1) == 0) return 0;\n\t\tvar y = x & 3; // y == 1/x mod 2^2\n\t\ty = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t\ty = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t\ty = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t\t// last step - calculate inverse mod DV directly;\n\t\t// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t\ty = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t\t// we really want the negative inverse, and -DV < y < DV\n\t\treturn (y > 0) ? this.DV - y : -y;\n\t}\n\t// Montgomery reduction\n\t/**\n\t* @constructor\n\t*/\n\tfunction Montgomery(m)\n\t{\n\t\tthis.m = m;\n\t\tthis.mp = m.invDigit();\n\t\tthis.mpl = this.mp & 0x7fff;\n\t\tthis.mph = this.mp >> 15;\n\t\tthis.um = (1 << (m.DB - 15)) - 1;\n\t\tthis.mt2 = 2 * m.t;\n\t}\n\t// xR mod m\n\tfunction montConvert(x)\n\t{\n\t\tvar r = nbi();\n\t\tx.abs().dlShiftTo(this.m.t, r);\n\t\tr.divRemTo(this.m, null, r);\n\t\tif (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t\treturn r;\n\t}\n\t// x/R mod m\n\tfunction montRevert(x)\n\t{\n\t\tvar r = nbi();\n\t\tx.copyTo(r);\n\t\tthis.reduce(r);\n\t\treturn r;\n\t}\n\t// x = x/R mod m (HAC 14.32)\n\tfunction montReduce(x)\n\t{\n\t\twhile (x.t <= this.mt2) // pad x so am has enough room later\n\t\t\tx[x.t++] = 0;\n\t\tfor (var i = 0; i < this.m.t; ++i)\n\t\t{\n\t\t\t// faster way of calculating u0 = x[i]*mp mod DV\n\t\t\tvar j = x[i] & 0x7fff;\n\t\t\tvar u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t\t\t// use am to combine the multiply-shift-add into one call\n\t\t\tj = i + this.m.t;\n\t\t\tx[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t\t\t// propagate carry\n\t\t\twhile (x[j] >= x.DV)\n\t\t\t{\n\t\t\t\tx[j] -= x.DV;\n\t\t\t\tx[++j]++;\n\t\t\t}\n\t\t}\n\t\tx.clamp();\n\t\tx.drShiftTo(this.m.t, x);\n\t\tif (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t}\n\t// r = \"x^2/R mod m\"; x != r\n\tfunction montSqrTo(x, r)\n\t{\n\t\tx.squareTo(r);\n\t\tthis.reduce(r);\n\t}\n\t// r = \"xy/R mod m\"; x,y != r\n\tfunction montMulTo(x, y, r)\n\t{\n\t\tx.multiplyTo(y, r);\n\t\tthis.reduce(r);\n\t}\n\tMontgomery.prototype.convert = montConvert;\n\tMontgomery.prototype.revert = montRevert;\n\tMontgomery.prototype.reduce = montReduce;\n\tMontgomery.prototype.mulTo = montMulTo;\n\tMontgomery.prototype.sqrTo = montSqrTo;\n\t// (protected) true iff this is even\n\tfunction bnpIsEven()\n\t{\n\t\treturn ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t}\n\t// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\tfunction bnpExp(e, z)\n\t{\n\t\tif (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t\tvar r = nbi(),\n\t\t\tr2 = nbi(),\n\t\t\tg = z.convert(this),\n\t\t\ti = nbits(e) - 1;\n\t\tg.copyTo(r);\n\t\twhile (--i >= 0)\n\t\t{\n\t\t\tz.sqrTo(r, r2);\n\t\t\tif ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar t = r;\n\t\t\t\tr = r2;\n\t\t\t\tr2 = t;\n\t\t\t}\n\t\t}\n\t\treturn z.revert(r);\n\t}\n\t// (public) this^e % m, 0 <= e < 2^32\n\tfunction bnModPowInt(e, m)\n\t{\n\t\tvar z;\n\t\tif (e < 256 || m.isEven()) z = new Classic(m);\n\t\telse z = new Montgomery(m);\n\t\treturn this.exp(e, z);\n\t}\n\t// protected\n\tBigInteger.prototype.copyTo = bnpCopyTo;\n\tBigInteger.prototype.fromInt = bnpFromInt;\n\tBigInteger.prototype.fromString = bnpFromString;\n\tBigInteger.prototype.clamp = bnpClamp;\n\tBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\tBigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\tBigInteger.prototype.lShiftTo = bnpLShiftTo;\n\tBigInteger.prototype.rShiftTo = bnpRShiftTo;\n\tBigInteger.prototype.subTo = bnpSubTo;\n\tBigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\tBigInteger.prototype.squareTo = bnpSquareTo;\n\tBigInteger.prototype.divRemTo = bnpDivRemTo;\n\tBigInteger.prototype.invDigit = bnpInvDigit;\n\tBigInteger.prototype.isEven = bnpIsEven;\n\tBigInteger.prototype.exp = bnpExp;\n\t// public\n\tBigInteger.prototype.toString = bnToString;\n\tBigInteger.prototype.negate = bnNegate;\n\tBigInteger.prototype.abs = bnAbs;\n\tBigInteger.prototype.compareTo = bnCompareTo;\n\tBigInteger.prototype.bitLength = bnBitLength;\n\tBigInteger.prototype.mod = bnMod;\n\tBigInteger.prototype.modPowInt = bnModPowInt;\n\t// \"constants\"\n\tBigInteger.ZERO = nbv(0);\n\tBigInteger.ONE = nbv(1);\n\t// Copyright (c) 2005-2009  Tom Wu\n\t// All Rights Reserved.\n\t// See \"LICENSE\" for details.\n\t// Extended JavaScript BN functions, required for RSA private ops.\n\t// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t// Version 1.2: square() API, isProbablePrime fix\n\t// (public)\n\tfunction bnClone()\n\t{\n\t\tvar r = nbi();\n\t\tthis.copyTo(r);\n\t\treturn r;\n\t}\n\t// (public) return value as integer\n\tfunction bnIntValue()\n\t{\n\t\tif (this.s < 0)\n\t\t{\n\t\t\tif (this.t == 1) return this[0] - this.DV;\n\t\t\telse if (this.t == 0) return -1;\n\t\t}\n\t\telse if (this.t == 1) return this[0];\n\t\telse if (this.t == 0) return 0;\n\t\t// assumes 16 < DB < 32\n\t\treturn ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t}\n\t// (public) return value as byte\n\tfunction bnByteValue()\n\t{\n\t\treturn (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t}\n\t// (public) return value as short (assumes DB>=16)\n\tfunction bnShortValue()\n\t{\n\t\treturn (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t}\n\t// (protected) return x s.t. r^x < DV\n\tfunction bnpChunkSize(r)\n\t{\n\t\treturn Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t}\n\t// (public) 0 if this == 0, 1 if this > 0\n\tfunction bnSigNum()\n\t{\n\t\tif (this.s < 0) return -1;\n\t\telse if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t\telse return 1;\n\t}\n\t// (protected) convert to radix string\n\tfunction bnpToRadix(b)\n\t{\n\t\tif (b == null) b = 10;\n\t\tif (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t\tvar cs = this.chunkSize(b);\n\t\tvar a = Math.pow(b, cs);\n\t\tvar d = nbv(a),\n\t\t\ty = nbi(),\n\t\t\tz = nbi(),\n\t\t\tr = \"\";\n\t\tthis.divRemTo(d, y, z);\n\t\twhile (y.signum() > 0)\n\t\t{\n\t\t\tr = (a + z.intValue()).toString(b).substr(1) + r;\n\t\t\ty.divRemTo(d, y, z);\n\t\t}\n\t\treturn z.intValue().toString(b) + r;\n\t}\n\t// (protected) convert from radix string\n\tfunction bnpFromRadix(s, b)\n\t{\n\t\tthis.fromInt(0);\n\t\tif (b == null) b = 10;\n\t\tvar cs = this.chunkSize(b);\n\t\tvar d = Math.pow(b, cs),\n\t\t\tmi = false,\n\t\t\tj = 0,\n\t\t\tw = 0;\n\t\tfor (var i = 0; i < s.length; ++i)\n\t\t{\n\t\t\tvar x = intAt(s, i);\n\t\t\tif (x < 0)\n\t\t\t{\n\t\t\t\tif (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw = b * w + x;\n\t\t\tif (++j >= cs)\n\t\t\t{\n\t\t\t\tthis.dMultiply(d);\n\t\t\t\tthis.dAddOffset(w, 0);\n\t\t\t\tj = 0;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\tif (j > 0)\n\t\t{\n\t\t\tthis.dMultiply(Math.pow(b, j));\n\t\t\tthis.dAddOffset(w, 0);\n\t\t}\n\t\tif (mi) BigInteger.ZERO.subTo(this, this);\n\t}\n\t// (protected) alternate constructor\n\tfunction bnpFromNumber(a, b, c)\n\t{\n\t\tif (\"number\" == typeof b)\n\t\t{\n\t\t\t// new BigInteger(int,int,RNG)\n\t\t\tif (a < 2) this.fromInt(1);\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.fromNumber(a, c);\n\t\t\t\tif (!this.testBit(a - 1)) // force MSB set\n\t\t\t\t\tthis.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t\t\t\tif (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t\t\t\twhile (!this.isProbablePrime(b))\n\t\t\t\t{\n\t\t\t\t\tthis.dAddOffset(2, 0);\n\t\t\t\t\tif (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// new BigInteger(int,RNG)\n\t\t\tvar x = new Array(),\n\t\t\t\tt = a & 7;\n\t\t\tx.length = (a >> 3) + 1;\n\t\t\tb.nextBytes(x);\n\t\t\tif (t > 0) x[0] &= ((1 << t) - 1);\n\t\t\telse x[0] = 0;\n\t\t\tthis.fromString(x, 256);\n\t\t}\n\t}\n\t// (public) convert to bigendian byte array\n\tfunction bnToByteArray()\n\t{\n\t\tvar i = this.t,\n\t\t\tr = new Array();\n\t\tr[0] = this.s;\n\t\tvar p = this.DB - (i * this.DB) % 8,\n\t\t\td, k = 0;\n\t\tif (i-- > 0)\n\t\t{\n\t\t\tif (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t\t\t\tr[k++] = d | (this.s << (this.DB - p));\n\t\t\twhile (i >= 0)\n\t\t\t{\n\t\t\t\tif (p < 8)\n\t\t\t\t{\n\t\t\t\t\td = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t\t\t\t\td |= this[--i] >> (p += this.DB - 8);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\td = (this[i] >> (p -= 8)) & 0xff;\n\t\t\t\t\tif (p <= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tp += this.DB;\n\t\t\t\t\t\t--i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((d & 0x80) != 0) d |= -256;\n\t\t\t\tif (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;\n\t\t\t\tif (k > 0 || d != this.s) r[k++] = d;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tfunction bnEquals(a)\n\t{\n\t\treturn (this.compareTo(a) == 0);\n\t}\n\n\tfunction bnMin(a)\n\t{\n\t\treturn (this.compareTo(a) < 0) ? this : a;\n\t}\n\n\tfunction bnMax(a)\n\t{\n\t\treturn (this.compareTo(a) > 0) ? this : a;\n\t}\n\t// (protected) r = this op a (bitwise)\n\tfunction bnpBitwiseTo(a, op, r)\n\t{\n\t\tvar i, f, m = Math.min(a.t, this.t);\n\t\tfor (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t\tif (a.t < this.t)\n\t\t{\n\t\t\tf = a.s & this.DM;\n\t\t\tfor (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t\t\tr.t = this.t;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = this.s & this.DM;\n\t\t\tfor (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t\t\tr.t = a.t;\n\t\t}\n\t\tr.s = op(this.s, a.s);\n\t\tr.clamp();\n\t}\n\t// (public) this & a\n\tfunction op_and(x, y)\n\t{\n\t\treturn x & y;\n\t}\n\n\tfunction bnAnd(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.bitwiseTo(a, op_and, r);\n\t\treturn r;\n\t}\n\t// (public) this | a\n\tfunction op_or(x, y)\n\t{\n\t\treturn x | y;\n\t}\n\n\tfunction bnOr(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.bitwiseTo(a, op_or, r);\n\t\treturn r;\n\t}\n\t// (public) this ^ a\n\tfunction op_xor(x, y)\n\t{\n\t\treturn x ^ y;\n\t}\n\n\tfunction bnXor(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.bitwiseTo(a, op_xor, r);\n\t\treturn r;\n\t}\n\t// (public) this & ~a\n\tfunction op_andnot(x, y)\n\t{\n\t\treturn x & ~y;\n\t}\n\n\tfunction bnAndNot(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.bitwiseTo(a, op_andnot, r);\n\t\treturn r;\n\t}\n\t// (public) ~this\n\tfunction bnNot()\n\t{\n\t\tvar r = nbi();\n\t\tfor (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t\tr.t = this.t;\n\t\tr.s = ~this.s;\n\t\treturn r;\n\t}\n\t// (public) this << n\n\tfunction bnShiftLeft(n)\n\t{\n\t\tvar r = nbi();\n\t\tif (n < 0) this.rShiftTo(-n, r);\n\t\telse this.lShiftTo(n, r);\n\t\treturn r;\n\t}\n\t// (public) this >> n\n\tfunction bnShiftRight(n)\n\t{\n\t\tvar r = nbi();\n\t\tif (n < 0) this.lShiftTo(-n, r);\n\t\telse this.rShiftTo(n, r);\n\t\treturn r;\n\t}\n\t// return index of lowest 1-bit in x, x < 2^31\n\tfunction lbit(x)\n\t{\n\t\tif (x == 0) return -1;\n\t\tvar r = 0;\n\t\tif ((x & 0xffff) == 0)\n\t\t{\n\t\t\tx >>= 16;\n\t\t\tr += 16;\n\t\t}\n\t\tif ((x & 0xff) == 0)\n\t\t{\n\t\t\tx >>= 8;\n\t\t\tr += 8;\n\t\t}\n\t\tif ((x & 0xf) == 0)\n\t\t{\n\t\t\tx >>= 4;\n\t\t\tr += 4;\n\t\t}\n\t\tif ((x & 3) == 0)\n\t\t{\n\t\t\tx >>= 2;\n\t\t\tr += 2;\n\t\t}\n\t\tif ((x & 1) == 0) ++r;\n\t\treturn r;\n\t}\n\t// (public) returns index of lowest 1-bit (or -1 if none)\n\tfunction bnGetLowestSetBit()\n\t{\n\t\tfor (var i = 0; i < this.t; ++i)\n\t\t\tif (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t\tif (this.s < 0) return this.t * this.DB;\n\t\treturn -1;\n\t}\n\t// return number of 1 bits in x\n\tfunction cbit(x)\n\t{\n\t\tvar r = 0;\n\t\twhile (x != 0)\n\t\t{\n\t\t\tx &= x - 1;\n\t\t\t++r;\n\t\t}\n\t\treturn r;\n\t}\n\t// (public) return number of set bits\n\tfunction bnBitCount()\n\t{\n\t\tvar r = 0,\n\t\t\tx = this.s & this.DM;\n\t\tfor (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t\treturn r;\n\t}\n\t// (public) true iff nth bit is set\n\tfunction bnTestBit(n)\n\t{\n\t\tvar j = Math.floor(n / this.DB);\n\t\tif (j >= this.t) return (this.s != 0);\n\t\treturn ((this[j] & (1 << (n % this.DB))) != 0);\n\t}\n\t// (protected) this op (1<<n)\n\tfunction bnpChangeBit(n, op)\n\t{\n\t\tvar r = BigInteger.ONE.shiftLeft(n);\n\t\tthis.bitwiseTo(r, op, r);\n\t\treturn r;\n\t}\n\t// (public) this | (1<<n)\n\tfunction bnSetBit(n)\n\t{\n\t\treturn this.changeBit(n, op_or);\n\t}\n\t// (public) this & ~(1<<n)\n\tfunction bnClearBit(n)\n\t{\n\t\treturn this.changeBit(n, op_andnot);\n\t}\n\t// (public) this ^ (1<<n)\n\tfunction bnFlipBit(n)\n\t{\n\t\treturn this.changeBit(n, op_xor);\n\t}\n\t// (protected) r = this + a\n\tfunction bnpAddTo(a, r)\n\t{\n\t\tvar i = 0,\n\t\t\tc = 0,\n\t\t\tm = Math.min(a.t, this.t);\n\t\twhile (i < m)\n\t\t{\n\t\t\tc += this[i] + a[i];\n\t\t\tr[i++] = c & this.DM;\n\t\t\tc >>= this.DB;\n\t\t}\n\t\tif (a.t < this.t)\n\t\t{\n\t\t\tc += a.s;\n\t\t\twhile (i < this.t)\n\t\t\t{\n\t\t\t\tc += this[i];\n\t\t\t\tr[i++] = c & this.DM;\n\t\t\t\tc >>= this.DB;\n\t\t\t}\n\t\t\tc += this.s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc += this.s;\n\t\t\twhile (i < a.t)\n\t\t\t{\n\t\t\t\tc += a[i];\n\t\t\t\tr[i++] = c & this.DM;\n\t\t\t\tc >>= this.DB;\n\t\t\t}\n\t\t\tc += a.s;\n\t\t}\n\t\tr.s = (c < 0) ? -1 : 0;\n\t\tif (c > 0) r[i++] = c;\n\t\telse if (c < -1) r[i++] = this.DV + c;\n\t\tr.t = i;\n\t\tr.clamp();\n\t}\n\t// (public) this + a\n\tfunction bnAdd(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.addTo(a, r);\n\t\treturn r;\n\t}\n\t// (public) this - a\n\tfunction bnSubtract(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.subTo(a, r);\n\t\treturn r;\n\t}\n\t// (public) this * a\n\tfunction bnMultiply(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.multiplyTo(a, r);\n\t\treturn r;\n\t}\n\t// (public) this^2\n\tfunction bnSquare()\n\t{\n\t\tvar r = nbi();\n\t\tthis.squareTo(r);\n\t\treturn r;\n\t}\n\t// (public) this / a\n\tfunction bnDivide(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.divRemTo(a, r, null);\n\t\treturn r;\n\t}\n\t// (public) this % a\n\tfunction bnRemainder(a)\n\t{\n\t\tvar r = nbi();\n\t\tthis.divRemTo(a, null, r);\n\t\treturn r;\n\t}\n\t// (public) [this/a,this%a]\n\tfunction bnDivideAndRemainder(a)\n\t{\n\t\tvar q = nbi(),\n\t\t\tr = nbi();\n\t\tthis.divRemTo(a, q, r);\n\t\treturn new Array(q, r);\n\t}\n\t// (protected) this *= n, this >= 0, 1 < n < DV\n\tfunction bnpDMultiply(n)\n\t{\n\t\tthis[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t\t++this.t;\n\t\tthis.clamp();\n\t}\n\t// (protected) this += n << w words, this >= 0\n\tfunction bnpDAddOffset(n, w)\n\t{\n\t\tif (n == 0) return;\n\t\twhile (this.t <= w) this[this.t++] = 0;\n\t\tthis[w] += n;\n\t\twhile (this[w] >= this.DV)\n\t\t{\n\t\t\tthis[w] -= this.DV;\n\t\t\tif (++w >= this.t) this[this.t++] = 0;\n\t\t\t++this[w];\n\t\t}\n\t}\n\t// A \"null\" reducer\n\t/**\n\t* @constructor\n\t*/\n\tfunction NullExp()\n\t{}\n\n\tfunction nNop(x)\n\t{\n\t\treturn x;\n\t}\n\n\tfunction nMulTo(x, y, r)\n\t{\n\t\tx.multiplyTo(y, r);\n\t}\n\n\tfunction nSqrTo(x, r)\n\t{\n\t\tx.squareTo(r);\n\t}\n\tNullExp.prototype.convert = nNop;\n\tNullExp.prototype.revert = nNop;\n\tNullExp.prototype.mulTo = nMulTo;\n\tNullExp.prototype.sqrTo = nSqrTo;\n\t// (public) this^e\n\tfunction bnPow(e)\n\t{\n\t\treturn this.exp(e, new NullExp());\n\t}\n\t// (protected) r = lower n words of \"this * a\", a.t <= n\n\t// \"this\" should be the larger one if appropriate.\n\tfunction bnpMultiplyLowerTo(a, n, r)\n\t{\n\t\tvar i = Math.min(this.t + a.t, n);\n\t\tr.s = 0; // assumes a,this >= 0\n\t\tr.t = i;\n\t\twhile (i > 0) r[--i] = 0;\n\t\tvar j;\n\t\tfor (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t\tfor (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t\tr.clamp();\n\t}\n\t// (protected) r = \"this * a\" without lower n words, n > 0\n\t// \"this\" should be the larger one if appropriate.\n\tfunction bnpMultiplyUpperTo(a, n, r)\n\t{\n\t\t--n;\n\t\tvar i = r.t = this.t + a.t - n;\n\t\tr.s = 0; // assumes a,this >= 0\n\t\twhile (--i >= 0) r[i] = 0;\n\t\tfor (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t\t\tr[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t\tr.clamp();\n\t\tr.drShiftTo(1, r);\n\t}\n\t// Barrett modular reduction\n\t/**\n\t* @constructor\n\t*/\n\tfunction Barrett(m)\n\t{\n\t\t// setup Barrett\n\t\tthis.r2 = nbi();\n\t\tthis.q3 = nbi();\n\t\tBigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t\tthis.mu = this.r2.divide(m);\n\t\tthis.m = m;\n\t}\n\n\tfunction barrettConvert(x)\n\t{\n\t\tif (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t\telse if (x.compareTo(this.m) < 0) return x;\n\t\telse\n\t\t{\n\t\t\tvar r = nbi();\n\t\t\tx.copyTo(r);\n\t\t\tthis.reduce(r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tfunction barrettRevert(x)\n\t{\n\t\treturn x;\n\t}\n\t// x = x mod m (HAC 14.42)\n\tfunction barrettReduce(x)\n\t{\n\t\tx.drShiftTo(this.m.t - 1, this.r2);\n\t\tif (x.t > this.m.t + 1)\n\t\t{\n\t\t\tx.t = this.m.t + 1;\n\t\t\tx.clamp();\n\t\t}\n\t\tthis.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t\tthis.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t\twhile (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t\tx.subTo(this.r2, x);\n\t\twhile (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t}\n\t// r = x^2 mod m; x != r\n\tfunction barrettSqrTo(x, r)\n\t{\n\t\tx.squareTo(r);\n\t\tthis.reduce(r);\n\t}\n\t// r = x*y mod m; x,y != r\n\tfunction barrettMulTo(x, y, r)\n\t{\n\t\tx.multiplyTo(y, r);\n\t\tthis.reduce(r);\n\t}\n\tBarrett.prototype.convert = barrettConvert;\n\tBarrett.prototype.revert = barrettRevert;\n\tBarrett.prototype.reduce = barrettReduce;\n\tBarrett.prototype.mulTo = barrettMulTo;\n\tBarrett.prototype.sqrTo = barrettSqrTo;\n\t// (public) this^e % m (HAC 14.85)\n\tfunction bnModPow(e, m)\n\t{\n\t\tvar i = e.bitLength(),\n\t\t\tk, r = nbv(1),\n\t\t\tz;\n\t\tif (i <= 0) return r;\n\t\telse if (i < 18) k = 1;\n\t\telse if (i < 48) k = 3;\n\t\telse if (i < 144) k = 4;\n\t\telse if (i < 768) k = 5;\n\t\telse k = 6;\n\t\tif (i < 8)\n\t\t\tz = new Classic(m);\n\t\telse if (m.isEven())\n\t\t\tz = new Barrett(m);\n\t\telse\n\t\t\tz = new Montgomery(m);\n\t\t// precomputation\n\t\tvar g = new Array(),\n\t\t\tn = 3,\n\t\t\tk1 = k - 1,\n\t\t\tkm = (1 << k) - 1;\n\t\tg[1] = z.convert(this);\n\t\tif (k > 1)\n\t\t{\n\t\t\tvar g2 = nbi();\n\t\t\tz.sqrTo(g[1], g2);\n\t\t\twhile (n <= km)\n\t\t\t{\n\t\t\t\tg[n] = nbi();\n\t\t\t\tz.mulTo(g2, g[n - 2], g[n]);\n\t\t\t\tn += 2;\n\t\t\t}\n\t\t}\n\t\tvar j = e.t - 1,\n\t\t\tw, is1 = true,\n\t\t\tr2 = nbi(),\n\t\t\tt;\n\t\ti = nbits(e[j]) - 1;\n\t\twhile (j >= 0)\n\t\t{\n\t\t\tif (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t\t\telse\n\t\t\t{\n\t\t\t\tw = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t\t\t\tif (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t\t\t}\n\t\t\tn = k;\n\t\t\twhile ((w & 1) == 0)\n\t\t\t{\n\t\t\t\tw >>= 1;\n\t\t\t\t--n;\n\t\t\t}\n\t\t\tif ((i -= n) < 0)\n\t\t\t{\n\t\t\t\ti += this.DB;\n\t\t\t\t--j;\n\t\t\t}\n\t\t\tif (is1)\n\t\t\t{ // ret == 1, don't bother squaring or multiplying it\n\t\t\t\tg[w].copyTo(r);\n\t\t\t\tis1 = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (n > 1)\n\t\t\t\t{\n\t\t\t\t\tz.sqrTo(r, r2);\n\t\t\t\t\tz.sqrTo(r2, r);\n\t\t\t\t\tn -= 2;\n\t\t\t\t}\n\t\t\t\tif (n > 0) z.sqrTo(r, r2);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tt = r;\n\t\t\t\t\tr = r2;\n\t\t\t\t\tr2 = t;\n\t\t\t\t}\n\t\t\t\tz.mulTo(r2, g[w], r);\n\t\t\t}\n\t\t\twhile (j >= 0 && (e[j] & (1 << i)) == 0)\n\t\t\t{\n\t\t\t\tz.sqrTo(r, r2);\n\t\t\t\tt = r;\n\t\t\t\tr = r2;\n\t\t\t\tr2 = t;\n\t\t\t\tif (--i < 0)\n\t\t\t\t{\n\t\t\t\t\ti = this.DB - 1;\n\t\t\t\t\t--j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn z.revert(r);\n\t}\n\t// (public) gcd(this,a) (HAC 14.54)\n\tfunction bnGCD(a)\n\t{\n\t\tvar x = (this.s < 0) ? this.negate() : this.clone();\n\t\tvar y = (a.s < 0) ? a.negate() : a.clone();\n\t\tif (x.compareTo(y) < 0)\n\t\t{\n\t\t\tvar t = x;\n\t\t\tx = y;\n\t\t\ty = t;\n\t\t}\n\t\tvar i = x.getLowestSetBit(),\n\t\t\tg = y.getLowestSetBit();\n\t\tif (g < 0) return x;\n\t\tif (i < g) g = i;\n\t\tif (g > 0)\n\t\t{\n\t\t\tx.rShiftTo(g, x);\n\t\t\ty.rShiftTo(g, y);\n\t\t}\n\t\twhile (x.signum() > 0)\n\t\t{\n\t\t\tif ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t\t\tif ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t\t\tif (x.compareTo(y) >= 0)\n\t\t\t{\n\t\t\t\tx.subTo(y, x);\n\t\t\t\tx.rShiftTo(1, x);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty.subTo(x, y);\n\t\t\t\ty.rShiftTo(1, y);\n\t\t\t}\n\t\t}\n\t\tif (g > 0) y.lShiftTo(g, y);\n\t\treturn y;\n\t}\n\t// (protected) this % n, n < 2^26\n\tfunction bnpModInt(n)\n\t{\n\t\tif (n <= 0) return 0;\n\t\tvar d = this.DV % n,\n\t\t\tr = (this.s < 0) ? n - 1 : 0;\n\t\tif (this.t > 0)\n\t\t\tif (d == 0) r = this[0] % n;\n\t\t\telse\n\t\t\t\tfor (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t\treturn r;\n\t}\n\t// (public) 1/this % m (HAC 14.61)\n\tfunction bnModInverse(m)\n\t{\n\t\tvar ac = m.isEven();\n\t\tif ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t\tvar u = m.clone(),\n\t\t\tv = this.clone();\n\t\tvar a = nbv(1),\n\t\t\tb = nbv(0),\n\t\t\tc = nbv(0),\n\t\t\td = nbv(1);\n\t\twhile (u.signum() != 0)\n\t\t{\n\t\t\twhile (u.isEven())\n\t\t\t{\n\t\t\t\tu.rShiftTo(1, u);\n\t\t\t\tif (ac)\n\t\t\t\t{\n\t\t\t\t\tif (!a.isEven() || !b.isEven())\n\t\t\t\t\t{\n\t\t\t\t\t\ta.addTo(this, a);\n\t\t\t\t\t\tb.subTo(m, b);\n\t\t\t\t\t}\n\t\t\t\t\ta.rShiftTo(1, a);\n\t\t\t\t}\n\t\t\t\telse if (!b.isEven()) b.subTo(m, b);\n\t\t\t\tb.rShiftTo(1, b);\n\t\t\t}\n\t\t\twhile (v.isEven())\n\t\t\t{\n\t\t\t\tv.rShiftTo(1, v);\n\t\t\t\tif (ac)\n\t\t\t\t{\n\t\t\t\t\tif (!c.isEven() || !d.isEven())\n\t\t\t\t\t{\n\t\t\t\t\t\tc.addTo(this, c);\n\t\t\t\t\t\td.subTo(m, d);\n\t\t\t\t\t}\n\t\t\t\t\tc.rShiftTo(1, c);\n\t\t\t\t}\n\t\t\t\telse if (!d.isEven()) d.subTo(m, d);\n\t\t\t\td.rShiftTo(1, d);\n\t\t\t}\n\t\t\tif (u.compareTo(v) >= 0)\n\t\t\t{\n\t\t\t\tu.subTo(v, u);\n\t\t\t\tif (ac) a.subTo(c, a);\n\t\t\t\tb.subTo(d, b);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv.subTo(u, v);\n\t\t\t\tif (ac) c.subTo(a, c);\n\t\t\t\td.subTo(b, d);\n\t\t\t}\n\t\t}\n\t\tif (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t\tif (d.compareTo(m) >= 0) return d.subtract(m);\n\t\tif (d.signum() < 0) d.addTo(m, d);\n\t\telse return d;\n\t\tif (d.signum() < 0) return d.add(m);\n\t\telse return d;\n\t}\n\tvar lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\tvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t// (public) test primality with certainty >= 1-.5^t\n\tfunction bnIsProbablePrime(t)\n\t{\n\t\tvar i, x = this.abs();\n\t\tif (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t\t{\n\t\t\tfor (i = 0; i < lowprimes.length; ++i)\n\t\t\t\tif (x[0] == lowprimes[i]) return true;\n\t\t\treturn false;\n\t\t}\n\t\tif (x.isEven()) return false;\n\t\ti = 1;\n\t\twhile (i < lowprimes.length)\n\t\t{\n\t\t\tvar m = lowprimes[i],\n\t\t\t\tj = i + 1;\n\t\t\twhile (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t\t\tm = x.modInt(m);\n\t\t\twhile (i < j)\n\t\t\t\tif (m % lowprimes[i++] == 0) return false;\n\t\t}\n\t\treturn x.millerRabin(t);\n\t}\n\t// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\tfunction bnpMillerRabin(t)\n\t{\n\t\tvar n1 = this.subtract(BigInteger.ONE);\n\t\tvar k = n1.getLowestSetBit();\n\t\tif (k <= 0) return false;\n\t\tvar r = n1.shiftRight(k);\n\t\tt = (t + 1) >> 1;\n\t\tif (t > lowprimes.length) t = lowprimes.length;\n\t\tvar a = nbi();\n\t\tfor (var i = 0; i < t; ++i)\n\t\t{\n\t\t\t//Pick bases at random, instead of starting at 2\n\t\t\ta.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t\t\tvar y = a.modPow(r, this);\n\t\t\tif (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t\t\t{\n\t\t\t\tvar j = 1;\n\t\t\t\twhile (j++ < k && y.compareTo(n1) != 0)\n\t\t\t\t{\n\t\t\t\t\ty = y.modPowInt(2, this);\n\t\t\t\t\tif (y.compareTo(BigInteger.ONE) == 0) return false;\n\t\t\t\t}\n\t\t\t\tif (y.compareTo(n1) != 0) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t// protected\n\tBigInteger.prototype.chunkSize = bnpChunkSize;\n\tBigInteger.prototype.toRadix = bnpToRadix;\n\tBigInteger.prototype.fromRadix = bnpFromRadix;\n\tBigInteger.prototype.fromNumber = bnpFromNumber;\n\tBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\tBigInteger.prototype.changeBit = bnpChangeBit;\n\tBigInteger.prototype.addTo = bnpAddTo;\n\tBigInteger.prototype.dMultiply = bnpDMultiply;\n\tBigInteger.prototype.dAddOffset = bnpDAddOffset;\n\tBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\tBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\tBigInteger.prototype.modInt = bnpModInt;\n\tBigInteger.prototype.millerRabin = bnpMillerRabin;\n\t// public\n\tBigInteger.prototype.clone = bnClone;\n\tBigInteger.prototype.intValue = bnIntValue;\n\tBigInteger.prototype.byteValue = bnByteValue;\n\tBigInteger.prototype.shortValue = bnShortValue;\n\tBigInteger.prototype.signum = bnSigNum;\n\tBigInteger.prototype.toByteArray = bnToByteArray;\n\tBigInteger.prototype.equals = bnEquals;\n\tBigInteger.prototype.min = bnMin;\n\tBigInteger.prototype.max = bnMax;\n\tBigInteger.prototype.and = bnAnd;\n\tBigInteger.prototype.or = bnOr;\n\tBigInteger.prototype.xor = bnXor;\n\tBigInteger.prototype.andNot = bnAndNot;\n\tBigInteger.prototype.not = bnNot;\n\tBigInteger.prototype.shiftLeft = bnShiftLeft;\n\tBigInteger.prototype.shiftRight = bnShiftRight;\n\tBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\tBigInteger.prototype.bitCount = bnBitCount;\n\tBigInteger.prototype.testBit = bnTestBit;\n\tBigInteger.prototype.setBit = bnSetBit;\n\tBigInteger.prototype.clearBit = bnClearBit;\n\tBigInteger.prototype.flipBit = bnFlipBit;\n\tBigInteger.prototype.add = bnAdd;\n\tBigInteger.prototype.subtract = bnSubtract;\n\tBigInteger.prototype.multiply = bnMultiply;\n\tBigInteger.prototype.divide = bnDivide;\n\tBigInteger.prototype.remainder = bnRemainder;\n\tBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\tBigInteger.prototype.modPow = bnModPow;\n\tBigInteger.prototype.modInverse = bnModInverse;\n\tBigInteger.prototype.pow = bnPow;\n\tBigInteger.prototype.gcd = bnGCD;\n\tBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t// JSBN-specific extension\n\tBigInteger.prototype.square = bnSquare;\n\tvar Int128 = BigInteger;\n\t// BigInteger interfaces not implemented in jsbn:\n\t// BigInteger(int signum, byte[] magnitude)\n\t// double doubleValue()\n\t// float floatValue()\n\t// int hashCode()\n\t// long longValue()\n\t// static BigInteger valueOf(long val)\n\t// Helper functions to make BigInteger functions callable with two parameters\n\t// as in original C# Clipper\n\tInt128.prototype.IsNegative = function ()\n\t{\n\t\tif (this.compareTo(Int128.ZERO) == -1) return true;\n\t\telse return false;\n\t};\n\n\tInt128.op_Equality = function (val1, val2)\n\t{\n\t\tif (val1.compareTo(val2) == 0) return true;\n\t\telse return false;\n\t};\n\n\tInt128.op_Inequality = function (val1, val2)\n\t{\n\t\tif (val1.compareTo(val2) != 0) return true;\n\t\telse return false;\n\t};\n\n\tInt128.op_GreaterThan = function (val1, val2)\n\t{\n\t\tif (val1.compareTo(val2) > 0) return true;\n\t\telse return false;\n\t};\n\n\tInt128.op_LessThan = function (val1, val2)\n\t{\n\t\tif (val1.compareTo(val2) < 0) return true;\n\t\telse return false;\n\t};\n\n\tInt128.op_Addition = function (lhs, rhs)\n\t{\n\t\treturn new Int128(lhs, undefined, undefined).add(new Int128(rhs, undefined, undefined));\n\t};\n\n\tInt128.op_Subtraction = function (lhs, rhs)\n\t{\n\t\treturn new Int128(lhs, undefined, undefined).subtract(new Int128(rhs, undefined, undefined));\n\t};\n\n\tInt128.Int128Mul = function (lhs, rhs)\n\t{\n\t\treturn new Int128(lhs, undefined, undefined).multiply(new Int128(rhs, undefined, undefined));\n\t};\n\n\tInt128.op_Division = function (lhs, rhs)\n\t{\n\t\treturn lhs.divide(rhs);\n\t};\n\n\tInt128.prototype.ToDouble = function ()\n\t{\n\t\treturn parseFloat(this.toString()); // This could be something faster\n\t};\n\n\t// end of Int128 section\n\t/*\n\t// Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\tif (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\telse self.Int128 = Int128;\n\t*/\n\n\t// ---------------------------------------------\n\n\t// Here starts the actual Clipper library:\n\t// Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) === 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) === 'undefined' || ce.prototype[p] === Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) === 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) === 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Path = function ()\n\t{\n\t\treturn [];\n\t};\n\n\tClipperLib.Path.prototype.push = Array.prototype.push;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Paths = function ()\n\t{\n\t\treturn []; // Was previously [[]], but caused problems when pushed\n\t};\n\n\tClipperLib.Paths.prototype.push = Array.prototype.push;\n\n\t// Preserves the calling way of original C# Clipper\n\t// Is essential due to compatibility, because DoublePoint is public class in original C# version\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.DoublePoint = function ()\n\t{\n\t\tvar a = arguments;\n\t\tthis.X = 0;\n\t\tthis.Y = 0;\n\t\t// public DoublePoint(DoublePoint dp)\n\t\t// public DoublePoint(IntPoint ip)\n\t\tif (a.length === 1)\n\t\t{\n\t\t\tthis.X = a[0].X;\n\t\t\tthis.Y = a[0].Y;\n\t\t}\n\t\telse if (a.length === 2)\n\t\t{\n\t\t\tthis.X = a[0];\n\t\t\tthis.Y = a[1];\n\t\t}\n\t}; // This is internal faster function when called without arguments\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.DoublePoint0 = function ()\n\t{\n\t\tthis.X = 0;\n\t\tthis.Y = 0;\n\t};\n\n\tClipperLib.DoublePoint0.prototype = ClipperLib.DoublePoint.prototype;\n\n\t// This is internal faster function when called with 1 argument (dp or ip)\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.DoublePoint1 = function (dp)\n\t{\n\t\tthis.X = dp.X;\n\t\tthis.Y = dp.Y;\n\t};\n\n\tClipperLib.DoublePoint1.prototype = ClipperLib.DoublePoint.prototype;\n\n\t// This is internal faster function when called with 2 arguments (x and y)\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.DoublePoint2 = function (x, y)\n\t{\n\t\tthis.X = x;\n\t\tthis.Y = y;\n\t};\n\n\tClipperLib.DoublePoint2.prototype = ClipperLib.DoublePoint.prototype;\n\n\t// PolyTree & PolyNode start\n\t/**\n\t* @suppress {missingProperties}\n\t*/\n\tClipperLib.PolyNode = function ()\n\t{\n\t\tthis.m_Parent = null;\n\t\tthis.m_polygon = new ClipperLib.Path();\n\t\tthis.m_Index = 0;\n\t\tthis.m_jointype = 0;\n\t\tthis.m_endtype = 0;\n\t\tthis.m_Childs = [];\n\t\tthis.IsOpen = false;\n\t};\n\n\tClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t{\n\t\tvar result = true;\n\t\tvar node = this.m_Parent;\n\t\twhile (node !== null)\n\t\t{\n\t\t\tresult = !result;\n\t\t\tnode = node.m_Parent;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.PolyNode.prototype.ChildCount = function ()\n\t{\n\t\treturn this.m_Childs.length;\n\t};\n\n\tClipperLib.PolyNode.prototype.Contour = function ()\n\t{\n\t\treturn this.m_polygon;\n\t};\n\n\tClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t{\n\t\tvar cnt = this.m_Childs.length;\n\t\tthis.m_Childs.push(Child);\n\t\tChild.m_Parent = this;\n\t\tChild.m_Index = cnt;\n\t};\n\n\tClipperLib.PolyNode.prototype.GetNext = function ()\n\t{\n\t\tif (this.m_Childs.length > 0)\n\t\t\treturn this.m_Childs[0];\n\t\telse\n\t\t\treturn this.GetNextSiblingUp();\n\t};\n\n\tClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t{\n\t\tif (this.m_Parent === null)\n\t\t\treturn null;\n\t\telse if (this.m_Index === this.m_Parent.m_Childs.length - 1)\n\t\t\treturn this.m_Parent.GetNextSiblingUp();\n\t\telse\n\t\t\treturn this.m_Parent.m_Childs[this.m_Index + 1];\n\t};\n\n\tClipperLib.PolyNode.prototype.Childs = function ()\n\t{\n\t\treturn this.m_Childs;\n\t};\n\n\tClipperLib.PolyNode.prototype.Parent = function ()\n\t{\n\t\treturn this.m_Parent;\n\t};\n\n\tClipperLib.PolyNode.prototype.IsHole = function ()\n\t{\n\t\treturn this.IsHoleNode();\n\t};\n\n\t// PolyTree : PolyNode\n\t/**\n\t * @suppress {missingProperties}\n\t * @constructor\n\t */\n\tClipperLib.PolyTree = function ()\n\t{\n\t\tthis.m_AllPolys = [];\n\t\tClipperLib.PolyNode.call(this);\n\t};\n\n\tClipperLib.PolyTree.prototype.Clear = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t\t\tthis.m_AllPolys[i] = null;\n\t\tthis.m_AllPolys.length = 0;\n\t\tthis.m_Childs.length = 0;\n\t};\n\n\tClipperLib.PolyTree.prototype.GetFirst = function ()\n\t{\n\t\tif (this.m_Childs.length > 0)\n\t\t\treturn this.m_Childs[0];\n\t\telse\n\t\t\treturn null;\n\t};\n\n\tClipperLib.PolyTree.prototype.Total = function ()\n\t{\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] !== this.m_AllPolys[0]) result--;\n\t\treturn result;\n\t};\n\n\tInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\n\t// PolyTree & PolyNode end\n\n\tClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t{\n\t\treturn Math.abs(a);\n\t};\n\n\tClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t{\n\t\treturn Math.max(a, b);\n\t};\n\n\t/*\n\t-----------------------------------\n\tcast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t-----------------------------------\n\t*/\n\tif (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t{\n\t\treturn a | 0;\n\t};\n\n\telse ClipperLib.Cast_Int32 = function (a)\n\t{ // eg. browser.chrome || browser.chromium || browser.firefox\n\t\treturn ~~a;\n\t};\n\n\t/*\n\t--------------------------\n\tcast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\tChrome: bitwise_not_floor\n\tFirefox17: toInteger (typeof test)\n\tIE9: bitwise_or_floor\n\tIE7 and IE8: to_parseint\n\tChromium: to_floor_or_ceil\n\tFirefox3: to_floor_or_ceil\n\tFirefox15: to_floor_or_ceil\n\tOpera: to_floor_or_ceil\n\tSafari: to_floor_or_ceil\n\t--------------------------\n\t*/\n\tif (typeof Number.toInteger === \"undefined\")\n\t\tNumber.toInteger = null;\n\n\tif (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t{\n\t\tif (a < -2147483648 || a > 2147483647)\n\t\t\treturn a < 0 ? Math.ceil(a) : Math.floor(a);\n\t\telse return ~~a;\n\t};\n\n\telse if (browser.firefox && typeof (Number.toInteger) === \"function\") ClipperLib.Cast_Int64 = function (a)\n\t{\n\t\treturn Number.toInteger(a);\n\t};\n\n\telse if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t{\n\t\treturn parseInt(a, 10);\n\t};\n\n\telse if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t{\n\t\tif (a < -2147483648 || a > 2147483647)\n\t\t\treturn a < 0 ? Math.ceil(a) : Math.floor(a);\n\t\treturn a | 0;\n\t};\n\n\t// eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\telse ClipperLib.Cast_Int64 = function (a)\n\t{\n\t\treturn a < 0 ? Math.ceil(a) : Math.floor(a);\n\t};\n\n\tClipperLib.Clear = function (a)\n\t{\n\t\ta.length = 0;\n\t};\n\n\t//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\tClipperLib.PI = 3.141592653589793;\n\tClipperLib.PI2 = 2 * 3.141592653589793;\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntPoint = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tthis.X = 0;\n\t\tthis.Y = 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tthis.Z = 0;\n\t\t\tif (alen === 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t\tthis.Z = a[2];\n\t\t\t}\n\t\t\telse if (alen === 2) // public IntPoint(cInt x, cInt y)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t\tthis.Z = 0;\n\t\t\t}\n\t\t\telse if (alen === 1)\n\t\t\t{\n\t\t\t\tif (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t\t\t\t{\n\t\t\t\t\tvar dp = a[0];\n\t\t\t\t\tthis.X = ClipperLib.Clipper.Round(dp.X);\n\t\t\t\t\tthis.Y = ClipperLib.Clipper.Round(dp.Y);\n\t\t\t\t\tthis.Z = 0;\n\t\t\t\t}\n\t\t\t\telse // public IntPoint(IntPoint pt)\n\t\t\t\t{\n\t\t\t\t\tvar pt = a[0];\n\t\t\t\t\tif (typeof (pt.Z) === \"undefined\") pt.Z = 0;\n\t\t\t\t\tthis.X = pt.X;\n\t\t\t\t\tthis.Y = pt.Y;\n\t\t\t\t\tthis.Z = pt.Z;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse // public IntPoint()\n\t\t\t{\n\t\t\t\tthis.X = 0;\n\t\t\t\tthis.Y = 0;\n\t\t\t\tthis.Z = 0;\n\t\t\t}\n\t\t}\n\t\telse // if (!ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (alen === 2) // public IntPoint(cInt X, cInt Y)\n\t\t\t{\n\t\t\t\tthis.X = a[0];\n\t\t\t\tthis.Y = a[1];\n\t\t\t}\n\t\t\telse if (alen === 1)\n\t\t\t{\n\t\t\t\tif (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t\t\t\t{\n\t\t\t\t\tvar dp = a[0];\n\t\t\t\t\tthis.X = ClipperLib.Clipper.Round(dp.X);\n\t\t\t\t\tthis.Y = ClipperLib.Clipper.Round(dp.Y);\n\t\t\t\t}\n\t\t\t\telse // public IntPoint(IntPoint pt)\n\t\t\t\t{\n\t\t\t\t\tvar pt = a[0];\n\t\t\t\t\tthis.X = pt.X;\n\t\t\t\t\tthis.Y = pt.Y;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse // public IntPoint(IntPoint pt)\n\t\t\t{\n\t\t\t\tthis.X = 0;\n\t\t\t\tthis.Y = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.IntPoint.op_Equality = function (a, b)\n\t{\n\t\t//return a == b;\n\t\treturn a.X === b.X && a.Y === b.Y;\n\t};\n\n\tClipperLib.IntPoint.op_Inequality = function (a, b)\n\t{\n\t\t//return a !== b;\n\t\treturn a.X !== b.X || a.Y !== b.Y;\n\t};\n\n\t/*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n\tif (obj === null)\n\t\treturn false;\n\tif (obj instanceof ClipperLib.IntPoint)\n\t{\n\t\tvar a = Cast(obj, ClipperLib.IntPoint);\n\t\treturn (this.X == a.X) && (this.Y == a.Y);\n\t}\n\telse\n\t\treturn false;\n  };\n\n\t*/\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntPoint0 = function ()\n\t{\n\t\tthis.X = 0;\n\t\tthis.Y = 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.Z = 0;\n\t};\n\n\tClipperLib.IntPoint0.prototype = ClipperLib.IntPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntPoint1 = function (pt)\n\t{\n\t\tthis.X = pt.X;\n\t\tthis.Y = pt.Y;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (typeof pt.Z === \"undefined\") this.Z = 0;\n\t\t\telse this.Z = pt.Z;\n\t\t}\n\t};\n\n\tClipperLib.IntPoint1.prototype = ClipperLib.IntPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntPoint1dp = function (dp)\n\t{\n\t\tthis.X = ClipperLib.Clipper.Round(dp.X);\n\t\tthis.Y = ClipperLib.Clipper.Round(dp.Y);\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.Z = 0;\n\t};\n\n\tClipperLib.IntPoint1dp.prototype = ClipperLib.IntPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntPoint2 = function (x, y, z)\n\t{\n\t\tthis.X = x;\n\t\tthis.Y = y;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tif (typeof z === \"undefined\") this.Z = 0;\n\t\t\telse this.Z = z;\n\t\t}\n\t};\n\n\tClipperLib.IntPoint2.prototype = ClipperLib.IntPoint.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntRect = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tif (alen === 4) // function (l, t, r, b)\n\t\t{\n\t\t\tthis.left = a[0];\n\t\t\tthis.top = a[1];\n\t\t\tthis.right = a[2];\n\t\t\tthis.bottom = a[3];\n\t\t}\n\t\telse if (alen === 1) // function (ir)\n\t\t{\n\t\t\tvar ir = a[0];\n\t\t\tthis.left = ir.left;\n\t\t\tthis.top = ir.top;\n\t\t\tthis.right = ir.right;\n\t\t\tthis.bottom = ir.bottom;\n\t\t}\n\t\telse // function ()\n\t\t{\n\t\t\tthis.left = 0;\n\t\t\tthis.top = 0;\n\t\t\tthis.right = 0;\n\t\t\tthis.bottom = 0;\n\t\t}\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntRect0 = function ()\n\t{\n\t\tthis.left = 0;\n\t\tthis.top = 0;\n\t\tthis.right = 0;\n\t\tthis.bottom = 0;\n\t};\n\n\tClipperLib.IntRect0.prototype = ClipperLib.IntRect.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntRect1 = function (ir)\n\t{\n\t\tthis.left = ir.left;\n\t\tthis.top = ir.top;\n\t\tthis.right = ir.right;\n\t\tthis.bottom = ir.bottom;\n\t};\n\n\tClipperLib.IntRect1.prototype = ClipperLib.IntRect.prototype;\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntRect4 = function (l, t, r, b)\n\t{\n\t\tthis.left = l;\n\t\tthis.top = t;\n\t\tthis.right = r;\n\t\tthis.bottom = b;\n\t};\n\n\tClipperLib.IntRect4.prototype = ClipperLib.IntRect.prototype;\n\n\tClipperLib.ClipType = {\n\t\tctIntersection: 0,\n\t\tctUnion: 1,\n\t\tctDifference: 2,\n\t\tctXor: 3\n\t};\n\n\tClipperLib.PolyType = {\n\t\tptSubject: 0,\n\t\tptClip: 1\n\t};\n\n\tClipperLib.PolyFillType = {\n\t\tpftEvenOdd: 0,\n\t\tpftNonZero: 1,\n\t\tpftPositive: 2,\n\t\tpftNegative: 3\n\t};\n\n\tClipperLib.JoinType = {\n\t\tjtSquare: 0,\n\t\tjtRound: 1,\n\t\tjtMiter: 2\n\t};\n\n\tClipperLib.EndType = {\n\t\tetOpenSquare: 0,\n\t\tetOpenRound: 1,\n\t\tetOpenButt: 2,\n\t\tetClosedLine: 3,\n\t\tetClosedPolygon: 4\n\t};\n\n\tClipperLib.EdgeSide = {\n\t\tesLeft: 0,\n\t\tesRight: 1\n\t};\n\n\tClipperLib.Direction = {\n\t\tdRightToLeft: 0,\n\t\tdLeftToRight: 1\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.TEdge = function ()\n\t{\n\t\tthis.Bot = new ClipperLib.IntPoint0();\n\t\tthis.Curr = new ClipperLib.IntPoint0(); //current (updated for every new scanbeam)\n\t\tthis.Top = new ClipperLib.IntPoint0();\n\t\tthis.Delta = new ClipperLib.IntPoint0();\n\t\tthis.Dx = 0;\n\t\tthis.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t\tthis.Side = ClipperLib.EdgeSide.esLeft; //side only refers to current side of solution poly\n\t\tthis.WindDelta = 0; //1 or -1 depending on winding direction\n\t\tthis.WindCnt = 0;\n\t\tthis.WindCnt2 = 0; //winding count of the opposite polytype\n\t\tthis.OutIdx = 0;\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t\tthis.NextInLML = null;\n\t\tthis.NextInAEL = null;\n\t\tthis.PrevInAEL = null;\n\t\tthis.NextInSEL = null;\n\t\tthis.PrevInSEL = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.IntersectNode = function ()\n\t{\n\t\tthis.Edge1 = null;\n\t\tthis.Edge2 = null;\n\t\tthis.Pt = new ClipperLib.IntPoint0();\n\t};\n\n\tClipperLib.MyIntersectNodeSort = function () {};\n\n\tClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t{\n\t\tvar i = node2.Pt.Y - node1.Pt.Y;\n\t\tif (i > 0) return 1;\n\t\telse if (i < 0) return -1;\n\t\telse return 0;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.LocalMinima = function ()\n\t{\n\t\tthis.Y = 0;\n\t\tthis.LeftBound = null;\n\t\tthis.RightBound = null;\n\t\tthis.Next = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Scanbeam = function ()\n\t{\n\t\tthis.Y = 0;\n\t\tthis.Next = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Maxima = function ()\n\t{\n\t\tthis.X = 0;\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t};\n\n\t//OutRec: contains a path in the clipping solution. Edges in the AEL will\n\t//carry a pointer to an OutRec when they are part of the clipping solution.\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.OutRec = function ()\n\t{\n\t\tthis.Idx = 0;\n\t\tthis.IsHole = false;\n\t\tthis.IsOpen = false;\n\t\tthis.FirstLeft = null; //see comments in clipper.pas\n\t\tthis.Pts = null;\n\t\tthis.BottomPt = null;\n\t\tthis.PolyNode = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.OutPt = function ()\n\t{\n\t\tthis.Idx = 0;\n\t\tthis.Pt = new ClipperLib.IntPoint0();\n\t\tthis.Next = null;\n\t\tthis.Prev = null;\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.Join = function ()\n\t{\n\t\tthis.OutPt1 = null;\n\t\tthis.OutPt2 = null;\n\t\tthis.OffPt = new ClipperLib.IntPoint0();\n\t};\n\n\tClipperLib.ClipperBase = function ()\n\t{\n\t\tthis.m_MinimaList = null;\n\t\tthis.m_CurrentLM = null;\n\t\tthis.m_edges = new Array();\n\t\tthis.m_UseFullRange = false;\n\t\tthis.m_HasOpenPaths = false;\n\t\tthis.PreserveCollinear = false;\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_PolyOuts = null;\n\t\tthis.m_ActiveEdges = null;\n\t};\n\n\t// Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t// protected const double horizontal = -3.4E+38;\n\t// internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t// internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t// So had to adjust them to more suitable for Javascript.\n\t// If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t// and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\tClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\tClipperLib.ClipperBase.Skip = -2;\n\tClipperLib.ClipperBase.Unassigned = -1;\n\tClipperLib.ClipperBase.tolerance = 1E-20;\n\tClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\tClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\n\tClipperLib.ClipperBase.near_zero = function (val)\n\t{\n\t\treturn (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t};\n\n\tClipperLib.ClipperBase.IsHorizontal = function (e)\n\t{\n\t\treturn e.Delta.Y === 0;\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t{\n\t\tvar pp2 = pp;\n\t\tdo {\n\t\t\tif (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t\t\t\treturn true;\n\t\t\tpp2 = pp2.Next;\n\t\t}\n\t\twhile (pp2 !== pp)\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t{\n\t\tif (UseFullRange)\n\t\t\treturn ((pt.X === linePt1.X) && (pt.Y === linePt1.Y)) ||\n\t\t\t\t((pt.X === linePt2.X) && (pt.Y === linePt2.Y)) ||\n\t\t\t\t(((pt.X > linePt1.X) === (pt.X < linePt2.X)) &&\n\t\t\t\t\t((pt.Y > linePt1.Y) === (pt.Y < linePt2.Y)) &&\n\t\t\t\t\t(Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t\t\t\t\t\tInt128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t\telse\n\t\t\treturn ((pt.X === linePt1.X) && (pt.Y === linePt1.Y)) || ((pt.X === linePt2.X) && (pt.Y === linePt2.Y)) || (((pt.X > linePt1.X) === (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) === (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) === (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t};\n\n\tClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t{\n\t\tvar pp2 = pp;\n\t\twhile (true)\n\t\t{\n\t\t\tif (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t\t\t\treturn true;\n\t\t\tpp2 = pp2.Next;\n\t\t\tif (pp2 === pp)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length;\n\t\tvar e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t\tif (alen === 3) // function (e1, e2, UseFullRange)\n\t\t{\n\t\t\te1 = a[0];\n\t\t\te2 = a[1];\n\t\t\tUseFullRange = a[2];\n\t\t\tif (UseFullRange)\n\t\t\t\treturn Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t\t\telse\n\t\t\t\treturn ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) === ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t\t}\n\t\telse if (alen === 4) // function (pt1, pt2, pt3, UseFullRange)\n\t\t{\n\t\t\tpt1 = a[0];\n\t\t\tpt2 = a[1];\n\t\t\tpt3 = a[2];\n\t\t\tUseFullRange = a[3];\n\t\t\tif (UseFullRange)\n\t\t\t\treturn Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t\t\telse\n\t\t\t\treturn ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t\t}\n\t\telse // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t\t{\n\t\t\tpt1 = a[0];\n\t\t\tpt2 = a[1];\n\t\t\tpt3 = a[2];\n\t\t\tpt4 = a[3];\n\t\t\tUseFullRange = a[4];\n\t\t\tif (UseFullRange)\n\t\t\t\treturn Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t\t\telse\n\t\t\t\treturn ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t{\n\t\tif (UseFullRange)\n\t\t\treturn Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t\telse\n\t\t\treturn ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) === ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t{\n\t\tif (UseFullRange)\n\t\t\treturn Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t\telse\n\t\t\treturn ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t};\n\n\tClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t{\n\t\tif (UseFullRange)\n\t\t\treturn Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t\telse\n\t\t\treturn ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t};\n\n\tClipperLib.ClipperBase.prototype.Clear = function ()\n\t{\n\t\tthis.DisposeLocalMinimaList();\n\t\tfor (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t\t{\n\t\t\tfor (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t\t\t\tthis.m_edges[i][j] = null;\n\t\t\tClipperLib.Clear(this.m_edges[i]);\n\t\t}\n\t\tClipperLib.Clear(this.m_edges);\n\t\tthis.m_UseFullRange = false;\n\t\tthis.m_HasOpenPaths = false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t{\n\t\twhile (this.m_MinimaList !== null)\n\t\t{\n\t\t\tvar tmpLm = this.m_MinimaList.Next;\n\t\t\tthis.m_MinimaList = null;\n\t\t\tthis.m_MinimaList = tmpLm;\n\t\t}\n\t\tthis.m_CurrentLM = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t{\n\t\tif (useFullRange.Value)\n\t\t{\n\t\t\tif (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t\t\t\tClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t\t}\n\t\telse if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t\t{\n\t\t\tuseFullRange.Value = true;\n\t\t\tthis.RangeTest(Pt, useFullRange);\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t{\n\t\te.Next = eNext;\n\t\te.Prev = ePrev;\n\t\t//e.Curr = pt;\n\t\te.Curr.X = pt.X;\n\t\te.Curr.Y = pt.Y;\n\t\tif (ClipperLib.use_xyz) e.Curr.Z = pt.Z;\n\t\te.OutIdx = -1;\n\t};\n\n\tClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t{\n\t\tif (e.Curr.Y >= e.Next.Curr.Y)\n\t\t{\n\t\t\t//e.Bot = e.Curr;\n\t\t\te.Bot.X = e.Curr.X;\n\t\t\te.Bot.Y = e.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Bot.Z = e.Curr.Z;\n\t\t\t//e.Top = e.Next.Curr;\n\t\t\te.Top.X = e.Next.Curr.X;\n\t\t\te.Top.Y = e.Next.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Top.Z = e.Next.Curr.Z;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//e.Top = e.Curr;\n\t\t\te.Top.X = e.Curr.X;\n\t\t\te.Top.Y = e.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Top.Z = e.Curr.Z;\n\t\t\t//e.Bot = e.Next.Curr;\n\t\t\te.Bot.X = e.Next.Curr.X;\n\t\t\te.Bot.Y = e.Next.Curr.Y;\n\t\t\tif (ClipperLib.use_xyz) e.Bot.Z = e.Next.Curr.Z;\n\t\t}\n\t\tthis.SetDx(e);\n\t\te.PolyTyp = polyType;\n\t};\n\n\tClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t{\n\t\tvar E2;\n\t\tfor (;;)\n\t\t{\n\t\t\twhile (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t\t\t\tE = E.Next;\n\t\t\tif (E.Dx !== ClipperLib.ClipperBase.horizontal && E.Prev.Dx !== ClipperLib.ClipperBase.horizontal)\n\t\t\t\tbreak;\n\t\t\twhile (E.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\tE = E.Prev;\n\t\t\tE2 = E;\n\t\t\twhile (E.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\tE = E.Next;\n\t\t\tif (E.Top.Y === E.Prev.Bot.Y)\n\t\t\t\tcontinue;\n\t\t\t//ie just an intermediate horz.\n\t\t\tif (E2.Prev.Bot.X < E.Bot.X)\n\t\t\t\tE = E2;\n\t\t\tbreak;\n\t\t}\n\t\treturn E;\n\t};\n\n\tClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t{\n\t\tvar EStart;\n\t\tvar Result = E;\n\t\tvar Horz;\n\n\t\tif (Result.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t{\n\t\t\t//check if there are edges beyond the skip edge in the bound and if so\n\t\t\t//create another LocMin and calling ProcessBound once more ...\n\t\t\tE = Result;\n\t\t\tif (LeftBoundIsForward)\n\t\t\t{\n\t\t\t\twhile (E.Top.Y === E.Next.Bot.Y) E = E.Next;\n\t\t\t\twhile (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (E.Top.Y === E.Prev.Bot.Y) E = E.Prev;\n\t\t\t\twhile (E !== Result && E.Dx === ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t\t\t}\n\t\t\tif (E === Result)\n\t\t\t{\n\t\t\t\tif (LeftBoundIsForward) Result = E.Next;\n\t\t\t\telse Result = E.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//there are more edges in the bound beyond result starting with E\n\t\t\t\tif (LeftBoundIsForward)\n\t\t\t\t\tE = Result.Next;\n\t\t\t\telse\n\t\t\t\t\tE = Result.Prev;\n\t\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\t\tlocMin.Next = null;\n\t\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\t\tlocMin.LeftBound = null;\n\t\t\t\tlocMin.RightBound = E;\n\t\t\t\tE.WindDelta = 0;\n\t\t\t\tResult = this.ProcessBound(E, LeftBoundIsForward);\n\t\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\t}\n\t\t\treturn Result;\n\t\t}\n\n\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t{\n\t\t\t//We need to be careful with open paths because this may not be a\n\t\t\t//true local minima (ie E may be following a skip edge).\n\t\t\t//Also, consecutive horz. edges may start heading left before going right.\n\t\t\tif (LeftBoundIsForward) EStart = E.Prev;\n\t\t\telse EStart = E.Next;\n\n\t\t\tif (EStart.Dx === ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t\t\t{\n\t\t\t\tif (EStart.Bot.X !== E.Bot.X && EStart.Top.X !== E.Bot.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t}\n\t\t\telse if (EStart.Bot.X !== E.Bot.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t}\n\n\t\tEStart = E;\n\t\tif (LeftBoundIsForward)\n\t\t{\n\t\t\twhile (Result.Top.Y === Result.Next.Bot.Y && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t\tResult = Result.Next;\n\t\t\tif (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t{\n\t\t\t\t//nb: at the top of a bound, horizontals are added to the bound\n\t\t\t\t//only when the preceding edge attaches to the horizontal's left vertex\n\t\t\t\t//unless a Skip edge is encountered when that becomes the top divide\n\t\t\t\tHorz = Result;\n\t\t\t\twhile (Horz.Prev.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\t\tHorz = Horz.Prev;\n\t\t\t\tif (Horz.Prev.Top.X > Result.Next.Top.X)\n\t\t\t\t\tResult = Horz.Prev;\n\t\t\t}\n\t\t\twhile (E !== Result)\n\t\t\t{\n\t\t\t\tE.NextInLML = E.Next;\n\t\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Prev.Top.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t\tE = E.Next;\n\t\t\t}\n\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Prev.Top.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\tResult = Result.Next;\n\t\t\t//move to the edge just beyond current bound\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (Result.Top.Y === Result.Prev.Bot.Y && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t\tResult = Result.Prev;\n\t\t\tif (Result.Dx === ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx !== ClipperLib.ClipperBase.Skip)\n\t\t\t{\n\t\t\t\tHorz = Result;\n\t\t\t\twhile (Horz.Next.Dx === ClipperLib.ClipperBase.horizontal)\n\t\t\t\t\tHorz = Horz.Next;\n\t\t\t\tif (Horz.Next.Top.X === Result.Prev.Top.X || Horz.Next.Top.X > Result.Prev.Top.X)\n\t\t\t\t{\n\t\t\t\t\tResult = Horz.Next;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (E !== Result)\n\t\t\t{\n\t\t\t\tE.NextInLML = E.Prev;\n\t\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Next.Top.X)\n\t\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\t\tE = E.Prev;\n\t\t\t}\n\t\t\tif (E.Dx === ClipperLib.ClipperBase.horizontal && E !== EStart && E.Bot.X !== E.Next.Top.X)\n\t\t\t\tthis.ReverseHorizontal(E);\n\t\t\tResult = Result.Prev;\n\t\t\t//move to the edge just beyond current bound\n\t\t}\n\n\t\treturn Result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t{\n\t\tif (ClipperLib.use_lines)\n\t\t{\n\t\t\tif (!Closed && polyType === ClipperLib.PolyType.ptClip)\n\t\t\t\tClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!Closed)\n\t\t\t\tClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t\t}\n\t\tvar highI = pg.length - 1;\n\t\tif (Closed)\n\t\t\twhile (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t\t\t\t--highI;\n\t\twhile (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t\t\t--highI;\n\t\tif ((Closed && highI < 2) || (!Closed && highI < 1))\n\t\t\treturn false;\n\t\t//create a new edge array ...\n\t\tvar edges = new Array();\n\t\tfor (var i = 0; i <= highI; i++)\n\t\t\tedges.push(new ClipperLib.TEdge());\n\t\tvar IsFlat = true;\n\t\t//1. Basic (first) edge initialization ...\n\n\t\t//edges[1].Curr = pg[1];\n\t\tedges[1].Curr.X = pg[1].X;\n\t\tedges[1].Curr.Y = pg[1].Y;\n\t\tif (ClipperLib.use_xyz) edges[1].Curr.Z = pg[1].Z;\n\n\t\tvar $1 = {\n\t\t\tValue: this.m_UseFullRange\n\t\t};\n\n\t\tthis.RangeTest(pg[0], $1);\n\t\tthis.m_UseFullRange = $1.Value;\n\n\t\t$1.Value = this.m_UseFullRange;\n\t\tthis.RangeTest(pg[highI], $1);\n\t\tthis.m_UseFullRange = $1.Value;\n\n\t\tthis.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t\tthis.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t\tfor (var i = highI - 1; i >= 1; --i)\n\t\t{\n\t\t\t$1.Value = this.m_UseFullRange;\n\t\t\tthis.RangeTest(pg[i], $1);\n\t\t\tthis.m_UseFullRange = $1.Value;\n\n\t\t\tthis.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t\t}\n\n\t\tvar eStart = edges[0];\n\t\t//2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t\tvar E = eStart,\n\t\t\teLoopStop = eStart;\n\t\tfor (;;)\n\t\t{\n\t\t\t//console.log(E.Next, eStart);\n\t\t\t//nb: allows matching start and end points when not Closed ...\n\t\t\tif (E.Curr === E.Next.Curr && (Closed || E.Next !== eStart))\n\t\t\t{\n\t\t\t\tif (E === E.Next)\n\t\t\t\t\tbreak;\n\t\t\t\tif (E === eStart)\n\t\t\t\t\teStart = E.Next;\n\t\t\t\tE = this.RemoveEdge(E);\n\t\t\t\teLoopStop = E;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (E.Prev === E.Next)\n\t\t\t\tbreak;\n\t\t\telse if (Closed && ClipperLib.ClipperBase.SlopesEqual4(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t\t\t{\n\t\t\t\t//Collinear edges are allowed for open paths but in closed paths\n\t\t\t\t//the default is to merge adjacent collinear edges into a single edge.\n\t\t\t\t//However, if the PreserveCollinear property is enabled, only overlapping\n\t\t\t\t//collinear edges (ie spikes) will be removed from closed paths.\n\t\t\t\tif (E === eStart)\n\t\t\t\t\teStart = E.Next;\n\t\t\t\tE = this.RemoveEdge(E);\n\t\t\t\tE = E.Prev;\n\t\t\t\teLoopStop = E;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tE = E.Next;\n\t\t\tif ((E === eLoopStop) || (!Closed && E.Next === eStart)) break;\n\t\t}\n\t\tif ((!Closed && (E === E.Next)) || (Closed && (E.Prev === E.Next)))\n\t\t\treturn false;\n\t\tif (!Closed)\n\t\t{\n\t\t\tthis.m_HasOpenPaths = true;\n\t\t\teStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t\t}\n\t\t//3. Do second stage of edge initialization ...\n\t\tE = eStart;\n\t\tdo {\n\t\t\tthis.InitEdge2(E, polyType);\n\t\t\tE = E.Next;\n\t\t\tif (IsFlat && E.Curr.Y !== eStart.Curr.Y)\n\t\t\t\tIsFlat = false;\n\t\t}\n\t\twhile (E !== eStart)\n\t\t//4. Finally, add edge bounds to LocalMinima list ...\n\t\t//Totally flat paths must be handled differently when adding them\n\t\t//to LocalMinima list to avoid endless loops etc ...\n\t\tif (IsFlat)\n\t\t{\n\t\t\tif (Closed)\n\t\t\t\treturn false;\n\n\t\t\tE.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\n\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\tlocMin.Next = null;\n\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\tlocMin.LeftBound = null;\n\t\t\tlocMin.RightBound = E;\n\t\t\tlocMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t\t\tlocMin.RightBound.WindDelta = 0;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tif (E.Bot.X !== E.Prev.Top.X) this.ReverseHorizontal(E);\n\t\t\t\tif (E.Next.OutIdx === ClipperLib.ClipperBase.Skip) break;\n\t\t\t\tE.NextInLML = E.Next;\n\t\t\t\tE = E.Next;\n\t\t\t}\n\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\tthis.m_edges.push(edges);\n\t\t\treturn true;\n\t\t}\n\t\tthis.m_edges.push(edges);\n\t\tvar leftBoundIsForward;\n\t\tvar EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n\t\t//open paths have matching start and end points ...\n\t\tif (ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t\t\tE = E.Next;\n\n\t\tfor (;;)\n\t\t{\n\t\t\tE = this.FindNextLocMin(E);\n\t\t\tif (E === EMin)\n\t\t\t\tbreak;\n\t\t\telse if (EMin === null)\n\t\t\t\tEMin = E;\n\t\t\t//E and E.Prev now share a local minima (left aligned if horizontal).\n\t\t\t//Compare their slopes to find which starts which bound ...\n\t\t\tvar locMin = new ClipperLib.LocalMinima();\n\t\t\tlocMin.Next = null;\n\t\t\tlocMin.Y = E.Bot.Y;\n\t\t\tif (E.Dx < E.Prev.Dx)\n\t\t\t{\n\t\t\t\tlocMin.LeftBound = E.Prev;\n\t\t\t\tlocMin.RightBound = E;\n\t\t\t\tleftBoundIsForward = false;\n\t\t\t\t//Q.nextInLML = Q.prev\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlocMin.LeftBound = E;\n\t\t\t\tlocMin.RightBound = E.Prev;\n\t\t\t\tleftBoundIsForward = true;\n\t\t\t\t//Q.nextInLML = Q.next\n\t\t\t}\n\t\t\tlocMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\tlocMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t\t\tif (!Closed)\n\t\t\t\tlocMin.LeftBound.WindDelta = 0;\n\t\t\telse if (locMin.LeftBound.Next === locMin.RightBound)\n\t\t\t\tlocMin.LeftBound.WindDelta = -1;\n\t\t\telse\n\t\t\t\tlocMin.LeftBound.WindDelta = 1;\n\t\t\tlocMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t\t\tE = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t\t\tif (E.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tE = this.ProcessBound(E, leftBoundIsForward);\n\t\t\tvar E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t\t\tif (E2.OutIdx === ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t\t\tif (locMin.LeftBound.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tlocMin.LeftBound = null;\n\t\t\telse if (locMin.RightBound.OutIdx === ClipperLib.ClipperBase.Skip)\n\t\t\t\tlocMin.RightBound = null;\n\t\t\tthis.InsertLocalMinima(locMin);\n\t\t\tif (!leftBoundIsForward)\n\t\t\t\tE = E2;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t{\n\t\t//  console.log(\"-------------------------------------------\");\n\t\t//  console.log(JSON.stringify(ppg));\n\t\tvar result = false;\n\t\tfor (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t\t\tif (this.AddPath(ppg[i], polyType, closed))\n\t\t\t\tresult = true;\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t{\n\t\tif ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) || (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n\t\t\t//if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t\t\treturn false;\n\n\t\telse if (pt1.X !== pt3.X)\n\t\t\treturn (pt2.X > pt1.X) === (pt2.X < pt3.X);\n\t\telse\n\t\t\treturn (pt2.Y > pt1.Y) === (pt2.Y < pt3.Y);\n\t};\n\n\tClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t{\n\t\t//removes e from double_linked_list (but without removing from memory)\n\t\te.Prev.Next = e.Next;\n\t\te.Next.Prev = e.Prev;\n\t\tvar result = e.Next;\n\t\te.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t{\n\t\te.Delta.X = (e.Top.X - e.Bot.X);\n\t\te.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t\tif (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t\telse e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t};\n\n\tClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t{\n\t\tif (this.m_MinimaList === null)\n\t\t{\n\t\t\tthis.m_MinimaList = newLm;\n\t\t}\n\t\telse if (newLm.Y >= this.m_MinimaList.Y)\n\t\t{\n\t\t\tnewLm.Next = this.m_MinimaList;\n\t\t\tthis.m_MinimaList = newLm;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmpLm = this.m_MinimaList;\n\t\t\twhile (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t\t\t\ttmpLm = tmpLm.Next;\n\t\t\tnewLm.Next = tmpLm.Next;\n\t\t\ttmpLm.Next = newLm;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.PopLocalMinima = function (Y, current)\n\t{\n\t\tcurrent.v = this.m_CurrentLM;\n\t\tif (this.m_CurrentLM !== null && this.m_CurrentLM.Y === Y)\n\t\t{\n\t\t\tthis.m_CurrentLM = this.m_CurrentLM.Next;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\tClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t{\n\t\t//swap horizontal edges' top and bottom x's so they follow the natural\n\t\t//progression of the bounds - ie so their xbots will align with the\n\t\t//adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t\tvar tmp = e.Top.X;\n\t\te.Top.X = e.Bot.X;\n\t\te.Bot.X = tmp;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\ttmp = e.Top.Z;\n\t\t\te.Top.Z = e.Bot.Z;\n\t\t\te.Bot.Z = tmp;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.Reset = function ()\n\t{\n\t\tthis.m_CurrentLM = this.m_MinimaList;\n\t\tif (this.m_CurrentLM === null) //ie nothing to process\n\t\t\treturn;\n\t\t//reset all edges ...\n\t\tthis.m_Scanbeam = null;\n\t\tvar lm = this.m_MinimaList;\n\t\twhile (lm !== null)\n\t\t{\n\t\t\tthis.InsertScanbeam(lm.Y);\n\t\t\tvar e = lm.LeftBound;\n\t\t\tif (e !== null)\n\t\t\t{\n\t\t\t\t//e.Curr = e.Bot;\n\t\t\t\te.Curr.X = e.Bot.X;\n\t\t\t\te.Curr.Y = e.Bot.Y;\n\t\t\t\tif (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\te = lm.RightBound;\n\t\t\tif (e !== null)\n\t\t\t{\n\t\t\t\t//e.Curr = e.Bot;\n\t\t\t\te.Curr.X = e.Bot.X;\n\t\t\t\te.Curr.Y = e.Bot.Y;\n\t\t\t\tif (ClipperLib.use_xyz) e.Curr.Z = e.Bot.Z;\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tlm = lm.Next;\n\t\t}\n\t\tthis.m_ActiveEdges = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.InsertScanbeam = function (Y)\n\t{\n\t\t//single-linked list: sorted descending, ignoring dups.\n\t\tif (this.m_Scanbeam === null)\n\t\t{\n\t\t\tthis.m_Scanbeam = new ClipperLib.Scanbeam();\n\t\t\tthis.m_Scanbeam.Next = null;\n\t\t\tthis.m_Scanbeam.Y = Y;\n\t\t}\n\t\telse if (Y > this.m_Scanbeam.Y)\n\t\t{\n\t\t\tvar newSb = new ClipperLib.Scanbeam();\n\t\t\tnewSb.Y = Y;\n\t\t\tnewSb.Next = this.m_Scanbeam;\n\t\t\tthis.m_Scanbeam = newSb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar sb2 = this.m_Scanbeam;\n\t\t\twhile (sb2.Next !== null && Y <= sb2.Next.Y)\n\t\t\t{\n\t\t\t\tsb2 = sb2.Next;\n\t\t\t}\n\t\t\tif (Y === sb2.Y)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t} //ie ignores duplicates\n\t\t\tvar newSb1 = new ClipperLib.Scanbeam();\n\t\t\tnewSb1.Y = Y;\n\t\t\tnewSb1.Next = sb2.Next;\n\t\t\tsb2.Next = newSb1;\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.PopScanbeam = function (Y)\n\t{\n\t\tif (this.m_Scanbeam === null)\n\t\t{\n\t\t\tY.v = 0;\n\t\t\treturn false;\n\t\t}\n\t\tY.v = this.m_Scanbeam.Y;\n\t\tthis.m_Scanbeam = this.m_Scanbeam.Next;\n\t\treturn true;\n\t};\n\n\tClipperLib.ClipperBase.prototype.LocalMinimaPending = function ()\n\t{\n\t\treturn (this.m_CurrentLM !== null);\n\t};\n\n\tClipperLib.ClipperBase.prototype.CreateOutRec = function ()\n\t{\n\t\tvar result = new ClipperLib.OutRec();\n\t\tresult.Idx = ClipperLib.ClipperBase.Unassigned;\n\t\tresult.IsHole = false;\n\t\tresult.IsOpen = false;\n\t\tresult.FirstLeft = null;\n\t\tresult.Pts = null;\n\t\tresult.BottomPt = null;\n\t\tresult.PolyNode = null;\n\t\tthis.m_PolyOuts.push(result);\n\t\tresult.Idx = this.m_PolyOuts.length - 1;\n\t\treturn result;\n\t};\n\n\tClipperLib.ClipperBase.prototype.DisposeOutRec = function (index)\n\t{\n\t\tvar outRec = this.m_PolyOuts[index];\n\t\toutRec.Pts = null;\n\t\toutRec = null;\n\t\tthis.m_PolyOuts[index] = null;\n\t};\n\n\tClipperLib.ClipperBase.prototype.UpdateEdgeIntoAEL = function (e)\n\t{\n\t\tif (e.NextInLML === null)\n\t\t{\n\t\t\tClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t\t}\n\t\tvar AelPrev = e.PrevInAEL;\n\t\tvar AelNext = e.NextInAEL;\n\t\te.NextInLML.OutIdx = e.OutIdx;\n\t\tif (AelPrev !== null)\n\t\t{\n\t\t\tAelPrev.NextInAEL = e.NextInLML;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.m_ActiveEdges = e.NextInLML;\n\t\t}\n\t\tif (AelNext !== null)\n\t\t{\n\t\t\tAelNext.PrevInAEL = e.NextInLML;\n\t\t}\n\t\te.NextInLML.Side = e.Side;\n\t\te.NextInLML.WindDelta = e.WindDelta;\n\t\te.NextInLML.WindCnt = e.WindCnt;\n\t\te.NextInLML.WindCnt2 = e.WindCnt2;\n\t\te = e.NextInLML;\n\t\te.Curr.X = e.Bot.X;\n\t\te.Curr.Y = e.Bot.Y;\n\t\te.PrevInAEL = AelPrev;\n\t\te.NextInAEL = AelNext;\n\t\tif (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t\t{\n\t\t\tthis.InsertScanbeam(e.Top.Y);\n\t\t}\n\t\treturn e;\n\t};\n\n\tClipperLib.ClipperBase.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t{\n\t\t//check that one or other edge hasn't already been removed from AEL ...\n\t\tif (edge1.NextInAEL === edge1.PrevInAEL || edge2.NextInAEL === edge2.PrevInAEL)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (edge1.NextInAEL === edge2)\n\t\t{\n\t\t\tvar next = edge2.NextInAEL;\n\t\t\tif (next !== null)\n\t\t\t{\n\t\t\t\tnext.PrevInAEL = edge1;\n\t\t\t}\n\t\t\tvar prev = edge1.PrevInAEL;\n\t\t\tif (prev !== null)\n\t\t\t{\n\t\t\t\tprev.NextInAEL = edge2;\n\t\t\t}\n\t\t\tedge2.PrevInAEL = prev;\n\t\t\tedge2.NextInAEL = edge1;\n\t\t\tedge1.PrevInAEL = edge2;\n\t\t\tedge1.NextInAEL = next;\n\t\t}\n\t\telse if (edge2.NextInAEL === edge1)\n\t\t{\n\t\t\tvar next1 = edge1.NextInAEL;\n\t\t\tif (next1 !== null)\n\t\t\t{\n\t\t\t\tnext1.PrevInAEL = edge2;\n\t\t\t}\n\t\t\tvar prev1 = edge2.PrevInAEL;\n\t\t\tif (prev1 !== null)\n\t\t\t{\n\t\t\t\tprev1.NextInAEL = edge1;\n\t\t\t}\n\t\t\tedge1.PrevInAEL = prev1;\n\t\t\tedge1.NextInAEL = edge2;\n\t\t\tedge2.PrevInAEL = edge1;\n\t\t\tedge2.NextInAEL = next1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar next2 = edge1.NextInAEL;\n\t\t\tvar prev2 = edge1.PrevInAEL;\n\t\t\tedge1.NextInAEL = edge2.NextInAEL;\n\t\t\tif (edge1.NextInAEL !== null)\n\t\t\t{\n\t\t\t\tedge1.NextInAEL.PrevInAEL = edge1;\n\t\t\t}\n\t\t\tedge1.PrevInAEL = edge2.PrevInAEL;\n\t\t\tif (edge1.PrevInAEL !== null)\n\t\t\t{\n\t\t\t\tedge1.PrevInAEL.NextInAEL = edge1;\n\t\t\t}\n\t\t\tedge2.NextInAEL = next2;\n\t\t\tif (edge2.NextInAEL !== null)\n\t\t\t{\n\t\t\t\tedge2.NextInAEL.PrevInAEL = edge2;\n\t\t\t}\n\t\t\tedge2.PrevInAEL = prev2;\n\t\t\tif (edge2.PrevInAEL !== null)\n\t\t\t{\n\t\t\t\tedge2.PrevInAEL.NextInAEL = edge2;\n\t\t\t}\n\t\t}\n\n\t\tif (edge1.PrevInAEL === null)\n\t\t{\n\t\t\tthis.m_ActiveEdges = edge1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (edge2.PrevInAEL === null)\n\t\t\t{\n\t\t\t\tthis.m_ActiveEdges = edge2;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperBase.prototype.DeleteFromAEL = function (e)\n\t{\n\t\tvar AelPrev = e.PrevInAEL;\n\t\tvar AelNext = e.NextInAEL;\n\t\tif (AelPrev === null && AelNext === null && e !== this.m_ActiveEdges)\n\t\t{\n\t\t\treturn;\n\t\t} //already deleted\n\t\tif (AelPrev !== null)\n\t\t{\n\t\t\tAelPrev.NextInAEL = AelNext;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.m_ActiveEdges = AelNext;\n\t\t}\n\t\tif (AelNext !== null)\n\t\t{\n\t\t\tAelNext.PrevInAEL = AelPrev;\n\t\t}\n\t\te.NextInAEL = null;\n\t\te.PrevInAEL = null;\n\t}\n\n\t// public Clipper(int InitOptions = 0)\n\t/**\n\t * @suppress {missingProperties}\n\t */\n\tClipperLib.Clipper = function (InitOptions)\n\t{\n\t\tif (typeof (InitOptions) === \"undefined\") InitOptions = 0;\n\t\tthis.m_PolyOuts = null;\n\t\tthis.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_Maxima = null;\n\t\tthis.m_ActiveEdges = null;\n\t\tthis.m_SortedEdges = null;\n\t\tthis.m_IntersectList = null;\n\t\tthis.m_IntersectNodeComparer = null;\n\t\tthis.m_ExecuteLocked = false;\n\t\tthis.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tthis.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tthis.m_Joins = null;\n\t\tthis.m_GhostJoins = null;\n\t\tthis.m_UsingPolyTree = false;\n\t\tthis.ReverseSolution = false;\n\t\tthis.StrictlySimple = false;\n\n\t\tClipperLib.ClipperBase.call(this);\n\n\t\tthis.m_Scanbeam = null;\n\t\tthis.m_Maxima = null;\n\t\tthis.m_ActiveEdges = null;\n\t\tthis.m_SortedEdges = null;\n\t\tthis.m_IntersectList = new Array();\n\t\tthis.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t\tthis.m_ExecuteLocked = false;\n\t\tthis.m_UsingPolyTree = false;\n\t\tthis.m_PolyOuts = new Array();\n\t\tthis.m_Joins = new Array();\n\t\tthis.m_GhostJoins = new Array();\n\t\tthis.ReverseSolution = (1 & InitOptions) !== 0;\n\t\tthis.StrictlySimple = (2 & InitOptions) !== 0;\n\t\tthis.PreserveCollinear = (4 & InitOptions) !== 0;\n\t\tif (ClipperLib.use_xyz)\n\t\t{\n\t\t\tthis.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.ioReverseSolution = 1;\n\tClipperLib.Clipper.ioStrictlySimple = 2;\n\tClipperLib.Clipper.ioPreserveCollinear = 4;\n\n\tClipperLib.Clipper.prototype.Clear = function ()\n\t{\n\t\tif (this.m_edges.length === 0)\n\t\t\treturn;\n\t\t//avoids problems with ClipperBase destructor\n\t\tthis.DisposeAllPolyPts();\n\t\tClipperLib.ClipperBase.prototype.Clear.call(this);\n\t};\n\n\tClipperLib.Clipper.prototype.InsertMaxima = function (X)\n\t{\n\t\t//double-linked list: sorted ascending, ignoring dups.\n\t\tvar newMax = new ClipperLib.Maxima();\n\t\tnewMax.X = X;\n\t\tif (this.m_Maxima === null)\n\t\t{\n\t\t\tthis.m_Maxima = newMax;\n\t\t\tthis.m_Maxima.Next = null;\n\t\t\tthis.m_Maxima.Prev = null;\n\t\t}\n\t\telse if (X < this.m_Maxima.X)\n\t\t{\n\t\t\tnewMax.Next = this.m_Maxima;\n\t\t\tnewMax.Prev = null;\n\t\t\tthis.m_Maxima = newMax;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar m = this.m_Maxima;\n\t\t\twhile (m.Next !== null && X >= m.Next.X)\n\t\t\t{\n\t\t\t\tm = m.Next;\n\t\t\t}\n\t\t\tif (X === m.X)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t} //ie ignores duplicates (& CG to clean up newMax)\n\t\t\t//insert newMax between m and m.Next ...\n\t\t\tnewMax.Next = m.Next;\n\t\t\tnewMax.Prev = m;\n\t\t\tif (m.Next !== null)\n\t\t\t{\n\t\t\t\tm.Next.Prev = newMax;\n\t\t\t}\n\t\t\tm.Next = newMax;\n\t\t}\n\t};\n\n\t// ************************************\n\tClipperLib.Clipper.prototype.Execute = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\talen = a.length,\n\t\t\tispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t\tif (alen === 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tsolution = a[1],\n\t\t\t\tsubjFillType = a[2],\n\t\t\t\tclipFillType = a[3];\n\t\t\tif (this.m_ExecuteLocked)\n\t\t\t\treturn false;\n\t\t\tif (this.m_HasOpenPaths)\n\t\t\t\tClipperLib.Error(\"Error: PolyTree struct is needed for open path clipping.\");\n\t\t\tthis.m_ExecuteLocked = true;\n\t\t\tClipperLib.Clear(solution);\n\t\t\tthis.m_SubjFillType = subjFillType;\n\t\t\tthis.m_ClipFillType = clipFillType;\n\t\t\tthis.m_ClipType = clipType;\n\t\t\tthis.m_UsingPolyTree = false;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar succeeded = this.ExecuteInternal();\n\t\t\t\t//build the return polygons ...\n\t\t\t\tif (succeeded) this.BuildResult(solution);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.DisposeAllPolyPts();\n\t\t\t\tthis.m_ExecuteLocked = false;\n\t\t\t}\n\t\t\treturn succeeded;\n\t\t}\n\t\telse if (alen === 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tpolytree = a[1],\n\t\t\t\tsubjFillType = a[2],\n\t\t\t\tclipFillType = a[3];\n\t\t\tif (this.m_ExecuteLocked)\n\t\t\t\treturn false;\n\t\t\tthis.m_ExecuteLocked = true;\n\t\t\tthis.m_SubjFillType = subjFillType;\n\t\t\tthis.m_ClipFillType = clipFillType;\n\t\t\tthis.m_ClipType = clipType;\n\t\t\tthis.m_UsingPolyTree = true;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar succeeded = this.ExecuteInternal();\n\t\t\t\t//build the return polygons ...\n\t\t\t\tif (succeeded) this.BuildResult2(polytree);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.DisposeAllPolyPts();\n\t\t\t\tthis.m_ExecuteLocked = false;\n\t\t\t}\n\t\t\treturn succeeded;\n\t\t}\n\t\telse if (alen === 2 && !ispolytree) // function (clipType, solution)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tsolution = a[1];\n\t\t\treturn this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t\t}\n\t\telse if (alen === 2 && ispolytree) // function (clipType, polytree)\n\t\t{\n\t\t\tvar clipType = a[0],\n\t\t\t\tpolytree = a[1];\n\t\t\treturn this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t{\n\t\t//skip if an outermost polygon or\n\t\t//already already points to the correct FirstLeft ...\n\t\tif (outRec.FirstLeft === null || (outRec.IsHole !== outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t\t\treturn;\n\t\tvar orfl = outRec.FirstLeft;\n\t\twhile (orfl !== null && ((orfl.IsHole === outRec.IsHole) || orfl.Pts === null))\n\t\t\torfl = orfl.FirstLeft;\n\t\toutRec.FirstLeft = orfl;\n\t};\n\n\tClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.Reset();\n\t\t\tthis.m_SortedEdges = null;\n\t\t\tthis.m_Maxima = null;\n\n\t\t\tvar botY = {},\n\t\t\t\ttopY = {};\n\n\t\t\tif (!this.PopScanbeam(botY))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.InsertLocalMinimaIntoAEL(botY.v);\n\t\t\twhile (this.PopScanbeam(topY) || this.LocalMinimaPending())\n\t\t\t{\n\t\t\t\tthis.ProcessHorizontals();\n\t\t\t\tthis.m_GhostJoins.length = 0;\n\t\t\t\tif (!this.ProcessIntersections(topY.v))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.ProcessEdgesAtTopOfScanbeam(topY.v);\n\t\t\t\tbotY.v = topY.v;\n\t\t\t\tthis.InsertLocalMinimaIntoAEL(botY.v);\n\t\t\t}\n\n\t\t\t//fix orientations ...\n\t\t\tvar outRec, i, ilen;\n\t\t\t//fix orientations ...\n\t\t\tfor (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts === null || outRec.IsOpen) continue;\n\t\t\t\tif ((outRec.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec) > 0))\n\t\t\t\t\tthis.ReversePolyPtLinks(outRec.Pts);\n\t\t\t}\n\n\t\t\tthis.JoinCommonEdges();\n\n\t\t\tfor (i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts === null)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (outRec.IsOpen)\n\t\t\t\t\tthis.FixupOutPolyline(outRec);\n\t\t\t\telse\n\t\t\t\t\tthis.FixupOutPolygon(outRec);\n\t\t\t}\n\n\t\t\tif (this.StrictlySimple) this.DoSimplePolygons();\n\t\t\treturn true;\n\t\t}\n\t\t//catch { return false; }\n\t\tfinally\n\t\t{\n\t\t\tthis.m_Joins.length = 0;\n\t\t\tthis.m_GhostJoins.length = 0;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t\t\tthis.DisposeOutRec(i);\n\t\tClipperLib.Clear(this.m_PolyOuts);\n\t};\n\n\tClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t{\n\t\tvar j = new ClipperLib.Join();\n\t\tj.OutPt1 = Op1;\n\t\tj.OutPt2 = Op2;\n\t\t//j.OffPt = OffPt;\n\t\tj.OffPt.X = OffPt.X;\n\t\tj.OffPt.Y = OffPt.Y;\n\t\tif (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;\n\t\tthis.m_Joins.push(j);\n\t};\n\n\tClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t{\n\t\tvar j = new ClipperLib.Join();\n\t\tj.OutPt1 = Op;\n\t\t//j.OffPt = OffPt;\n\t\tj.OffPt.X = OffPt.X;\n\t\tj.OffPt.Y = OffPt.Y;\n\t\tif (ClipperLib.use_xyz) j.OffPt.Z = OffPt.Z;\n\t\tthis.m_GhostJoins.push(j);\n\t};\n\n\t//if (ClipperLib.use_xyz)\n\t//{\n\tClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t{\n\t\tif (this.ZFillFunction !== null)\n\t\t{\n\t\t\tif (pt.Z !== 0 || this.ZFillFunction === null) return;\n\t\t\telse if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t\t\telse if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t\t\telse if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t\t\telse if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t\t\telse this.ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t\t}\n\t};\n\t//}\n\n\tClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t{\n\t\tvar lm = {};\n\n\t\tvar lb;\n\t\tvar rb;\n\t\twhile (this.PopLocalMinima(botY, lm))\n\t\t{\n\t\t\tlb = lm.v.LeftBound;\n\t\t\trb = lm.v.RightBound;\n\n\t\t\tvar Op1 = null;\n\t\t\tif (lb === null)\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(rb, null);\n\t\t\t\tthis.SetWindingCount(rb);\n\t\t\t\tif (this.IsContributing(rb))\n\t\t\t\t\tOp1 = this.AddOutPt(rb, rb.Bot);\n\t\t\t}\n\t\t\telse if (rb === null)\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(lb, null);\n\t\t\t\tthis.SetWindingCount(lb);\n\t\t\t\tif (this.IsContributing(lb))\n\t\t\t\t\tOp1 = this.AddOutPt(lb, lb.Bot);\n\t\t\t\tthis.InsertScanbeam(lb.Top.Y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.InsertEdgeIntoAEL(lb, null);\n\t\t\t\tthis.InsertEdgeIntoAEL(rb, lb);\n\t\t\t\tthis.SetWindingCount(lb);\n\t\t\t\trb.WindCnt = lb.WindCnt;\n\t\t\t\trb.WindCnt2 = lb.WindCnt2;\n\t\t\t\tif (this.IsContributing(lb))\n\t\t\t\t\tOp1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t\t\t\tthis.InsertScanbeam(lb.Top.Y);\n\t\t\t}\n\t\t\tif (rb !== null)\n\t\t\t{\n\t\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t\t\t\t{\n\t\t\t\t\tif (rb.NextInLML !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.InsertScanbeam(rb.NextInLML.Top.Y);\n\t\t\t\t\t}\n\t\t\t\t\tthis.AddEdgeToSEL(rb);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.InsertScanbeam(rb.Top.Y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lb === null || rb === null) continue;\n\t\t\t//if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t\t\tif (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tfor (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t\t\t\t{\n\t\t\t\t\t//if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t\t\t\t\t//the 'ghost' join to a real join ready for later ...\n\t\t\t\t\tvar j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t\t\t\t\t\tthis.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t\t\t\tlb.PrevInAEL.Curr.X === lb.Bot.X &&\n\t\t\t\tlb.PrevInAEL.OutIdx >= 0 &&\n\t\t\t\tClipperLib.ClipperBase.SlopesEqual5(lb.PrevInAEL.Curr, lb.PrevInAEL.Top, lb.Curr, lb.Top, this.m_UseFullRange) &&\n\t\t\t\tlb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tvar Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t\t\t\tthis.AddJoin(Op1, Op2, lb.Top);\n\t\t\t}\n\t\t\tif (lb.NextInAEL !== rb)\n\t\t\t{\n\t\t\t\tif (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t\t\t\t\tClipperLib.ClipperBase.SlopesEqual5(rb.PrevInAEL.Curr, rb.PrevInAEL.Top, rb.Curr, rb.Top, this.m_UseFullRange) &&\n\t\t\t\t\trb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t\t\t\t{\n\t\t\t\t\tvar Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t\t\t\t\tthis.AddJoin(Op1, Op2, rb.Top);\n\t\t\t\t}\n\t\t\t\tvar e = lb.NextInAEL;\n\t\t\t\tif (e !== null)\n\t\t\t\t\twhile (e !== rb)\n\t\t\t\t\t{\n\t\t\t\t\t\t//nb: For calculating winding counts etc, IntersectEdges() assumes\n\t\t\t\t\t\t//that param1 will be to the right of param2 ABOVE the intersection ...\n\t\t\t\t\t\tthis.IntersectEdges(rb, e, lb.Curr);\n\t\t\t\t\t\t//order important here\n\t\t\t\t\t\te = e.NextInAEL;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t{\n\t\t\tedge.PrevInAEL = null;\n\t\t\tedge.NextInAEL = null;\n\t\t\tthis.m_ActiveEdges = edge;\n\t\t}\n\t\telse if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t\t{\n\t\t\tedge.PrevInAEL = null;\n\t\t\tedge.NextInAEL = this.m_ActiveEdges;\n\t\t\tthis.m_ActiveEdges.PrevInAEL = edge;\n\t\t\tthis.m_ActiveEdges = edge;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (startEdge === null)\n\t\t\t\tstartEdge = this.m_ActiveEdges;\n\t\t\twhile (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t\t\t\tstartEdge = startEdge.NextInAEL;\n\t\t\tedge.NextInAEL = startEdge.NextInAEL;\n\t\t\tif (startEdge.NextInAEL !== null)\n\t\t\t\tstartEdge.NextInAEL.PrevInAEL = edge;\n\t\t\tedge.PrevInAEL = startEdge;\n\t\t\tstartEdge.NextInAEL = edge;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t{\n\t\tif (e2.Curr.X === e1.Curr.X)\n\t\t{\n\t\t\tif (e2.Top.Y > e1.Top.Y)\n\t\t\t\treturn e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t\t\telse\n\t\t\t\treturn e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t\t}\n\t\telse\n\t\t\treturn e2.Curr.X < e1.Curr.X;\n\t};\n\n\tClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t{\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\treturn this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t\telse\n\t\t\treturn this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t};\n\n\tClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t{\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\treturn this.m_ClipFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t\telse\n\t\t\treturn this.m_SubjFillType === ClipperLib.PolyFillType.pftEvenOdd;\n\t};\n\n\tClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t{\n\t\tvar pft, pft2;\n\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\tpft = this.m_SubjFillType;\n\t\t\tpft2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpft = this.m_ClipFillType;\n\t\t\tpft2 = this.m_SubjFillType;\n\t\t}\n\t\tswitch (pft)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tif (edge.WindDelta === 0 && edge.WindCnt !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\tif (Math.abs(edge.WindCnt) !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\tif (edge.WindCnt !== 1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (edge.WindCnt !== -1)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (this.m_ClipType)\n\t\t{\n\t\tcase ClipperLib.ClipType.ctIntersection:\n\t\t\tswitch (pft2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\treturn (edge.WindCnt2 !== 0);\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\treturn (edge.WindCnt2 > 0);\n\t\t\tdefault:\n\t\t\t\treturn (edge.WindCnt2 < 0);\n\t\t\t}\n\t\tcase ClipperLib.ClipType.ctUnion:\n\t\t\tswitch (pft2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\tdefault:\n\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t}\n\t\tcase ClipperLib.ClipType.ctDifference:\n\t\t\tif (edge.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 !== 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 > 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 < 0);\n\t\t\t\t}\n\t\tcase ClipperLib.ClipType.ctXor:\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t\tswitch (pft2)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.PolyFillType.pftEvenOdd:\n\t\t\t\tcase ClipperLib.PolyFillType.pftNonZero:\n\t\t\t\t\treturn (edge.WindCnt2 === 0);\n\t\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\t\treturn (edge.WindCnt2 <= 0);\n\t\t\t\tdefault:\n\t\t\t\t\treturn (edge.WindCnt2 >= 0);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t{\n\t\tvar e = edge.PrevInAEL;\n\t\t//find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t\twhile (e !== null && ((e.PolyTyp !== edge.PolyTyp) || (e.WindDelta === 0)))\n\t\t\te = e.PrevInAEL;\n\t\tif (e === null)\n\t\t{\n\t\t\tvar pft = (edge.PolyTyp === ClipperLib.PolyType.ptSubject ? this.m_SubjFillType : this.m_ClipFillType);\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t{\n\t\t\t\tedge.WindCnt = (pft === ClipperLib.PolyFillType.pftNegative ? -1 : 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tedge.WindCnt = edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = 0;\n\t\t\te = this.m_ActiveEdges;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse if (edge.WindDelta === 0 && this.m_ClipType !== ClipperLib.ClipType.ctUnion)\n\t\t{\n\t\t\tedge.WindCnt = 1;\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse if (this.IsEvenOddFillType(edge))\n\t\t{\n\t\t\t//EvenOdd filling ...\n\t\t\tif (edge.WindDelta === 0)\n\t\t\t{\n\t\t\t\t//are we inside a subj polygon ...\n\t\t\t\tvar Inside = true;\n\t\t\t\tvar e2 = e.PrevInAEL;\n\t\t\t\twhile (e2 !== null)\n\t\t\t\t{\n\t\t\t\t\tif (e2.PolyTyp === e.PolyTyp && e2.WindDelta !== 0)\n\t\t\t\t\t\tInside = !Inside;\n\t\t\t\t\te2 = e2.PrevInAEL;\n\t\t\t\t}\n\t\t\t\tedge.WindCnt = (Inside ? 0 : 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tedge.WindCnt = edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nonZero, Positive or Negative filling ...\n\t\t\tif (e.WindCnt * e.WindDelta < 0)\n\t\t\t{\n\t\t\t\t//prev edge is 'decreasing' WindCount (WC) toward zero\n\t\t\t\t//so we're outside the previous polygon ...\n\t\t\t\tif (Math.abs(e.WindCnt) > 1)\n\t\t\t\t{\n\t\t\t\t\t//outside prev poly but still inside another.\n\t\t\t\t\t//when reversing direction of prev poly use the same WC\n\t\t\t\t\tif (e.WindDelta * edge.WindDelta < 0)\n\t\t\t\t\t\tedge.WindCnt = e.WindCnt;\n\t\t\t\t\telse\n\t\t\t\t\t\tedge.WindCnt = e.WindCnt + edge.WindDelta;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tedge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//prev edge is 'increasing' WindCount (WC) away from zero\n\t\t\t\t//so we're inside the previous polygon ...\n\t\t\t\tif (edge.WindDelta === 0)\n\t\t\t\t\tedge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t\t\t\telse if (e.WindDelta * edge.WindDelta < 0)\n\t\t\t\t\tedge.WindCnt = e.WindCnt;\n\t\t\t\telse\n\t\t\t\t\tedge.WindCnt = e.WindCnt + edge.WindDelta;\n\t\t\t}\n\t\t\tedge.WindCnt2 = e.WindCnt2;\n\t\t\te = e.NextInAEL;\n\t\t\t//ie get ready to calc WindCnt2\n\t\t}\n\t\t//update WindCnt2 ...\n\t\tif (this.IsEvenOddAltFillType(edge))\n\t\t{\n\t\t\t//EvenOdd filling ...\n\t\t\twhile (e !== edge)\n\t\t\t{\n\t\t\t\tif (e.WindDelta !== 0)\n\t\t\t\t\tedge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nonZero, Positive or Negative filling ...\n\t\t\twhile (e !== edge)\n\t\t\t{\n\t\t\t\tedge.WindCnt2 += e.WindDelta;\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t{\n\t\t//SEL pointers in PEdge are use to build transient lists of horizontal edges.\n\t\t//However, since we don't need to worry about processing order, all additions\n\t\t//are made to the front of the list ...\n\t\tif (this.m_SortedEdges === null)\n\t\t{\n\t\t\tthis.m_SortedEdges = edge;\n\t\t\tedge.PrevInSEL = null;\n\t\t\tedge.NextInSEL = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tedge.NextInSEL = this.m_SortedEdges;\n\t\t\tedge.PrevInSEL = null;\n\t\t\tthis.m_SortedEdges.PrevInSEL = edge;\n\t\t\tthis.m_SortedEdges = edge;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.PopEdgeFromSEL = function (e)\n\t{\n\t\t//Pop edge from front of SEL (ie SEL is a FILO list)\n\t\te.v = this.m_SortedEdges;\n\t\tif (e.v === null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tvar oldE = e.v;\n\t\tthis.m_SortedEdges = e.v.NextInSEL;\n\t\tif (this.m_SortedEdges !== null)\n\t\t{\n\t\t\tthis.m_SortedEdges.PrevInSEL = null;\n\t\t}\n\t\toldE.NextInSEL = null;\n\t\toldE.PrevInSEL = null;\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t{\n\t\tvar e = this.m_ActiveEdges;\n\t\tthis.m_SortedEdges = e;\n\t\twhile (e !== null)\n\t\t{\n\t\t\te.PrevInSEL = e.PrevInAEL;\n\t\t\te.NextInSEL = e.NextInAEL;\n\t\t\te = e.NextInAEL;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t{\n\t\tif (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t\t\treturn;\n\t\tif (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t\t\treturn;\n\t\tif (edge1.NextInSEL === edge2)\n\t\t{\n\t\t\tvar next = edge2.NextInSEL;\n\t\t\tif (next !== null)\n\t\t\t\tnext.PrevInSEL = edge1;\n\t\t\tvar prev = edge1.PrevInSEL;\n\t\t\tif (prev !== null)\n\t\t\t\tprev.NextInSEL = edge2;\n\t\t\tedge2.PrevInSEL = prev;\n\t\t\tedge2.NextInSEL = edge1;\n\t\t\tedge1.PrevInSEL = edge2;\n\t\t\tedge1.NextInSEL = next;\n\t\t}\n\t\telse if (edge2.NextInSEL === edge1)\n\t\t{\n\t\t\tvar next = edge1.NextInSEL;\n\t\t\tif (next !== null)\n\t\t\t\tnext.PrevInSEL = edge2;\n\t\t\tvar prev = edge2.PrevInSEL;\n\t\t\tif (prev !== null)\n\t\t\t\tprev.NextInSEL = edge1;\n\t\t\tedge1.PrevInSEL = prev;\n\t\t\tedge1.NextInSEL = edge2;\n\t\t\tedge2.PrevInSEL = edge1;\n\t\t\tedge2.NextInSEL = next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar next = edge1.NextInSEL;\n\t\t\tvar prev = edge1.PrevInSEL;\n\t\t\tedge1.NextInSEL = edge2.NextInSEL;\n\t\t\tif (edge1.NextInSEL !== null)\n\t\t\t\tedge1.NextInSEL.PrevInSEL = edge1;\n\t\t\tedge1.PrevInSEL = edge2.PrevInSEL;\n\t\t\tif (edge1.PrevInSEL !== null)\n\t\t\t\tedge1.PrevInSEL.NextInSEL = edge1;\n\t\t\tedge2.NextInSEL = next;\n\t\t\tif (edge2.NextInSEL !== null)\n\t\t\t\tedge2.NextInSEL.PrevInSEL = edge2;\n\t\t\tedge2.PrevInSEL = prev;\n\t\t\tif (edge2.PrevInSEL !== null)\n\t\t\t\tedge2.PrevInSEL.NextInSEL = edge2;\n\t\t}\n\t\tif (edge1.PrevInSEL === null)\n\t\t\tthis.m_SortedEdges = edge1;\n\t\telse if (edge2.PrevInSEL === null)\n\t\t\tthis.m_SortedEdges = edge2;\n\t};\n\n\tClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t{\n\t\tthis.AddOutPt(e1, pt);\n\t\tif (e2.WindDelta === 0) this.AddOutPt(e2, pt);\n\t\tif (e1.OutIdx === e2.OutIdx)\n\t\t{\n\t\t\te1.OutIdx = -1;\n\t\t\te2.OutIdx = -1;\n\t\t}\n\t\telse if (e1.OutIdx < e2.OutIdx)\n\t\t\tthis.AppendPolygon(e1, e2);\n\t\telse\n\t\t\tthis.AppendPolygon(e2, e1);\n\t};\n\n\tClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t{\n\t\tvar result;\n\t\tvar e, prevE;\n\t\tif (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t\t{\n\t\t\tresult = this.AddOutPt(e1, pt);\n\t\t\te2.OutIdx = e1.OutIdx;\n\t\t\te1.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\te2.Side = ClipperLib.EdgeSide.esRight;\n\t\t\te = e1;\n\t\t\tif (e.PrevInAEL === e2)\n\t\t\t\tprevE = e2.PrevInAEL;\n\t\t\telse\n\t\t\t\tprevE = e.PrevInAEL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = this.AddOutPt(e2, pt);\n\t\t\te1.OutIdx = e2.OutIdx;\n\t\t\te1.Side = ClipperLib.EdgeSide.esRight;\n\t\t\te2.Side = ClipperLib.EdgeSide.esLeft;\n\t\t\te = e2;\n\t\t\tif (e.PrevInAEL === e1)\n\t\t\t\tprevE = e1.PrevInAEL;\n\t\t\telse\n\t\t\t\tprevE = e.PrevInAEL;\n\t\t}\n\n\t\tif (prevE !== null && prevE.OutIdx >= 0 && prevE.Top.Y < pt.Y && e.Top.Y < pt.Y)\n\t\t{\n\t\t\tvar xPrev = ClipperLib.Clipper.TopX(prevE, pt.Y);\n\t\t\tvar xE = ClipperLib.Clipper.TopX(e, pt.Y);\n\t\t\tif ((xPrev === xE) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0) && ClipperLib.ClipperBase.SlopesEqual5(new ClipperLib.IntPoint2(xPrev, pt.Y), prevE.Top, new ClipperLib.IntPoint2(xE, pt.Y), e.Top, this.m_UseFullRange))\n\t\t\t{\n\t\t\t\tvar outPt = this.AddOutPt(prevE, pt);\n\t\t\t\tthis.AddJoin(result, outPt, e.Top);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t{\n\t\tif (e.OutIdx < 0)\n\t\t{\n\t\t\tvar outRec = this.CreateOutRec();\n\t\t\toutRec.IsOpen = (e.WindDelta === 0);\n\t\t\tvar newOp = new ClipperLib.OutPt();\n\t\t\toutRec.Pts = newOp;\n\t\t\tnewOp.Idx = outRec.Idx;\n\t\t\t//newOp.Pt = pt;\n\t\t\tnewOp.Pt.X = pt.X;\n\t\t\tnewOp.Pt.Y = pt.Y;\n\t\t\tif (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;\n\t\t\tnewOp.Next = newOp;\n\t\t\tnewOp.Prev = newOp;\n\t\t\tif (!outRec.IsOpen)\n\t\t\t\tthis.SetHoleState(e, outRec);\n\t\t\te.OutIdx = outRec.Idx;\n\t\t\t//nb: do this after SetZ !\n\t\t\treturn newOp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[e.OutIdx];\n\t\t\t//OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t\t\tvar op = outRec.Pts;\n\t\t\tvar ToFront = (e.Side === ClipperLib.EdgeSide.esLeft);\n\t\t\tif (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t\t\t\treturn op;\n\t\t\telse if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t\t\t\treturn op.Prev;\n\t\t\tvar newOp = new ClipperLib.OutPt();\n\t\t\tnewOp.Idx = outRec.Idx;\n\t\t\t//newOp.Pt = pt;\n\t\t\tnewOp.Pt.X = pt.X;\n\t\t\tnewOp.Pt.Y = pt.Y;\n\t\t\tif (ClipperLib.use_xyz) newOp.Pt.Z = pt.Z;\n\t\t\tnewOp.Next = op;\n\t\t\tnewOp.Prev = op.Prev;\n\t\t\tnewOp.Prev.Next = newOp;\n\t\t\top.Prev = newOp;\n\t\t\tif (ToFront)\n\t\t\t\toutRec.Pts = newOp;\n\t\t\treturn newOp;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetLastOutPt = function (e)\n\t{\n\t\tvar outRec = this.m_PolyOuts[e.OutIdx];\n\t\tif (e.Side === ClipperLib.EdgeSide.esLeft)\n\t\t{\n\t\t\treturn outRec.Pts;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn outRec.Pts.Prev;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t{\n\t\tvar tmp = new ClipperLib.IntPoint1(pt1.Value);\n\t\t//pt1.Value = pt2.Value;\n\t\tpt1.Value.X = pt2.Value.X;\n\t\tpt1.Value.Y = pt2.Value.Y;\n\t\tif (ClipperLib.use_xyz) pt1.Value.Z = pt2.Value.Z;\n\t\t//pt2.Value = tmp;\n\t\tpt2.Value.X = tmp.X;\n\t\tpt2.Value.Y = tmp.Y;\n\t\tif (ClipperLib.use_xyz) pt2.Value.Z = tmp.Z;\n\t};\n\n\tClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n\tClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t{\n\t\tvar e2 = e.PrevInAEL;\n\t\tvar eTmp = null;\n\t\twhile (e2 !== null)\n\t\t{\n\t\t\tif (e2.OutIdx >= 0 && e2.WindDelta !== 0)\n\t\t\t{\n\t\t\t\tif (eTmp === null)\n\t\t\t\t\teTmp = e2;\n\t\t\t\telse if (eTmp.OutIdx === e2.OutIdx)\n\t\t\t\t\teTmp = null; //paired\n\t\t\t}\n\t\t\te2 = e2.PrevInAEL;\n\t\t}\n\n\t\tif (eTmp === null)\n\t\t{\n\t\t\toutRec.FirstLeft = null;\n\t\t\toutRec.IsHole = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutRec.FirstLeft = this.m_PolyOuts[eTmp.OutIdx];\n\t\t\toutRec.IsHole = !outRec.FirstLeft.IsHole;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t{\n\t\tif (pt1.Y === pt2.Y)\n\t\t\treturn ClipperLib.ClipperBase.horizontal;\n\t\telse\n\t\t\treturn (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t};\n\n\tClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t{\n\t\tvar p = btmPt1.Prev;\n\t\twhile ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n\t\t\tp = p.Prev;\n\t\tvar dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t\tp = btmPt1.Next;\n\t\twhile ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p !== btmPt1))\n\t\t\tp = p.Next;\n\t\tvar dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t\tp = btmPt2.Prev;\n\t\twhile ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n\t\t\tp = p.Prev;\n\t\tvar dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t\tp = btmPt2.Next;\n\t\twhile ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p !== btmPt2))\n\t\t\tp = p.Next;\n\t\tvar dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\n\t\tif (Math.max(dx1p, dx1n) === Math.max(dx2p, dx2n) && Math.min(dx1p, dx1n) === Math.min(dx2p, dx2n))\n\t\t{\n\t\t\treturn this.Area(btmPt1) > 0; //if otherwise identical use orientation\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t{\n\t\tvar dups = null;\n\t\tvar p = pp.Next;\n\t\twhile (p !== pp)\n\t\t{\n\t\t\tif (p.Pt.Y > pp.Pt.Y)\n\t\t\t{\n\t\t\t\tpp = p;\n\t\t\t\tdups = null;\n\t\t\t}\n\t\t\telse if (p.Pt.Y === pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t\t\t{\n\t\t\t\tif (p.Pt.X < pp.Pt.X)\n\t\t\t\t{\n\t\t\t\t\tdups = null;\n\t\t\t\t\tpp = p;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p.Next !== pp && p.Prev !== pp)\n\t\t\t\t\t\tdups = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = p.Next;\n\t\t}\n\t\tif (dups !== null)\n\t\t{\n\t\t\t//there appears to be at least 2 vertices at bottomPt so ...\n\t\t\twhile (dups !== p)\n\t\t\t{\n\t\t\t\tif (!this.FirstIsBottomPt(p, dups))\n\t\t\t\t\tpp = dups;\n\t\t\t\tdups = dups.Next;\n\t\t\t\twhile (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t\t\t\t\tdups = dups.Next;\n\t\t\t}\n\t\t}\n\t\treturn pp;\n\t};\n\n\tClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t{\n\t\t//work out which polygon fragment has the correct hole state ...\n\t\tif (outRec1.BottomPt === null)\n\t\t\toutRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t\tif (outRec2.BottomPt === null)\n\t\t\toutRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t\tvar bPt1 = outRec1.BottomPt;\n\t\tvar bPt2 = outRec2.BottomPt;\n\t\tif (bPt1.Pt.Y > bPt2.Pt.Y)\n\t\t\treturn outRec1;\n\t\telse if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t\t\treturn outRec2;\n\t\telse if (bPt1.Pt.X < bPt2.Pt.X)\n\t\t\treturn outRec1;\n\t\telse if (bPt1.Pt.X > bPt2.Pt.X)\n\t\t\treturn outRec2;\n\t\telse if (bPt1.Next === bPt1)\n\t\t\treturn outRec2;\n\t\telse if (bPt2.Next === bPt2)\n\t\t\treturn outRec1;\n\t\telse if (this.FirstIsBottomPt(bPt1, bPt2))\n\t\t\treturn outRec1;\n\t\telse\n\t\t\treturn outRec2;\n\t};\n\n\tClipperLib.Clipper.prototype.OutRec1RightOfOutRec2 = function (outRec1, outRec2)\n\t{\n\t\tdo {\n\t\t\toutRec1 = outRec1.FirstLeft;\n\t\t\tif (outRec1 === outRec2)\n\t\t\t\treturn true;\n\t\t}\n\t\twhile (outRec1 !== null)\n\t\treturn false;\n\t};\n\n\tClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t{\n\t\tvar outrec = this.m_PolyOuts[idx];\n\t\twhile (outrec !== this.m_PolyOuts[outrec.Idx])\n\t\t\toutrec = this.m_PolyOuts[outrec.Idx];\n\t\treturn outrec;\n\t};\n\n\tClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t{\n\t\t//get the start and ends of both output polygons ...\n\t\tvar outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t\tvar outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t\tvar holeStateRec;\n\t\tif (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n\t\t\tholeStateRec = outRec2;\n\t\telse if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n\t\t\tholeStateRec = outRec1;\n\t\telse\n\t\t\tholeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n\t\t//get the start and ends of both output polygons and\n\t\t//join E2 poly onto E1 poly and delete pointers to E2 ...\n\n\t\tvar p1_lft = outRec1.Pts;\n\t\tvar p1_rt = p1_lft.Prev;\n\t\tvar p2_lft = outRec2.Pts;\n\t\tvar p2_rt = p2_lft.Prev;\n\t\t//join e2 poly onto e1 poly and delete pointers to e2 ...\n\t\tif (e1.Side === ClipperLib.EdgeSide.esLeft)\n\t\t{\n\t\t\tif (e2.Side === ClipperLib.EdgeSide.esLeft)\n\t\t\t{\n\t\t\t\t//z y x a b c\n\t\t\t\tthis.ReversePolyPtLinks(p2_lft);\n\t\t\t\tp2_lft.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_lft;\n\t\t\t\tp1_rt.Next = p2_rt;\n\t\t\t\tp2_rt.Prev = p1_rt;\n\t\t\t\toutRec1.Pts = p2_rt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//x y z a b c\n\t\t\t\tp2_rt.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_rt;\n\t\t\t\tp2_lft.Prev = p1_rt;\n\t\t\t\tp1_rt.Next = p2_lft;\n\t\t\t\toutRec1.Pts = p2_lft;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (e2.Side === ClipperLib.EdgeSide.esRight)\n\t\t\t{\n\t\t\t\t//a b c z y x\n\t\t\t\tthis.ReversePolyPtLinks(p2_lft);\n\t\t\t\tp1_rt.Next = p2_rt;\n\t\t\t\tp2_rt.Prev = p1_rt;\n\t\t\t\tp2_lft.Next = p1_lft;\n\t\t\t\tp1_lft.Prev = p2_lft;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//a b c x y z\n\t\t\t\tp1_rt.Next = p2_lft;\n\t\t\t\tp2_lft.Prev = p1_rt;\n\t\t\t\tp1_lft.Prev = p2_rt;\n\t\t\t\tp2_rt.Next = p1_lft;\n\t\t\t}\n\t\t}\n\t\toutRec1.BottomPt = null;\n\t\tif (holeStateRec === outRec2)\n\t\t{\n\t\t\tif (outRec2.FirstLeft !== outRec1)\n\t\t\t\toutRec1.FirstLeft = outRec2.FirstLeft;\n\t\t\toutRec1.IsHole = outRec2.IsHole;\n\t\t}\n\t\toutRec2.Pts = null;\n\t\toutRec2.BottomPt = null;\n\t\toutRec2.FirstLeft = outRec1;\n\t\tvar OKIdx = e1.OutIdx;\n\t\tvar ObsoleteIdx = e2.OutIdx;\n\t\te1.OutIdx = -1;\n\t\t//nb: safe because we only get here via AddLocalMaxPoly\n\t\te2.OutIdx = -1;\n\t\tvar e = this.m_ActiveEdges;\n\t\twhile (e !== null)\n\t\t{\n\t\t\tif (e.OutIdx === ObsoleteIdx)\n\t\t\t{\n\t\t\t\te.OutIdx = OKIdx;\n\t\t\t\te.Side = e1.Side;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\te = e.NextInAEL;\n\t\t}\n\t\toutRec2.Idx = outRec1.Idx;\n\t};\n\n\tClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t{\n\t\tif (pp === null)\n\t\t\treturn;\n\t\tvar pp1;\n\t\tvar pp2;\n\t\tpp1 = pp;\n\t\tdo {\n\t\t\tpp2 = pp1.Next;\n\t\t\tpp1.Next = pp1.Prev;\n\t\t\tpp1.Prev = pp2;\n\t\t\tpp1 = pp2;\n\t\t}\n\t\twhile (pp1 !== pp)\n\t};\n\n\tClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t{\n\t\tvar side = edge1.Side;\n\t\tedge1.Side = edge2.Side;\n\t\tedge2.Side = side;\n\t};\n\n\tClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t{\n\t\tvar outIdx = edge1.OutIdx;\n\t\tedge1.OutIdx = edge2.OutIdx;\n\t\tedge2.OutIdx = outIdx;\n\t};\n\n\tClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t{\n\t\t//e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t\t//e2 in AEL except when e1 is being inserted at the intersection point ...\n\t\tvar e1Contributing = (e1.OutIdx >= 0);\n\t\tvar e2Contributing = (e2.OutIdx >= 0);\n\n\t\tif (ClipperLib.use_xyz)\n\t\t\tthis.SetZ(pt, e1, e2);\n\n\t\tif (ClipperLib.use_lines)\n\t\t{\n\t\t\t//if either edge is on an OPEN path ...\n\t\t\tif (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t\t\t{\n\t\t\t\t//ignore subject-subject open path intersections UNLESS they\n\t\t\t\t//are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta === 0 && e2.WindDelta === 0) return;\n\t\t\t\t//if intersecting a subj line with a subj poly ...\n\t\t\t\telse if (e1.PolyTyp === e2.PolyTyp &&\n\t\t\t\t\te1.WindDelta !== e2.WindDelta && this.m_ClipType === ClipperLib.ClipType.ctUnion)\n\t\t\t\t{\n\t\t\t\t\tif (e1.WindDelta === 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t\t\te1.OutIdx = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t\t\te2.OutIdx = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (e1.PolyTyp !== e2.PolyTyp)\n\t\t\t\t{\n\t\t\t\t\tif ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) === 1 &&\n\t\t\t\t\t\t(this.m_ClipType !== ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\t\t\tif (e1Contributing)\n\t\t\t\t\t\t\te1.OutIdx = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) === 1) &&\n\t\t\t\t\t\t(this.m_ClipType !== ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\t\t\tif (e2Contributing)\n\t\t\t\t\t\t\te2.OutIdx = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t//update winding counts...\n\t\t//assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t\tif (e1.PolyTyp === e2.PolyTyp)\n\t\t{\n\t\t\tif (this.IsEvenOddFillType(e1))\n\t\t\t{\n\t\t\t\tvar oldE1WindCnt = e1.WindCnt;\n\t\t\t\te1.WindCnt = e2.WindCnt;\n\t\t\t\te2.WindCnt = oldE1WindCnt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (e1.WindCnt + e2.WindDelta === 0)\n\t\t\t\t\te1.WindCnt = -e1.WindCnt;\n\t\t\t\telse\n\t\t\t\t\te1.WindCnt += e2.WindDelta;\n\t\t\t\tif (e2.WindCnt - e1.WindDelta === 0)\n\t\t\t\t\te2.WindCnt = -e2.WindCnt;\n\t\t\t\telse\n\t\t\t\t\te2.WindCnt -= e1.WindDelta;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!this.IsEvenOddFillType(e2))\n\t\t\t\te1.WindCnt2 += e2.WindDelta;\n\t\t\telse\n\t\t\t\te1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t\t\tif (!this.IsEvenOddFillType(e1))\n\t\t\t\te2.WindCnt2 -= e1.WindDelta;\n\t\t\telse\n\t\t\t\te2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t\t}\n\t\tvar e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t\tif (e1.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\te1FillType = this.m_SubjFillType;\n\t\t\te1FillType2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te1FillType = this.m_ClipFillType;\n\t\t\te1FillType2 = this.m_SubjFillType;\n\t\t}\n\t\tif (e2.PolyTyp === ClipperLib.PolyType.ptSubject)\n\t\t{\n\t\t\te2FillType = this.m_SubjFillType;\n\t\t\te2FillType2 = this.m_ClipFillType;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te2FillType = this.m_ClipFillType;\n\t\t\te2FillType2 = this.m_SubjFillType;\n\t\t}\n\t\tvar e1Wc, e2Wc;\n\t\tswitch (e1FillType)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\te1Wc = e1.WindCnt;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\te1Wc = -e1.WindCnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te1Wc = Math.abs(e1.WindCnt);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (e2FillType)\n\t\t{\n\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\te2Wc = e2.WindCnt;\n\t\t\tbreak;\n\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\te2Wc = -e2.WindCnt;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te2Wc = Math.abs(e2.WindCnt);\n\t\t\tbreak;\n\t\t}\n\t\tif (e1Contributing && e2Contributing)\n\t\t{\n\t\t\tif ((e1Wc !== 0 && e1Wc !== 1) || (e2Wc !== 0 && e2Wc !== 1) ||\n\t\t\t\t(e1.PolyTyp !== e2.PolyTyp && this.m_ClipType !== ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if (e1Contributing)\n\t\t{\n\t\t\tif (e2Wc === 0 || e2Wc === 1)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e1, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if (e2Contributing)\n\t\t{\n\t\t\tif (e1Wc === 0 || e1Wc === 1)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e2, pt);\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t\t\tClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t\t\t}\n\t\t}\n\t\telse if ((e1Wc === 0 || e1Wc === 1) && (e2Wc === 0 || e2Wc === 1))\n\t\t{\n\t\t\t//neither edge is currently contributing ...\n\t\t\tvar e1Wc2, e2Wc2;\n\t\t\tswitch (e1FillType2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\te1Wc2 = e1.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\t\te1Wc2 = -e1.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te1Wc2 = Math.abs(e1.WindCnt2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (e2FillType2)\n\t\t\t{\n\t\t\tcase ClipperLib.PolyFillType.pftPositive:\n\t\t\t\te2Wc2 = e2.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.PolyFillType.pftNegative:\n\t\t\t\te2Wc2 = -e2.WindCnt2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\te2Wc2 = Math.abs(e2.WindCnt2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e1.PolyTyp !== e2.PolyTyp)\n\t\t\t{\n\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t}\n\t\t\telse if (e1Wc === 1 && e2Wc === 1)\n\t\t\t\tswitch (this.m_ClipType)\n\t\t\t\t{\n\t\t\t\tcase ClipperLib.ClipType.ctIntersection:\n\t\t\t\t\tif (e1Wc2 > 0 && e2Wc2 > 0)\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctUnion:\n\t\t\t\t\tif (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctDifference:\n\t\t\t\t\tif (((e1.PolyTyp === ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t\t\t\t\t\t((e1.PolyTyp === ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ClipperLib.ClipType.ctXor:\n\t\t\t\t\tthis.AddLocalMinPoly(e1, e2, pt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tClipperLib.Clipper.SwapSides(e1, e2);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t{\n\t\tvar SelPrev = e.PrevInSEL;\n\t\tvar SelNext = e.NextInSEL;\n\t\tif (SelPrev === null && SelNext === null && (e !== this.m_SortedEdges))\n\t\t\treturn;\n\t\t//already deleted\n\t\tif (SelPrev !== null)\n\t\t\tSelPrev.NextInSEL = SelNext;\n\t\telse\n\t\t\tthis.m_SortedEdges = SelNext;\n\t\tif (SelNext !== null)\n\t\t\tSelNext.PrevInSEL = SelPrev;\n\t\te.NextInSEL = null;\n\t\te.PrevInSEL = null;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessHorizontals = function ()\n\t{\n\t\tvar horzEdge = {}; //m_SortedEdges;\n\t\twhile (this.PopEdgeFromSEL(horzEdge))\n\t\t{\n\t\t\tthis.ProcessHorizontal(horzEdge.v);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t{\n\t\tif (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t\t{\n\t\t\t$var.Left = HorzEdge.Bot.X;\n\t\t\t$var.Right = HorzEdge.Top.X;\n\t\t\t$var.Dir = ClipperLib.Direction.dLeftToRight;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$var.Left = HorzEdge.Top.X;\n\t\t\t$var.Right = HorzEdge.Bot.X;\n\t\t\t$var.Dir = ClipperLib.Direction.dRightToLeft;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge)\n\t{\n\t\tvar $var = {\n\t\t\tDir: null,\n\t\t\tLeft: null,\n\t\t\tRight: null\n\t\t};\n\n\t\tthis.GetHorzDirection(horzEdge, $var);\n\t\tvar dir = $var.Dir;\n\t\tvar horzLeft = $var.Left;\n\t\tvar horzRight = $var.Right;\n\n\t\tvar IsOpen = horzEdge.WindDelta === 0;\n\n\t\tvar eLastHorz = horzEdge,\n\t\t\teMaxPair = null;\n\t\twhile (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t\t\teLastHorz = eLastHorz.NextInLML;\n\t\tif (eLastHorz.NextInLML === null)\n\t\t\teMaxPair = this.GetMaximaPair(eLastHorz);\n\n\t\tvar currMax = this.m_Maxima;\n\t\tif (currMax !== null)\n\t\t{\n\t\t\t//get the first maxima in range (X) ...\n\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t{\n\t\t\t\twhile (currMax !== null && currMax.X <= horzEdge.Bot.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t}\n\t\t\t\tif (currMax !== null && currMax.X >= eLastHorz.Top.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (currMax.Next !== null && currMax.Next.X < horzEdge.Bot.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t}\n\t\t\t\tif (currMax.X <= eLastHorz.Top.X)\n\t\t\t\t{\n\t\t\t\t\tcurrMax = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar op1 = null;\n\t\tfor (;;) //loop through consec. horizontal edges\n\t\t{\n\t\t\tvar IsLastHorz = (horzEdge === eLastHorz);\n\t\t\tvar e = this.GetNextInAEL(horzEdge, dir);\n\t\t\twhile (e !== null)\n\t\t\t{\n\t\t\t\t//this code block inserts extra coords into horizontal edges (in output\n\t\t\t\t//polygons) whereever maxima touch these horizontal edges. This helps\n\t\t\t\t//'simplifying' polygons (ie if the Simplify property is set).\n\t\t\t\tif (currMax !== null)\n\t\t\t\t{\n\t\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (currMax !== null && currMax.X < e.Curr.X)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.AddOutPt(horzEdge, new ClipperLib.IntPoint2(currMax.X, horzEdge.Bot.Y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrMax = currMax.Next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (currMax !== null && currMax.X > e.Curr.X)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.AddOutPt(horzEdge, new ClipperLib.IntPoint2(currMax.X, horzEdge.Bot.Y));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrMax = currMax.Prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((dir === ClipperLib.Direction.dLeftToRight && e.Curr.X > horzRight) || (dir === ClipperLib.Direction.dRightToLeft && e.Curr.X < horzLeft))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//Also break if we've got to the end of an intermediate horizontal edge ...\n\t\t\t\t//nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t\t\t\tif (e.Curr.X === horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (horzEdge.OutIdx >= 0 && !IsOpen) //note: may be done multiple times\n\t\t\t\t{\n\t\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t\t\t\tthis.SetZ(e.Curr, horzEdge, e);\n\t\t\t\t\t\telse this.SetZ(e.Curr, e, horzEdge);\n\t\t\t\t\t}\n\n\t\t\t\t\top1 = this.AddOutPt(horzEdge, e.Curr);\n\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op2 = this.GetLastOutPt(eNextHorz);\n\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t}\n\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t}\n\n\t\t\t\t//OK, so far we're still in range of the horizontal Edge  but make sure\n\t\t\t\t//we're at the last of consec. horizontals when matching with eMaxPair\n\t\t\t\tif (e === eMaxPair && IsLastHorz)\n\t\t\t\t{\n\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t}\n\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (dir === ClipperLib.Direction.dLeftToRight)\n\t\t\t\t{\n\t\t\t\t\tvar Pt = new ClipperLib.IntPoint2(e.Curr.X, horzEdge.Curr.Y);\n\t\t\t\t\tthis.IntersectEdges(horzEdge, e, Pt);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar Pt = new ClipperLib.IntPoint2(e.Curr.X, horzEdge.Curr.Y);\n\t\t\t\t\tthis.IntersectEdges(e, horzEdge, Pt);\n\t\t\t\t}\n\t\t\t\tvar eNext = this.GetNextInAEL(e, dir);\n\t\t\t\tthis.SwapPositionsInAEL(horzEdge, e);\n\t\t\t\te = eNext;\n\t\t\t} //end while(e !== null)\n\n\t\t\t//Break out of loop if HorzEdge.NextInLML is not also horizontal ...\n\t\t\tif (horzEdge.NextInLML === null || !ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(horzEdge, horzEdge.Bot);\n\t\t\t}\n\n\t\t\t$var = {\n\t\t\t\tDir: dir,\n\t\t\t\tLeft: horzLeft,\n\t\t\t\tRight: horzRight\n\t\t\t};\n\n\t\t\tthis.GetHorzDirection(horzEdge, $var);\n\t\t\tdir = $var.Dir;\n\t\t\thorzLeft = $var.Left;\n\t\t\thorzRight = $var.Right;\n\n\t\t} //end for (;;)\n\n\t\tif (horzEdge.OutIdx >= 0 && op1 === null)\n\t\t{\n\t\t\top1 = this.GetLastOutPt(horzEdge);\n\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\twhile (eNextHorz !== null)\n\t\t\t{\n\t\t\t\tif (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.GetLastOutPt(eNextHorz);\n\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t}\n\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t}\n\t\t\tthis.AddGhostJoin(op1, horzEdge.Top);\n\t\t}\n\n\t\tif (horzEdge.NextInLML !== null)\n\t\t{\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\top1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\n\t\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\t\tif (horzEdge.WindDelta === 0)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//nb: HorzEdge is no longer horizontal here\n\t\t\t\tvar ePrev = horzEdge.PrevInAEL;\n\t\t\t\tvar eNext = horzEdge.NextInAEL;\n\t\t\t\tif (ePrev !== null && ePrev.Curr.X === horzEdge.Bot.X && ePrev.Curr.Y === horzEdge.Bot.Y && ePrev.WindDelta === 0 && (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, ePrev, this.m_UseFullRange)))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t\t\t\t\tthis.AddJoin(op1, op2, horzEdge.Top);\n\t\t\t\t}\n\t\t\t\telse if (eNext !== null && eNext.Curr.X === horzEdge.Bot.X && eNext.Curr.Y === horzEdge.Bot.Y && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual3(horzEdge, eNext, this.m_UseFullRange))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t\t\t\t\tthis.AddJoin(op1, op2, horzEdge.Top);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thorzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t{\n\t\treturn Direction === ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t};\n\n\tClipperLib.Clipper.prototype.IsMinima = function (e)\n\t{\n\t\treturn e !== null && (e.Prev.NextInLML !== e) && (e.Next.NextInLML !== e);\n\t};\n\n\tClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t{\n\t\treturn (e !== null && e.Top.Y === Y && e.NextInLML === null);\n\t};\n\n\tClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t{\n\t\treturn (e.Top.Y === Y && e.NextInLML !== null);\n\t};\n\n\tClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t{\n\t\tif ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t\t{\n\t\t\treturn e.Next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t\t\t{\n\t\t\t\treturn e.Prev;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.GetMaximaPairEx = function (e)\n\t{\n\t\t//as above but returns null if MaxPair isn't in AEL (unless it's horizontal)\n\t\tvar result = this.GetMaximaPair(e);\n\t\tif (result === null || result.OutIdx === ClipperLib.ClipperBase.Skip ||\n\t\t\t((result.NextInAEL === result.PrevInAEL) && !ClipperLib.ClipperBase.IsHorizontal(result)))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t\treturn true;\n\t\ttry\n\t\t{\n\t\t\tthis.BuildIntersectList(topY);\n\t\t\tif (this.m_IntersectList.length === 0)\n\t\t\t\treturn true;\n\t\t\tif (this.m_IntersectList.length === 1 || this.FixupIntersectionOrder())\n\t\t\t\tthis.ProcessIntersectList();\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tcatch ($$e2)\n\t\t{\n\t\t\tthis.m_SortedEdges = null;\n\t\t\tthis.m_IntersectList.length = 0;\n\t\t\tClipperLib.Error(\"ProcessIntersections error\");\n\t\t}\n\t\tthis.m_SortedEdges = null;\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t{\n\t\tif (this.m_ActiveEdges === null)\n\t\t\treturn;\n\t\t//prepare for sorting ...\n\t\tvar e = this.m_ActiveEdges;\n\t\t//console.log(JSON.stringify(JSON.decycle( e )));\n\t\tthis.m_SortedEdges = e;\n\t\twhile (e !== null)\n\t\t{\n\t\t\te.PrevInSEL = e.PrevInAEL;\n\t\t\te.NextInSEL = e.NextInAEL;\n\t\t\te.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t\t\te = e.NextInAEL;\n\t\t}\n\t\t//bubblesort ...\n\t\tvar isModified = true;\n\t\twhile (isModified && this.m_SortedEdges !== null)\n\t\t{\n\t\t\tisModified = false;\n\t\t\te = this.m_SortedEdges;\n\t\t\twhile (e.NextInSEL !== null)\n\t\t\t{\n\t\t\t\tvar eNext = e.NextInSEL;\n\t\t\t\tvar pt = new ClipperLib.IntPoint0();\n\t\t\t\t//console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t\t\t\tif (e.Curr.X > eNext.Curr.X)\n\t\t\t\t{\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t\t\t\t\tif (pt.Y < topY)\n\t\t\t\t\t{\n\t\t\t\t\t\tpt = new ClipperLib.IntPoint2(ClipperLib.Clipper.TopX(e, topY), topY);\n\t\t\t\t\t}\n\t\t\t\t\tvar newNode = new ClipperLib.IntersectNode();\n\t\t\t\t\tnewNode.Edge1 = e;\n\t\t\t\t\tnewNode.Edge2 = eNext;\n\t\t\t\t\t//newNode.Pt = pt;\n\t\t\t\t\tnewNode.Pt.X = pt.X;\n\t\t\t\t\tnewNode.Pt.Y = pt.Y;\n\t\t\t\t\tif (ClipperLib.use_xyz) newNode.Pt.Z = pt.Z;\n\t\t\t\t\tthis.m_IntersectList.push(newNode);\n\t\t\t\t\tthis.SwapPositionsInSEL(e, eNext);\n\t\t\t\t\tisModified = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\te = eNext;\n\t\t\t}\n\t\t\tif (e.PrevInSEL !== null)\n\t\t\t\te.PrevInSEL.NextInSEL = null;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.m_SortedEdges = null;\n\t};\n\n\tClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t{\n\t\treturn (inode.Edge1.NextInSEL === inode.Edge2) || (inode.Edge1.PrevInSEL === inode.Edge2);\n\t};\n\n\tClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t{\n\t\t//the following typecast is safe because the differences in Pt.Y will\n\t\t//be limited to the height of the scanbeam.\n\t\treturn (node2.Pt.Y - node1.Pt.Y);\n\t};\n\n\tClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t{\n\t\t//pre-condition: intersections are sorted bottom-most first.\n\t\t//Now it's crucial that intersections are made only between adjacent edges,\n\t\t//so to ensure this the order of intersections may need adjusting ...\n\t\tthis.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t\tthis.CopyAELToSEL();\n\t\tvar cnt = this.m_IntersectList.length;\n\t\tfor (var i = 0; i < cnt; i++)\n\t\t{\n\t\t\tif (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t\t\t{\n\t\t\t\tvar j = i + 1;\n\t\t\t\twhile (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t\t\t\t\tj++;\n\t\t\t\tif (j === cnt)\n\t\t\t\t\treturn false;\n\t\t\t\tvar tmp = this.m_IntersectList[i];\n\t\t\t\tthis.m_IntersectList[i] = this.m_IntersectList[j];\n\t\t\t\tthis.m_IntersectList[j] = tmp;\n\t\t\t}\n\t\t\tthis.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t\t{\n\t\t\tvar iNode = this.m_IntersectList[i];\n\t\t\tthis.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t\t\tthis.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t\t}\n\t\tthis.m_IntersectList.length = 0;\n\t};\n\n\t/*\n\t--------------------------------\n\tRound speedtest: http://jsperf.com/fastest-round\n\t--------------------------------\n\t*/\n\tvar R1 = function (a)\n\t{\n\t\treturn a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t};\n\n\tvar R2 = function (a)\n\t{\n\t\treturn a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t};\n\n\tvar R3 = function (a)\n\t{\n\t\treturn a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t};\n\n\tvar R4 = function (a)\n\t{\n\t\tif (a < 0)\n\t\t{\n\t\t\ta -= 0.5;\n\t\t\treturn a < -2147483648 ? Math.ceil(a) : a | 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta += 0.5;\n\t\t\treturn a > 2147483647 ? Math.floor(a) : a | 0;\n\t\t}\n\t};\n\n\tif (browser.msie) ClipperLib.Clipper.Round = R1;\n\telse if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\telse if (browser.safari) ClipperLib.Clipper.Round = R4;\n\telse ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\tClipperLib.Clipper.TopX = function (edge, currentY)\n\t{\n\t\t//if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t\t//if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t\tif (currentY === edge.Top.Y)\n\t\t\treturn edge.Top.X;\n\t\treturn edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t};\n\n\tClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t{\n\t\tip.X = 0;\n\t\tip.Y = 0;\n\t\tvar b1, b2;\n\t\t//nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t\t//return false but for the edge.Dx value be equal due to double precision rounding.\n\t\tif (edge1.Dx === edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n\t\t}\n\t\tif (edge1.Delta.X === 0)\n\t\t{\n\t\t\tip.X = edge1.Bot.X;\n\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t\t\t{\n\t\t\t\tip.Y = edge2.Bot.Y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t\t\t\tip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t\t\t}\n\t\t}\n\t\telse if (edge2.Delta.X === 0)\n\t\t{\n\t\t\tip.X = edge2.Bot.X;\n\t\t\tif (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t\t\t{\n\t\t\t\tip.Y = edge1.Bot.Y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t\t\t\tip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t\t\tb2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t\t\tvar q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t\t\tip.Y = ClipperLib.Clipper.Round(q);\n\t\t\tif (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t\t}\n\t\tif (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t\t{\n\t\t\tif (edge1.Top.Y > edge2.Top.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Top.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t\t\t\treturn ip.X < edge1.Top.X;\n\t\t\t}\n\t\t\telse\n\t\t\t\tip.Y = edge2.Top.Y;\n\t\t\tif (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t}\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t{\n\t\tvar e = this.m_ActiveEdges;\n\n\t\twhile (e !== null)\n\t\t{\n\t\t\t//1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t\t\t//   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t\t\tvar IsMaximaEdge = this.IsMaxima(e, topY);\n\t\t\tif (IsMaximaEdge)\n\t\t\t{\n\t\t\t\tvar eMaxPair = this.GetMaximaPairEx(e);\n\t\t\t\tIsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t\t\t}\n\t\t\tif (IsMaximaEdge)\n\t\t\t{\n\t\t\t\tif (this.StrictlySimple)\n\t\t\t\t{\n\t\t\t\t\tthis.InsertMaxima(e.Top.X);\n\t\t\t\t}\n\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\tthis.DoMaxima(e);\n\t\t\t\tif (ePrev === null)\n\t\t\t\t\te = this.m_ActiveEdges;\n\t\t\t\telse\n\t\t\t\t\te = ePrev.NextInAEL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t\t\t\tif (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t\t\t\t{\n\t\t\t\t\te = this.UpdateEdgeIntoAEL(e);\n\t\t\t\t\tif (e.OutIdx >= 0)\n\t\t\t\t\t\tthis.AddOutPt(e, e.Bot);\n\t\t\t\t\tthis.AddEdgeToSEL(e);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\te.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t\t\t\t\te.Curr.Y = topY;\n\t\t\t\t}\n\n\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t{\n\t\t\t\t\tif (e.Top.Y === topY) e.Curr.Z = e.Top.Z;\n\t\t\t\t\telse if (e.Bot.Y === topY) e.Curr.Z = e.Bot.Z;\n\t\t\t\t\telse e.Curr.Z = 0;\n\t\t\t\t}\n\n\t\t\t\t//When StrictlySimple and 'e' is being touched by another edge, then\n\t\t\t\t//make sure both edges have a vertex here ...\n\t\t\t\tif (this.StrictlySimple)\n\t\t\t\t{\n\t\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\t\tif ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t\t\t\t\t\t(ePrev.OutIdx >= 0) && (ePrev.Curr.X === e.Curr.X) &&\n\t\t\t\t\t\t(ePrev.WindDelta !== 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar ip = new ClipperLib.IntPoint1(e.Curr);\n\n\t\t\t\t\t\tif (ClipperLib.use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar op = this.AddOutPt(ePrev, ip);\n\t\t\t\t\t\tvar op2 = this.AddOutPt(e, ip);\n\t\t\t\t\t\tthis.AddJoin(op, op2, ip); //StrictlySimple (type-3) join\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te = e.NextInAEL;\n\t\t\t}\n\t\t}\n\t\t//3. Process horizontals at the Top of the scanbeam ...\n\t\tthis.ProcessHorizontals();\n\t\tthis.m_Maxima = null;\n\t\t//4. Promote intermediate vertices ...\n\t\te = this.m_ActiveEdges;\n\t\twhile (e !== null)\n\t\t{\n\t\t\tif (this.IsIntermediate(e, topY))\n\t\t\t{\n\t\t\t\tvar op = null;\n\t\t\t\tif (e.OutIdx >= 0)\n\t\t\t\t\top = this.AddOutPt(e, e.Top);\n\t\t\t\te = this.UpdateEdgeIntoAEL(e);\n\t\t\t\t//if output polygons share an edge, they'll need joining later ...\n\t\t\t\tvar ePrev = e.PrevInAEL;\n\t\t\t\tvar eNext = e.NextInAEL;\n\n\t\t\t\tif (ePrev !== null && ePrev.Curr.X === e.Bot.X && ePrev.Curr.Y === e.Bot.Y && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr.Y === ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, ePrev.Curr, ePrev.Top, this.m_UseFullRange) && (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(ePrev2, e.Bot);\n\t\t\t\t\tthis.AddJoin(op, op2, e.Top);\n\t\t\t\t}\n\t\t\t\telse if (eNext !== null && eNext.Curr.X === e.Bot.X && eNext.Curr.Y === e.Bot.Y && op !== null && eNext.OutIdx >= 0 && eNext.Curr.Y === eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual5(e.Curr, e.Top, eNext.Curr, eNext.Top, this.m_UseFullRange) && (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t\t\t\t{\n\t\t\t\t\tvar op2 = this.AddOutPt(eNext, e.Bot);\n\t\t\t\t\tthis.AddJoin(op, op2, e.Top);\n\t\t\t\t}\n\t\t\t}\n\t\t\te = e.NextInAEL;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t{\n\t\tvar eMaxPair = this.GetMaximaPairEx(e);\n\t\tif (eMaxPair === null)\n\t\t{\n\t\t\tif (e.OutIdx >= 0)\n\t\t\t\tthis.AddOutPt(e, e.Top);\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\treturn;\n\t\t}\n\t\tvar eNext = e.NextInAEL;\n\t\twhile (eNext !== null && eNext !== eMaxPair)\n\t\t{\n\t\t\tthis.IntersectEdges(e, eNext, e.Top);\n\t\t\tthis.SwapPositionsInAEL(e, eNext);\n\t\t\teNext = e.NextInAEL;\n\t\t}\n\t\tif (e.OutIdx === -1 && eMaxPair.OutIdx === -1)\n\t\t{\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t\t{\n\t\t\tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse if (ClipperLib.use_lines && e.WindDelta === 0)\n\t\t{\n\t\t\tif (e.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(e, e.Top);\n\t\t\t\te.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(e);\n\t\t\tif (eMaxPair.OutIdx >= 0)\n\t\t\t{\n\t\t\t\tthis.AddOutPt(eMaxPair, e.Top);\n\t\t\t\teMaxPair.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t\t\t}\n\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t\t}\n\t\telse\n\t\t\tClipperLib.Error(\"DoMaxima error\");\n\t};\n\n\tClipperLib.Clipper.ReversePaths = function (polys)\n\t{\n\t\tfor (var i = 0, len = polys.length; i < len; i++)\n\t\t\tpolys[i].reverse();\n\t};\n\n\tClipperLib.Clipper.Orientation = function (poly)\n\t{\n\t\treturn ClipperLib.Clipper.Area(poly) >= 0;\n\t};\n\n\tClipperLib.Clipper.prototype.PointCount = function (pts)\n\t{\n\t\tif (pts === null)\n\t\t\treturn 0;\n\t\tvar result = 0;\n\t\tvar p = pts;\n\t\tdo {\n\t\t\tresult++;\n\t\t\tp = p.Next;\n\t\t}\n\t\twhile (p !== pts)\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t{\n\t\tClipperLib.Clear(polyg);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts === null)\n\t\t\t\tcontinue;\n\t\t\tvar p = outRec.Pts.Prev;\n\t\t\tvar cnt = this.PointCount(p);\n\t\t\tif (cnt < 2)\n\t\t\t\tcontinue;\n\t\t\tvar pg = new Array(cnt);\n\t\t\tfor (var j = 0; j < cnt; j++)\n\t\t\t{\n\t\t\t\tpg[j] = p.Pt;\n\t\t\t\tp = p.Prev;\n\t\t\t}\n\t\t\tpolyg.push(pg);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t{\n\t\tpolytree.Clear();\n\t\t//add each output polygon/contour to polytree ...\n\t\t//polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tvar cnt = this.PointCount(outRec.Pts);\n\t\t\tif ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t\t\t\tcontinue;\n\t\t\tthis.FixHoleLinkage(outRec);\n\t\t\tvar pn = new ClipperLib.PolyNode();\n\t\t\tpolytree.m_AllPolys.push(pn);\n\t\t\toutRec.PolyNode = pn;\n\t\t\tpn.m_polygon.length = cnt;\n\t\t\tvar op = outRec.Pts.Prev;\n\t\t\tfor (var j = 0; j < cnt; j++)\n\t\t\t{\n\t\t\t\tpn.m_polygon[j] = op.Pt;\n\t\t\t\top = op.Prev;\n\t\t\t}\n\t\t}\n\t\t//fixup PolyNode links etc ...\n\t\t//polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.PolyNode === null)\n\t\t\t\tcontinue;\n\t\t\telse if (outRec.IsOpen)\n\t\t\t{\n\t\t\t\toutRec.PolyNode.IsOpen = true;\n\t\t\t\tpolytree.AddChild(outRec.PolyNode);\n\t\t\t}\n\t\t\telse if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode !== null)\n\t\t\t\toutRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t\t\telse\n\t\t\t\tpolytree.AddChild(outRec.PolyNode);\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixupOutPolyline = function (outRec)\n\t{\n\t\tvar pp = outRec.Pts;\n\t\tvar lastPP = pp.Prev;\n\t\twhile (pp !== lastPP)\n\t\t{\n\t\t\tpp = pp.Next;\n\t\t\tif (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt))\n\t\t\t{\n\t\t\t\tif (pp === lastPP)\n\t\t\t\t{\n\t\t\t\t\tlastPP = pp.Prev;\n\t\t\t\t}\n\t\t\t\tvar tmpPP = pp.Prev;\n\t\t\t\ttmpPP.Next = pp.Next;\n\t\t\t\tpp.Next.Prev = tmpPP;\n\t\t\t\tpp = tmpPP;\n\t\t\t}\n\t\t}\n\t\tif (pp === pp.Prev)\n\t\t{\n\t\t\toutRec.Pts = null;\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t{\n\t\t//FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t\t//parallel edges by removing the middle vertex.\n\t\tvar lastOK = null;\n\t\toutRec.BottomPt = null;\n\t\tvar pp = outRec.Pts;\n\t\tvar preserveCol = this.PreserveCollinear || this.StrictlySimple;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (pp.Prev === pp || pp.Prev === pp.Next)\n\t\t\t{\n\t\t\t\toutRec.Pts = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//test for duplicate points and collinear edges ...\n\t\t\tif ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) || (ClipperLib.ClipperBase.SlopesEqual4(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) && (!preserveCol || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t\t\t{\n\t\t\t\tlastOK = null;\n\t\t\t\tpp.Prev.Next = pp.Next;\n\t\t\t\tpp.Next.Prev = pp.Prev;\n\t\t\t\tpp = pp.Prev;\n\t\t\t}\n\t\t\telse if (pp === lastOK)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (lastOK === null)\n\t\t\t\t\tlastOK = pp;\n\t\t\t\tpp = pp.Next;\n\t\t\t}\n\t\t}\n\t\toutRec.Pts = pp;\n\t};\n\n\tClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t{\n\t\tvar result = new ClipperLib.OutPt();\n\t\t//result.Pt = outPt.Pt;\n\t\tresult.Pt.X = outPt.Pt.X;\n\t\tresult.Pt.Y = outPt.Pt.Y;\n\t\tif (ClipperLib.use_xyz) result.Pt.Z = outPt.Pt.Z;\n\t\tresult.Idx = outPt.Idx;\n\t\tif (InsertAfter)\n\t\t{\n\t\t\tresult.Next = outPt.Next;\n\t\t\tresult.Prev = outPt;\n\t\t\toutPt.Next.Prev = result;\n\t\t\toutPt.Next = result;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.Prev = outPt.Prev;\n\t\t\tresult.Next = outPt;\n\t\t\toutPt.Prev.Next = result;\n\t\t\toutPt.Prev = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t{\n\t\tif (a1 < a2)\n\t\t{\n\t\t\tif (b1 < b2)\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a1, b1);\n\t\t\t\t$val.Right = Math.min(a2, b2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a1, b2);\n\t\t\t\t$val.Right = Math.min(a2, b1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (b1 < b2)\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a2, b1);\n\t\t\t\t$val.Right = Math.min(a1, b2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$val.Left = Math.max(a2, b2);\n\t\t\t\t$val.Right = Math.min(a1, b1);\n\t\t\t}\n\t\t}\n\t\treturn $val.Left < $val.Right;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t{\n\t\tvar Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t\tvar Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t\tif (Dir1 === Dir2)\n\t\t\treturn false;\n\t\t//When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t\t//want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t\t//So, to facilitate this while inserting Op1b and Op2b ...\n\t\t//when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t\t//otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t\tif (Dir1 === ClipperLib.Direction.dLeftToRight)\n\t\t{\n\t\t\twhile (op1.Next.Pt.X <= Pt.X &&\n\t\t\t\top1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y === Pt.Y)\n\t\t\t\top1 = op1.Next;\n\t\t\tif (DiscardLeft && (op1.Pt.X !== Pt.X))\n\t\t\t\top1 = op1.Next;\n\t\t\top1b = this.DupOutPt(op1, !DiscardLeft);\n\t\t\tif (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t\t\t{\n\t\t\t\top1 = op1b;\n\t\t\t\t//op1.Pt = Pt;\n\t\t\t\top1.Pt.X = Pt.X;\n\t\t\t\top1.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;\n\t\t\t\top1b = this.DupOutPt(op1, !DiscardLeft);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (op1.Next.Pt.X >= Pt.X &&\n\t\t\t\top1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y === Pt.Y)\n\t\t\t\top1 = op1.Next;\n\t\t\tif (!DiscardLeft && (op1.Pt.X !== Pt.X))\n\t\t\t\top1 = op1.Next;\n\t\t\top1b = this.DupOutPt(op1, DiscardLeft);\n\t\t\tif (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t\t\t{\n\t\t\t\top1 = op1b;\n\t\t\t\t//op1.Pt = Pt;\n\t\t\t\top1.Pt.X = Pt.X;\n\t\t\t\top1.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op1.Pt.Z = Pt.Z;\n\t\t\t\top1b = this.DupOutPt(op1, DiscardLeft);\n\t\t\t}\n\t\t}\n\t\tif (Dir2 === ClipperLib.Direction.dLeftToRight)\n\t\t{\n\t\t\twhile (op2.Next.Pt.X <= Pt.X &&\n\t\t\t\top2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y === Pt.Y)\n\t\t\t\top2 = op2.Next;\n\t\t\tif (DiscardLeft && (op2.Pt.X !== Pt.X))\n\t\t\t\top2 = op2.Next;\n\t\t\top2b = this.DupOutPt(op2, !DiscardLeft);\n\t\t\tif (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t\t\t{\n\t\t\t\top2 = op2b;\n\t\t\t\t//op2.Pt = Pt;\n\t\t\t\top2.Pt.X = Pt.X;\n\t\t\t\top2.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;\n\t\t\t\top2b = this.DupOutPt(op2, !DiscardLeft);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (op2.Next.Pt.X >= Pt.X &&\n\t\t\t\top2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y === Pt.Y)\n\t\t\t\top2 = op2.Next;\n\t\t\tif (!DiscardLeft && (op2.Pt.X !== Pt.X))\n\t\t\t\top2 = op2.Next;\n\t\t\top2b = this.DupOutPt(op2, DiscardLeft);\n\t\t\tif (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t\t\t{\n\t\t\t\top2 = op2b;\n\t\t\t\t//op2.Pt = Pt;\n\t\t\t\top2.Pt.X = Pt.X;\n\t\t\t\top2.Pt.Y = Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) op2.Pt.Z = Pt.Z;\n\t\t\t\top2b = this.DupOutPt(op2, DiscardLeft);\n\t\t\t}\n\t\t}\n\t\tif ((Dir1 === ClipperLib.Direction.dLeftToRight) === DiscardLeft)\n\t\t{\n\t\t\top1.Prev = op2;\n\t\t\top2.Next = op1;\n\t\t\top1b.Next = op2b;\n\t\t\top2b.Prev = op1b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\top1.Next = op2;\n\t\t\top2.Prev = op1;\n\t\t\top1b.Prev = op2b;\n\t\t\top2b.Next = op1b;\n\t\t}\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t{\n\t\tvar op1 = j.OutPt1,\n\t\t\top1b = new ClipperLib.OutPt();\n\t\tvar op2 = j.OutPt2,\n\t\t\top2b = new ClipperLib.OutPt();\n\t\t//There are 3 kinds of joins for output polygons ...\n\t\t//1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are vertices anywhere\n\t\t//along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t\t//2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t\t//location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t\t//3. StrictlySimple joins where edges touch but are not collinear and where\n\t\t//Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t\tvar isHorizontal = (j.OutPt1.Pt.Y === j.OffPt.Y);\n\t\tif (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t\t{\n\t\t\t//Strictly Simple join ...\n\t\t\tif (outRec1 !== outRec2) return false;\n\n\t\t\top1b = j.OutPt1.Next;\n\t\t\twhile (op1b !== op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t\t\t\top1b = op1b.Next;\n\t\t\tvar reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t\t\top2b = j.OutPt2.Next;\n\t\t\twhile (op2b !== op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t\t\t\top2b = op2b.Next;\n\t\t\tvar reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t\t\tif (reverse1 === reverse2)\n\t\t\t\treturn false;\n\t\t\tif (reverse1)\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, false);\n\t\t\t\top2b = this.DupOutPt(op2, true);\n\t\t\t\top1.Prev = op2;\n\t\t\t\top2.Next = op1;\n\t\t\t\top1b.Next = op2b;\n\t\t\t\top2b.Prev = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, true);\n\t\t\t\top2b = this.DupOutPt(op2, false);\n\t\t\t\top1.Next = op2;\n\t\t\t\top2.Prev = op1;\n\t\t\t\top1b.Prev = op2b;\n\t\t\t\top2b.Next = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (isHorizontal)\n\t\t{\n\t\t\t//treat horizontal joins differently to non-horizontal joins since with\n\t\t\t//them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t\t\t//may be anywhere along the horizontal edge.\n\t\t\top1b = op1;\n\t\t\twhile (op1.Prev.Pt.Y === op1.Pt.Y && op1.Prev !== op1b && op1.Prev !== op2)\n\t\t\t\top1 = op1.Prev;\n\t\t\twhile (op1b.Next.Pt.Y === op1b.Pt.Y && op1b.Next !== op1 && op1b.Next !== op2)\n\t\t\t\top1b = op1b.Next;\n\t\t\tif (op1b.Next === op1 || op1b.Next === op2)\n\t\t\t\treturn false;\n\t\t\t//a flat 'polygon'\n\t\t\top2b = op2;\n\t\t\twhile (op2.Prev.Pt.Y === op2.Pt.Y && op2.Prev !== op2b && op2.Prev !== op1b)\n\t\t\t\top2 = op2.Prev;\n\t\t\twhile (op2b.Next.Pt.Y === op2b.Pt.Y && op2b.Next !== op2 && op2b.Next !== op1)\n\t\t\t\top2b = op2b.Next;\n\t\t\tif (op2b.Next === op2 || op2b.Next === op1)\n\t\t\t\treturn false;\n\t\t\t//a flat 'polygon'\n\t\t\t//Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n\t\t\tvar $val = {\n\t\t\t\tLeft: null,\n\t\t\t\tRight: null\n\t\t\t};\n\n\t\t\tif (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t\t\t\treturn false;\n\t\t\tvar Left = $val.Left;\n\t\t\tvar Right = $val.Right;\n\n\t\t\t//DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t\t\t//which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t\t\t//on the discard Side as either may still be needed for other joins ...\n\t\t\tvar Pt = new ClipperLib.IntPoint0();\n\t\t\tvar DiscardLeftSide;\n\t\t\tif (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op1.Pt;\n\t\t\t\tPt.X = op1.Pt.X;\n\t\t\t\tPt.Y = op1.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op1.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t\t\t}\n\t\t\telse if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op2.Pt;\n\t\t\t\tPt.X = op2.Pt.X;\n\t\t\t\tPt.Y = op2.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op2.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t\t\t}\n\t\t\telse if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t\t\t{\n\t\t\t\t//Pt = op1b.Pt;\n\t\t\t\tPt.X = op1b.Pt.X;\n\t\t\t\tPt.Y = op1b.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op1b.Pt.Z;\n\t\t\t\tDiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Pt = op2b.Pt;\n\t\t\t\tPt.X = op2b.Pt.X;\n\t\t\t\tPt.Y = op2b.Pt.Y;\n\t\t\t\tif (ClipperLib.use_xyz) Pt.Z = op2b.Pt.Z;\n\t\t\t\tDiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t\t\t}\n\t\t\tj.OutPt1 = op1;\n\t\t\tj.OutPt2 = op2;\n\t\t\treturn this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//nb: For non-horizontal joins ...\n\t\t\t//    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t\t\t//    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t\t\t//make sure the polygons are correctly oriented ...\n\t\t\top1b = op1.Next;\n\t\t\twhile ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n\t\t\t\top1b = op1b.Next;\n\t\t\tvar Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t\t\tif (Reverse1)\n\t\t\t{\n\t\t\t\top1b = op1.Prev;\n\t\t\t\twhile ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b !== op1))\n\t\t\t\t\top1b = op1b.Prev;\n\n\t\t\t\tif ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\top2b = op2.Next;\n\t\t\twhile ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n\t\t\t\top2b = op2b.Next;\n\n\t\t\tvar Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t\t\tif (Reverse2)\n\t\t\t{\n\t\t\t\top2b = op2.Prev;\n\t\t\t\twhile ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b !== op2))\n\t\t\t\t\top2b = op2b.Prev;\n\n\t\t\t\tif ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual4(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ((op1b === op1) || (op2b === op2) || (op1b === op2b) ||\n\t\t\t\t((outRec1 === outRec2) && (Reverse1 === Reverse2)))\n\t\t\t\treturn false;\n\t\t\tif (Reverse1)\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, false);\n\t\t\t\top2b = this.DupOutPt(op2, true);\n\t\t\t\top1.Prev = op2;\n\t\t\t\top2.Next = op1;\n\t\t\t\top1b.Next = op2b;\n\t\t\t\top2b.Prev = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top1b = this.DupOutPt(op1, true);\n\t\t\t\top2b = this.DupOutPt(op2, false);\n\t\t\t\top1.Next = op2;\n\t\t\t\top2.Prev = op1;\n\t\t\t\top1b.Prev = op2b;\n\t\t\t\top2b.Next = op1b;\n\t\t\t\tj.OutPt1 = op1;\n\t\t\t\tj.OutPt2 = op1b;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.GetBounds = function (paths)\n\t{\n\t\tvar i = 0,\n\t\t\tcnt = paths.length;\n\t\twhile (i < cnt && paths[i].length === 0) i++;\n\t\tif (i === cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t\tvar result = new ClipperLib.IntRect();\n\t\tresult.left = paths[i][0].X;\n\t\tresult.right = result.left;\n\t\tresult.top = paths[i][0].Y;\n\t\tresult.bottom = result.top;\n\t\tfor (; i < cnt; i++)\n\t\t\tfor (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t\t\t{\n\t\t\t\tif (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t\t\t\telse if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t\t\t\tif (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t\t\t\telse if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t\t\t}\n\t\treturn result;\n\t}\n\tClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t{\n\t\tvar opStart = ops;\n\t\tvar result = new ClipperLib.IntRect();\n\t\tresult.left = ops.Pt.X;\n\t\tresult.right = ops.Pt.X;\n\t\tresult.top = ops.Pt.Y;\n\t\tresult.bottom = ops.Pt.Y;\n\t\tops = ops.Next;\n\t\twhile (ops !== opStart)\n\t\t{\n\t\t\tif (ops.Pt.X < result.left)\n\t\t\t\tresult.left = ops.Pt.X;\n\t\t\tif (ops.Pt.X > result.right)\n\t\t\t\tresult.right = ops.Pt.X;\n\t\t\tif (ops.Pt.Y < result.top)\n\t\t\t\tresult.top = ops.Pt.Y;\n\t\t\tif (ops.Pt.Y > result.bottom)\n\t\t\t\tresult.bottom = ops.Pt.Y;\n\t\t\tops = ops.Next;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t{\n\t\t//returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t\t//http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t\tvar result = 0,\n\t\t\tcnt = path.length;\n\t\tif (cnt < 3)\n\t\t\treturn 0;\n\t\tvar ip = path[0];\n\t\tfor (var i = 1; i <= cnt; ++i)\n\t\t{\n\t\t\tvar ipNext = (i === cnt ? path[0] : path[i]);\n\t\t\tif (ipNext.Y === pt.Y)\n\t\t\t{\n\t\t\t\tif ((ipNext.X === pt.X) || (ip.Y === pt.Y && ((ipNext.X > pt.X) === (ip.X < pt.X))))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((ip.Y < pt.Y) !== (ipNext.Y < pt.Y))\n\t\t\t{\n\t\t\t\tif (ip.X >= pt.X)\n\t\t\t\t{\n\t\t\t\t\tif (ipNext.X > pt.X)\n\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\telse if ((d > 0) === (ipNext.Y > ip.Y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (ipNext.X > pt.X)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\telse if ((d > 0) === (ipNext.Y > ip.Y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tip = ipNext;\n\t\t}\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t{\n\t\t//returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\tvar result = 0;\n\t\tvar startOp = op;\n\t\tvar ptx = pt.X,\n\t\t\tpty = pt.Y;\n\t\tvar poly0x = op.Pt.X,\n\t\t\tpoly0y = op.Pt.Y;\n\t\tdo {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X,\n\t\t\t\tpoly1y = op.Pt.Y;\n\t\t\tif (poly1y === pty)\n\t\t\t{\n\t\t\t\tif ((poly1x === ptx) || (poly0y === pty && ((poly1x > ptx) === (poly0x < ptx))))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ((poly0y < pty) !== (poly1y < pty))\n\t\t\t{\n\t\t\t\tif (poly0x >= ptx)\n\t\t\t\t{\n\t\t\t\t\tif (poly1x > ptx)\n\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tif ((d > 0) === (poly1y > poly0y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (poly1x > ptx)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t\t\t\t\t\tif (d === 0)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tif ((d > 0) === (poly1y > poly0y))\n\t\t\t\t\t\t\tresult = 1 - result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpoly0x = poly1x;\n\t\t\tpoly0y = poly1y;\n\t\t} while (startOp !== op);\n\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t{\n\t\tvar op = outPt1;\n\t\tdo {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t\t\tvar res = this.PointInPolygon(op.Pt, outPt2);\n\t\t\tif (res >= 0)\n\t\t\t\treturn res > 0;\n\t\t\top = op.Next;\n\t\t}\n\t\twhile (op !== outPt1)\n\t\treturn true;\n\t};\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t{\n\t\tvar outRec, firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (outRec.Pts !== null && firstLeft === OldOutRec)\n\t\t\t{\n\t\t\t\tif (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t\t\t\t\toutRec.FirstLeft = NewOutRec;\n\t\t\t}\n\t\t}\n\t}\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts2 = function (innerOutRec, outerOutRec)\n\t{\n\t\t//A polygon has split into two such that one is now the inner of the other.\n\t\t//It's possible that these polygons now wrap around other polygons, so check\n\t\t//every polygon that's also contained by OuterOutRec's FirstLeft container\n\t\t//(including nil) to see if they've become inner to the new inner polygon ...\n\t\tvar orfl = outerOutRec.FirstLeft;\n\t\tvar outRec, firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts === null || outRec === outerOutRec || outRec === innerOutRec)\n\t\t\t\tcontinue;\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft !== orfl && firstLeft !== innerOutRec && firstLeft !== outerOutRec)\n\t\t\t\tcontinue;\n\t\t\tif (this.Poly2ContainsPoly1(outRec.Pts, innerOutRec.Pts))\n\t\t\t\toutRec.FirstLeft = innerOutRec;\n\t\t\telse if (this.Poly2ContainsPoly1(outRec.Pts, outerOutRec.Pts))\n\t\t\t\toutRec.FirstLeft = outerOutRec;\n\t\t\telse if (outRec.FirstLeft === innerOutRec || outRec.FirstLeft === outerOutRec)\n\t\t\t\toutRec.FirstLeft = orfl;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.prototype.FixupFirstLefts3 = function (OldOutRec, NewOutRec)\n\t{\n\t\t//same as FixupFirstLefts1 but doesn't call Poly2ContainsPoly1()\n\t\tvar outRec;\n\t\tvar firstLeft;\n\t\tfor (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t\t{\n\t\t\toutRec = this.m_PolyOuts[i];\n\t\t\tfirstLeft = ClipperLib.Clipper.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (outRec.Pts !== null && firstLeft === OldOutRec)\n\t\t\t\toutRec.FirstLeft = NewOutRec;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t{\n\t\twhile (FirstLeft !== null && FirstLeft.Pts === null)\n\t\t\tFirstLeft = FirstLeft.FirstLeft;\n\t\treturn FirstLeft;\n\t};\n\n\tClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t{\n\t\tfor (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t\t{\n\t\t\tvar join = this.m_Joins[i];\n\t\t\tvar outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t\t\tvar outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t\t\tif (outRec1.Pts === null || outRec2.Pts === null)\n\t\t\t\tcontinue;\n\n\t\t\tif (outRec1.IsOpen || outRec2.IsOpen)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//get the polygon fragment with the correct hole state (FirstLeft)\n\t\t\t//before calling JoinPoints() ...\n\t\t\tvar holeStateRec;\n\t\t\tif (outRec1 === outRec2)\n\t\t\t\tholeStateRec = outRec1;\n\t\t\telse if (this.OutRec1RightOfOutRec2(outRec1, outRec2))\n\t\t\t\tholeStateRec = outRec2;\n\t\t\telse if (this.OutRec1RightOfOutRec2(outRec2, outRec1))\n\t\t\t\tholeStateRec = outRec1;\n\t\t\telse\n\t\t\t\tholeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n\t\t\tif (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n\t\t\tif (outRec1 === outRec2)\n\t\t\t{\n\t\t\t\t//instead of joining two polygons, we've just created a new one by\n\t\t\t\t//splitting one polygon into two.\n\t\t\t\toutRec1.Pts = join.OutPt1;\n\t\t\t\toutRec1.BottomPt = null;\n\t\t\t\toutRec2 = this.CreateOutRec();\n\t\t\t\toutRec2.Pts = join.OutPt2;\n\t\t\t\t//update all OutRec2.Pts Idx's ...\n\t\t\t\tthis.UpdateOutPtIdxs(outRec2);\n\n\t\t\t\tif (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t\t\t\t{\n\t\t\t\t\t//outRec1 contains outRec2 ...\n\t\t\t\t\toutRec2.IsHole = !outRec1.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1;\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts2(outRec2, outRec1);\n\t\t\t\t\tif ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec2) > 0))\n\t\t\t\t\t\tthis.ReversePolyPtLinks(outRec2.Pts);\n\t\t\t\t}\n\t\t\t\telse if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t\t\t\t{\n\t\t\t\t\t//outRec2 contains outRec1 ...\n\t\t\t\t\toutRec2.IsHole = outRec1.IsHole;\n\t\t\t\t\toutRec1.IsHole = !outRec2.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1.FirstLeft;\n\t\t\t\t\toutRec1.FirstLeft = outRec2;\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts2(outRec1, outRec2);\n\n\t\t\t\t\tif ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area$1(outRec1) > 0))\n\t\t\t\t\t\tthis.ReversePolyPtLinks(outRec1.Pts);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//the 2 polygons are completely separate ...\n\t\t\t\t\toutRec2.IsHole = outRec1.IsHole;\n\t\t\t\t\toutRec2.FirstLeft = outRec1.FirstLeft;\n\t\t\t\t\t//fixup FirstLeft pointers that may need reassigning to OutRec2\n\t\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\t\tthis.FixupFirstLefts1(outRec1, outRec2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//joined 2 polygons together ...\n\t\t\t\toutRec2.Pts = null;\n\t\t\t\toutRec2.BottomPt = null;\n\t\t\t\toutRec2.Idx = outRec1.Idx;\n\t\t\t\toutRec1.IsHole = holeStateRec.IsHole;\n\t\t\t\tif (holeStateRec === outRec2)\n\t\t\t\t\toutRec1.FirstLeft = outRec2.FirstLeft;\n\t\t\t\toutRec2.FirstLeft = outRec1;\n\t\t\t\t//fixup FirstLeft pointers that may need reassigning to OutRec1\n\t\t\t\tif (this.m_UsingPolyTree)\n\t\t\t\t\tthis.FixupFirstLefts3(outRec2, outRec1);\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t{\n\t\tvar op = outrec.Pts;\n\t\tdo {\n\t\t\top.Idx = outrec.Idx;\n\t\t\top = op.Prev;\n\t\t}\n\t\twhile (op !== outrec.Pts)\n\t};\n\n\tClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t{\n\t\tvar i = 0;\n\t\twhile (i < this.m_PolyOuts.length)\n\t\t{\n\t\t\tvar outrec = this.m_PolyOuts[i++];\n\t\t\tvar op = outrec.Pts;\n\t\t\tif (op === null || outrec.IsOpen)\n\t\t\t\tcontinue;\n\t\t\tdo //for each Pt in Polygon until duplicate found do ...\n\t\t\t{\n\t\t\t\tvar op2 = op.Next;\n\t\t\t\twhile (op2 !== outrec.Pts)\n\t\t\t\t{\n\t\t\t\t\tif ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next !== op && op2.Prev !== op)\n\t\t\t\t\t{\n\t\t\t\t\t\t//split the polygon into two ...\n\t\t\t\t\t\tvar op3 = op.Prev;\n\t\t\t\t\t\tvar op4 = op2.Prev;\n\t\t\t\t\t\top.Prev = op4;\n\t\t\t\t\t\top4.Next = op;\n\t\t\t\t\t\top2.Prev = op3;\n\t\t\t\t\t\top3.Next = op2;\n\t\t\t\t\t\toutrec.Pts = op;\n\t\t\t\t\t\tvar outrec2 = this.CreateOutRec();\n\t\t\t\t\t\toutrec2.Pts = op2;\n\t\t\t\t\t\tthis.UpdateOutPtIdxs(outrec2);\n\t\t\t\t\t\tif (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//OutRec2 is contained by OutRec1 ...\n\t\t\t\t\t\t\toutrec2.IsHole = !outrec.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//OutRec1 is contained by OutRec2 ...\n\t\t\t\t\t\t\toutrec2.IsHole = outrec.IsHole;\n\t\t\t\t\t\t\toutrec.IsHole = !outrec2.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\toutrec.FirstLeft = outrec2;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//the 2 polygons are separate ...\n\t\t\t\t\t\t\toutrec2.IsHole = outrec.IsHole;\n\t\t\t\t\t\t\toutrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\top2 = op;\n\t\t\t\t\t\t//ie get ready for the next iteration\n\t\t\t\t\t}\n\t\t\t\t\top2 = op2.Next;\n\t\t\t\t}\n\t\t\t\top = op.Next;\n\t\t\t}\n\t\t\twhile (op !== outrec.Pts)\n\t\t}\n\t};\n\n\tClipperLib.Clipper.Area = function (poly)\n\t{\n\t\tif (!Array.isArray(poly))\n\t\t\treturn 0;\n\t\tvar cnt = poly.length;\n\t\tif (cnt < 3)\n\t\t\treturn 0;\n\t\tvar a = 0;\n\t\tfor (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t\t{\n\t\t\ta += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t\t\tj = i;\n\t\t}\n\t\treturn -a * 0.5;\n\t};\n\n\tClipperLib.Clipper.prototype.Area = function (op)\n\t{\n\t\tvar opFirst = op;\n\t\tif (op === null) return 0;\n\t\tvar a = 0;\n\t\tdo {\n\t\t\ta = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t\t\top = op.Next;\n\t\t} while (op !== opFirst); // && typeof op !== 'undefined');\n\t\treturn a * 0.5;\n\t}\n\n\tClipperLib.Clipper.prototype.Area$1 = function (outRec)\n\t{\n\t\treturn this.Area(outRec.Pts);\n\t};\n\n\tClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t{\n\t\tvar result = new Array();\n\t\tvar c = new ClipperLib.Clipper(0);\n\t\tc.StrictlySimple = true;\n\t\tc.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t{\n\t\tif (typeof (fillType) === \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t\tvar result = new Array();\n\t\tvar c = new ClipperLib.Clipper(0);\n\t\tc.StrictlySimple = true;\n\t\tc.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t{\n\t\tvar dx = (pt1.X - pt2.X);\n\t\tvar dy = (pt1.Y - pt2.Y);\n\t\treturn (dx * dx + dy * dy);\n\t};\n\n\tClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t{\n\t\t//The equation of a line in general form (Ax + By + C = 0)\n\t\t//given 2 points (x¹,y¹) & (x²,y²) is ...\n\t\t//(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n\t\t//A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n\t\t//perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n\t\t//see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t\tvar A = ln1.Y - ln2.Y;\n\t\tvar B = ln2.X - ln1.X;\n\t\tvar C = A * ln1.X + B * ln1.Y;\n\t\tC = A * pt.X + B * pt.Y - C;\n\t\treturn (C * C) / (A * A + B * B);\n\t};\n\n\tClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\t\tif ((pt1.X > pt2.X) === (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) === (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) === (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) === (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t{\n\t\tvar dx = pt1.X - pt2.X;\n\t\tvar dy = pt1.Y - pt2.Y;\n\t\treturn ((dx * dx) + (dy * dy) <= distSqrd);\n\t};\n\n\tClipperLib.Clipper.ExcludeOp = function (op)\n\t{\n\t\tvar result = op.Prev;\n\t\tresult.Next = op.Next;\n\t\top.Next.Prev = result;\n\t\tresult.Idx = 0;\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t{\n\t\tif (typeof (distance) === \"undefined\") distance = 1.415;\n\t\t//distance = proximity in units/pixels below which vertices will be stripped.\n\t\t//Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t\t//both x & y coords within 1 unit, then the second vertex will be stripped.\n\t\tvar cnt = path.length;\n\t\tif (cnt === 0)\n\t\t\treturn new Array();\n\t\tvar outPts = new Array(cnt);\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t\toutPts[i] = new ClipperLib.OutPt();\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t{\n\t\t\toutPts[i].Pt = path[i];\n\t\t\toutPts[i].Next = outPts[(i + 1) % cnt];\n\t\t\toutPts[i].Next.Prev = outPts[i];\n\t\t\toutPts[i].Idx = 0;\n\t\t}\n\t\tvar distSqrd = distance * distance;\n\t\tvar op = outPts[0];\n\t\twhile (op.Idx === 0 && op.Next !== op.Prev)\n\t\t{\n\t\t\tif (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t\t\t{\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\telse if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t\t\t{\n\t\t\t\tClipperLib.Clipper.ExcludeOp(op.Next);\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt -= 2;\n\t\t\t}\n\t\t\telse if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t\t\t{\n\t\t\t\top = ClipperLib.Clipper.ExcludeOp(op);\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\top.Idx = 1;\n\t\t\t\top = op.Next;\n\t\t\t}\n\t\t}\n\t\tif (cnt < 3)\n\t\t\tcnt = 0;\n\t\tvar result = new Array(cnt);\n\t\tfor (var i = 0; i < cnt; ++i)\n\t\t{\n\t\t\tresult[i] = new ClipperLib.IntPoint1(op.Pt);\n\t\t\top = op.Next;\n\t\t}\n\t\toutPts = null;\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t{\n\t\tvar result = new Array(polys.length);\n\t\tfor (var i = 0, ilen = polys.length; i < ilen; i++)\n\t\t\tresult[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t{\n\t\tvar delta = (IsClosed ? 1 : 0);\n\t\tvar polyCnt = pattern.length;\n\t\tvar pathCnt = path.length;\n\t\tvar result = new Array();\n\t\tif (IsSum)\n\t\t\tfor (var i = 0; i < pathCnt; i++)\n\t\t\t{\n\t\t\t\tvar p = new Array(polyCnt);\n\t\t\t\tfor (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t\t\t\t\tp[j] = new ClipperLib.IntPoint2(path[i].X + ip.X, path[i].Y + ip.Y);\n\t\t\t\tresult.push(p);\n\t\t\t}\n\t\telse\n\t\t\tfor (var i = 0; i < pathCnt; i++)\n\t\t\t{\n\t\t\t\tvar p = new Array(polyCnt);\n\t\t\t\tfor (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t\t\t\t\tp[j] = new ClipperLib.IntPoint2(path[i].X - ip.X, path[i].Y - ip.Y);\n\t\t\t\tresult.push(p);\n\t\t\t}\n\t\tvar quads = new Array();\n\t\tfor (var i = 0; i < pathCnt - 1 + delta; i++)\n\t\t\tfor (var j = 0; j < polyCnt; j++)\n\t\t\t{\n\t\t\t\tvar quad = new Array();\n\t\t\t\tquad.push(result[i % pathCnt][j % polyCnt]);\n\t\t\t\tquad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t\t\t\tquad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t\t\t\tquad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t\t\t\tif (!ClipperLib.Clipper.Orientation(quad))\n\t\t\t\t\tquad.reverse();\n\t\t\t\tquads.push(quad);\n\t\t\t}\n\t\treturn quads;\n\t};\n\n\tClipperLib.Clipper.MinkowskiSum = function (pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif (!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint2(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n\tClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t{\n\t\tvar result = new Array();\n\t\t//result.set_Capacity(polytree.get_Total());\n\t\tClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t{\n\t\tvar match = true;\n\t\tswitch (nt)\n\t\t{\n\t\tcase ClipperLib.Clipper.NodeType.ntOpen:\n\t\t\treturn;\n\t\tcase ClipperLib.Clipper.NodeType.ntClosed:\n\t\t\tmatch = !polynode.IsOpen;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (polynode.m_polygon.length > 0 && match)\n\t\t\tpaths.push(polynode.m_polygon);\n\t\tfor (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t\t\tClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t};\n\n\tClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t{\n\t\tvar result = new ClipperLib.Paths();\n\t\t//result.set_Capacity(polytree.ChildCount());\n\t\tfor (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t\t\tif (polytree.Childs()[i].IsOpen)\n\t\t\t\tresult.push(polytree.Childs()[i].m_polygon);\n\t\treturn result;\n\t};\n\n\tClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t{\n\t\tvar result = new ClipperLib.Paths();\n\t\t//result.set_Capacity(polytree.Total());\n\t\tClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t\treturn result;\n\t};\n\n\tInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\tClipperLib.Clipper.NodeType = {\n\t\tntAny: 0,\n\t\tntOpen: 1,\n\t\tntClosed: 2\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t{\n\t\tif (typeof (miterLimit) === \"undefined\") miterLimit = 2;\n\t\tif (typeof (arcTolerance) === \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\tthis.m_destPolys = new ClipperLib.Paths();\n\t\tthis.m_srcPoly = new ClipperLib.Path();\n\t\tthis.m_destPoly = new ClipperLib.Path();\n\t\tthis.m_normals = new Array();\n\t\tthis.m_delta = 0;\n\t\tthis.m_sinA = 0;\n\t\tthis.m_sin = 0;\n\t\tthis.m_cos = 0;\n\t\tthis.m_miterLim = 0;\n\t\tthis.m_StepsPerRad = 0;\n\t\tthis.m_lowest = new ClipperLib.IntPoint0();\n\t\tthis.m_polyNodes = new ClipperLib.PolyNode();\n\t\tthis.MiterLimit = miterLimit;\n\t\tthis.ArcTolerance = arcTolerance;\n\t\tthis.m_lowest.X = -1;\n\t};\n\n\tClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\tClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\tClipperLib.ClipperOffset.prototype.Clear = function ()\n\t{\n\t\tClipperLib.Clear(this.m_polyNodes.Childs());\n\t\tthis.m_lowest.X = -1;\n\t};\n\n\tClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\tClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t{\n\t\tvar highI = path.length - 1;\n\t\tif (highI < 0)\n\t\t\treturn;\n\t\tvar newNode = new ClipperLib.PolyNode();\n\t\tnewNode.m_jointype = joinType;\n\t\tnewNode.m_endtype = endType;\n\t\t//strip duplicate points from path and also get index to the lowest point ...\n\t\tif (endType === ClipperLib.EndType.etClosedLine || endType === ClipperLib.EndType.etClosedPolygon)\n\t\t\twhile (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t\t\t\thighI--;\n\t\t//newNode.m_polygon.set_Capacity(highI + 1);\n\t\tnewNode.m_polygon.push(path[0]);\n\t\tvar j = 0,\n\t\t\tk = 0;\n\t\tfor (var i = 1; i <= highI; i++)\n\t\t\tif (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tnewNode.m_polygon.push(path[i]);\n\t\t\t\tif (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y === newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t\t\t\t\tk = j;\n\t\t\t}\n\t\tif (endType === ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n\t\tthis.m_polyNodes.AddChild(newNode);\n\t\t//if this path's lowest pt is lower than all the others then update m_lowest\n\t\tif (endType !== ClipperLib.EndType.etClosedPolygon)\n\t\t\treturn;\n\t\tif (this.m_lowest.X < 0)\n\t\t\tthis.m_lowest = new ClipperLib.IntPoint2(this.m_polyNodes.ChildCount() - 1, k);\n\t\telse\n\t\t{\n\t\t\tvar ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t\t\tif (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y === ip.Y && newNode.m_polygon[k].X < ip.X))\n\t\t\t\tthis.m_lowest = new ClipperLib.IntPoint2(this.m_polyNodes.ChildCount() - 1, k);\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t{\n\t\tfor (var i = 0, ilen = paths.length; i < ilen; i++)\n\t\t\tthis.AddPath(paths[i], joinType, endType);\n\t};\n\n\tClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t{\n\t\t//fixup orientations of all closed paths if the orientation of the\n\t\t//closed path with the lowermost vertex is wrong ...\n\t\tif (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t\t{\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon || (node.m_endtype === ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t\t\t\t\tnode.m_polygon.reverse();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t\t\t\t\tnode.m_polygon.reverse();\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t{\n\t\tvar dx = (pt2.X - pt1.X);\n\t\tvar dy = (pt2.Y - pt1.Y);\n\t\tif ((dx === 0) && (dy === 0))\n\t\t\treturn new ClipperLib.DoublePoint2(0, 0);\n\t\tvar f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t\tdx *= f;\n\t\tdy *= f;\n\t\treturn new ClipperLib.DoublePoint2(dy, -dx);\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t{\n\t\tthis.m_destPolys = new Array();\n\t\tthis.m_delta = delta;\n\t\t//if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t\tif (ClipperLib.ClipperBase.near_zero(delta))\n\t\t{\n\t\t\t//this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t\t{\n\t\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t\t\tthis.m_destPolys.push(node.m_polygon);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t//see offset_triginometry3.svg in the documentation folder ...\n\t\tif (this.MiterLimit > 2)\n\t\t\tthis.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t\telse\n\t\t\tthis.m_miterLim = 0.5;\n\t\tvar y;\n\t\tif (this.ArcTolerance <= 0)\n\t\t\ty = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\telse if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t\t\ty = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t\telse\n\t\t\ty = this.ArcTolerance;\n\t\t//see offset_triginometry2.svg in the documentation folder ...\n\t\tvar steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t\tthis.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t\tthis.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t\tthis.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t\tif (delta < 0)\n\t\t\tthis.m_sin = -this.m_sin;\n\t\t//this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t\tfor (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t\t{\n\t\t\tvar node = this.m_polyNodes.Childs()[i];\n\t\t\tthis.m_srcPoly = node.m_polygon;\n\t\t\tvar len = this.m_srcPoly.length;\n\t\t\tif (len === 0 || (delta <= 0 && (len < 3 || node.m_endtype !== ClipperLib.EndType.etClosedPolygon)))\n\t\t\t\tcontinue;\n\t\t\tthis.m_destPoly = new Array();\n\t\t\tif (len === 1)\n\t\t\t{\n\t\t\t\tif (node.m_jointype === ClipperLib.JoinType.jtRound)\n\t\t\t\t{\n\t\t\t\t\tvar X = 1,\n\t\t\t\t\t\tY = 0;\n\t\t\t\t\tfor (var j = 1; j <= steps; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t\t\t\t\t\tvar X2 = X;\n\t\t\t\t\t\tX = X * this.m_cos - this.m_sin * Y;\n\t\t\t\t\t\tY = X2 * this.m_sin + Y * this.m_cos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar X = -1,\n\t\t\t\t\t\tY = -1;\n\t\t\t\t\tfor (var j = 0; j < 4; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t\t\t\t\t\tif (X < 0)\n\t\t\t\t\t\t\tX = 1;\n\t\t\t\t\t\telse if (Y < 0)\n\t\t\t\t\t\t\tY = 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tX = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//build m_normals ...\n\t\t\tthis.m_normals.length = 0;\n\t\t\t//this.m_normals.set_Capacity(len);\n\t\t\tfor (var j = 0; j < len - 1; j++)\n\t\t\t\tthis.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedLine || node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t\tthis.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t\t\telse\n\t\t\t\tthis.m_normals.push(new ClipperLib.DoublePoint1(this.m_normals[len - 2]));\n\t\t\tif (node.m_endtype === ClipperLib.EndType.etClosedPolygon)\n\t\t\t{\n\t\t\t\tvar k = len - 1;\n\t\t\t\tfor (var j = 0; j < len; j++)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t\telse if (node.m_endtype === ClipperLib.EndType.etClosedLine)\n\t\t\t{\n\t\t\t\tvar k = len - 1;\n\t\t\t\tfor (var j = 0; j < len; j++)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t\tthis.m_destPoly = new Array();\n\t\t\t\t//re-build m_normals ...\n\t\t\t\tvar n = this.m_normals[len - 1];\n\t\t\t\tfor (var j = len - 1; j > 0; j--)\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.DoublePoint2(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t\t\t\tthis.m_normals[0] = new ClipperLib.DoublePoint2(-n.X, -n.Y);\n\t\t\t\tk = 0;\n\t\t\t\tfor (var j = len - 1; j >= 0; j--)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar k = 0;\n\t\t\t\tfor (var j = 1; j < len - 1; ++j)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tvar pt1;\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenButt)\n\t\t\t\t{\n\t\t\t\t\tvar j = len - 1;\n\t\t\t\t\tpt1 = new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t\tpt1 = new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar j = len - 1;\n\t\t\t\t\tk = len - 2;\n\t\t\t\t\tthis.m_sinA = 0;\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.DoublePoint2(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n\t\t\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoRound(j, k);\n\t\t\t\t}\n\t\t\t\t//re-build m_normals ...\n\t\t\t\tfor (var j = len - 1; j > 0; j--)\n\t\t\t\t\tthis.m_normals[j] = new ClipperLib.DoublePoint2(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t\t\t\tthis.m_normals[0] = new ClipperLib.DoublePoint2(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t\t\t\tk = len - 1;\n\t\t\t\tfor (var j = k - 1; j > 0; --j)\n\t\t\t\t\tk = this.OffsetPoint(j, k, node.m_jointype);\n\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenButt)\n\t\t\t\t{\n\t\t\t\t\tpt1 = new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t\tpt1 = new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t\t\t\t\tthis.m_destPoly.push(pt1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tk = 1;\n\t\t\t\t\tthis.m_sinA = 0;\n\t\t\t\t\tif (node.m_endtype === ClipperLib.EndType.etOpenSquare)\n\t\t\t\t\t\tthis.DoSquare(0, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoRound(0, 1);\n\t\t\t\t}\n\t\t\t\tthis.m_destPolys.push(this.m_destPoly);\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.Execute = function ()\n\t{\n\t\tvar a = arguments,\n\t\t\tispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t\tif (!ispolytree) // function (solution, delta)\n\t\t{\n\t\t\tvar solution = a[0],\n\t\t\t\tdelta = a[1];\n\t\t\tClipperLib.Clear(solution);\n\t\t\tthis.FixOrientations();\n\t\t\tthis.DoOffset(delta);\n\t\t\t//now clean up 'corners' ...\n\t\t\tvar clpr = new ClipperLib.Clipper(0);\n\t\t\tclpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t\t\t\tvar outer = new ClipperLib.Path();\n\t\t\t\touter.push(new ClipperLib.IntPoint2(r.left - 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.IntPoint2(r.right + 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.IntPoint2(r.right + 10, r.top - 10));\n\t\t\t\touter.push(new ClipperLib.IntPoint2(r.left - 10, r.top - 10));\n\t\t\t\tclpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tclpr.ReverseSolution = true;\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t\t\t\tif (solution.length > 0)\n\t\t\t\t\tsolution.splice(0, 1);\n\t\t\t}\n\t\t\t//console.log(JSON.stringify(solution));\n\t\t}\n\t\telse // function (polytree, delta)\n\t\t{\n\t\t\tvar solution = a[0],\n\t\t\t\tdelta = a[1];\n\t\t\tsolution.Clear();\n\t\t\tthis.FixOrientations();\n\t\t\tthis.DoOffset(delta);\n\t\t\t//now clean up 'corners' ...\n\t\t\tvar clpr = new ClipperLib.Clipper(0);\n\t\t\tclpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t\t\tif (delta > 0)\n\t\t\t{\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t\t\t\tvar outer = new ClipperLib.Path();\n\t\t\t\touter.push(new ClipperLib.IntPoint2(r.left - 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.IntPoint2(r.right + 10, r.bottom + 10));\n\t\t\t\touter.push(new ClipperLib.IntPoint2(r.right + 10, r.top - 10));\n\t\t\t\touter.push(new ClipperLib.IntPoint2(r.left - 10, r.top - 10));\n\t\t\t\tclpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tclpr.ReverseSolution = true;\n\t\t\t\tclpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t\t\t\t//remove the outer PolyNode rectangle ...\n\t\t\t\tif (solution.ChildCount() === 1 && solution.Childs()[0].ChildCount() > 0)\n\t\t\t\t{\n\t\t\t\t\tvar outerNode = solution.Childs()[0];\n\t\t\t\t\t//solution.Childs.set_Capacity(outerNode.ChildCount);\n\t\t\t\t\tsolution.Childs()[0] = outerNode.Childs()[0];\n\t\t\t\t\tsolution.Childs()[0].m_Parent = solution;\n\t\t\t\t\tfor (var i = 1; i < outerNode.ChildCount(); i++)\n\t\t\t\t\t\tsolution.AddChild(outerNode.Childs()[i]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsolution.Clear();\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t{\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n\t\telse if (this.m_sinA > 1)\n\t\t\tthis.m_sinA = 1.0;\n\t\telse if (this.m_sinA < -1)\n\t\t\tthis.m_sinA = -1.0;\n\t\tif (this.m_sinA * this.m_delta < 0)\n\t\t{\n\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint1(this.m_srcPoly[j]));\n\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t\t}\n\t\telse\n\t\t\tswitch (jointype)\n\t\t\t{\n\t\t\tcase ClipperLib.JoinType.jtMiter:\n\t\t\t\t{\n\t\t\t\t\tvar r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\t\tif (r >= this.m_miterLim)\n\t\t\t\t\t\tthis.DoMiter(j, k, r);\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase ClipperLib.JoinType.jtSquare:\n\t\t\t\tthis.DoSquare(j, k);\n\t\t\t\tbreak;\n\t\t\tcase ClipperLib.JoinType.jtRound:\n\t\t\t\tthis.DoRound(j, k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tk = j;\n\t\treturn k;\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t{\n\t\tvar dx = Math.tan(Math.atan2(this.m_sinA,\n\t\t\tthis.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(\n\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(\n\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t{\n\t\tvar q = this.m_delta / r;\n\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(\n\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t};\n\n\tClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t{\n\t\tvar a = Math.atan2(this.m_sinA,\n\t\t\tthis.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n\t\tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n\t\tvar X = this.m_normals[k].X,\n\t\t\tY = this.m_normals[k].Y,\n\t\t\tX2;\n\t\tfor (var i = 0; i < steps; ++i)\n\t\t{\n\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(\n\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t\t\tX2 = X;\n\t\t\tX = X * this.m_cos - this.m_sin * Y;\n\t\t\tY = X2 * this.m_sin + Y * this.m_cos;\n\t\t}\n\t\tthis.m_destPoly.push(new ClipperLib.IntPoint2(\n\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t};\n\n\tClipperLib.Error = function (message)\n\t{\n\t\ttry\n\t\t{\n\t\t\tthrow new Error(message);\n\t\t}\n\t\tcatch (err)\n\t\t{\n\t\t\talert(err.message);\n\t\t}\n\t};\n\n\t// ---------------------------------------------\n\n\t// JS extension by Timo 2013\n\tClipperLib.JS = {};\n\n\tClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t{\n\t\tif (!scale) scale = 1;\n\t\treturn ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t};\n\n\tClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t{\n\t\tif (!scale) scale = 1;\n\t\tvar area = 0;\n\t\tfor (var i = 0; i < poly.length; i++)\n\t\t{\n\t\t\tarea += ClipperLib.Clipper.Area(poly[i]);\n\t\t}\n\t\treturn area / (scale * scale);\n\t};\n\n\tClipperLib.JS.BoundsOfPath = function (path, scale)\n\t{\n\t\treturn ClipperLib.JS.BoundsOfPaths([path], scale);\n\t};\n\n\tClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t{\n\t\tif (!scale) scale = 1;\n\t\tvar bounds = ClipperLib.Clipper.GetBounds(paths);\n\t\tbounds.left /= scale;\n\t\tbounds.bottom /= scale;\n\t\tbounds.right /= scale;\n\t\tbounds.top /= scale;\n\t\treturn bounds;\n\t};\n\n\t// Clean() joins vertices that are too near each other\n\t// and causes distortion to offsetted polygons without cleaning\n\tClipperLib.JS.Clean = function (polygon, delta)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tvar polygon = ClipperLib.JS.Clone(polygon);\n\t\tif (typeof delta !== \"number\" || delta === null)\n\t\t{\n\t\t\tClipperLib.Error(\"Delta is not a number in Clean().\");\n\t\t\treturn polygon;\n\t\t}\n\t\tif (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar k_length = polygon.length;\n\t\tvar len, poly, result, d, p, j, i;\n\t\tvar results = [];\n\t\tfor (var k = 0; k < k_length; k++)\n\t\t{\n\t\t\tpoly = polygon[k];\n\t\t\tlen = poly.length;\n\t\t\tif (len === 0) continue;\n\t\t\telse if (len < 3)\n\t\t\t{\n\t\t\t\tresult = poly;\n\t\t\t\tresults.push(result);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult = poly;\n\t\t\td = delta * delta;\n\t\t\t//d = Math.floor(c_delta * c_delta);\n\t\t\tp = poly[0];\n\t\t\tj = 1;\n\t\t\tfor (i = 1; i < len; i++)\n\t\t\t{\n\t\t\t\tif ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t\t\t\t\t(poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult[j] = poly[i];\n\t\t\t\tp = poly[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tp = poly[j - 1];\n\t\t\tif ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t\t\t\t(poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t\t\t\tj--;\n\t\t\tif (j < len)\n\t\t\t\tresult.splice(j, len - j);\n\t\t\tif (result.length) results.push(result);\n\t\t}\n\t\tif (!isPolygons && results.length) results = results[0];\n\t\telse if (!isPolygons && results.length === 0) results = [];\n\t\telse if (isPolygons && results.length === 0) results = [\n\t\t\t[]\n\t\t];\n\t\treturn results;\n\t}\n\t// Make deep copy of Polygons or Polygon\n\t// so that also IntPoint objects are cloned and not only referenced\n\t// This should be the fastest way\n\tClipperLib.JS.Clone = function (polygon)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tif (polygon.length === 0) return [];\n\t\telse if (polygon.length === 1 && polygon[0].length === 0) return [\n\t\t\t[]\n\t\t];\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar len = polygon.length,\n\t\t\tplen, i, j, result;\n\t\tvar results = new Array(len);\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tplen = polygon[i].length;\n\t\t\tresult = new Array(plen);\n\t\t\tfor (j = 0; j < plen; j++)\n\t\t\t{\n\t\t\t\tresult[j] = {\n\t\t\t\t\tX: polygon[i][j].X,\n\t\t\t\t\tY: polygon[i][j].Y\n\t\t\t\t};\n\n\t\t\t}\n\t\t\tresults[i] = result;\n\t\t}\n\t\tif (!isPolygons) results = results[0];\n\t\treturn results;\n\t};\n\n\t// Removes points that doesn't affect much to the visual appearance.\n\t// If middle point is at or under certain distance (tolerance) of the line segment between\n\t// start and end point, the middle point is removed.\n\tClipperLib.JS.Lighten = function (polygon, tolerance)\n\t{\n\t\tif (!(polygon instanceof Array)) return [];\n\t\tif (typeof tolerance !== \"number\" || tolerance === null)\n\t\t{\n\t\t\tClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t\t\treturn ClipperLib.JS.Clone(polygon);\n\t\t}\n\t\tif (polygon.length === 0 || (polygon.length === 1 && polygon[0].length === 0) || tolerance < 0)\n\t\t{\n\t\t\treturn ClipperLib.JS.Clone(polygon);\n\t\t}\n\t\tvar isPolygons = polygon[0] instanceof Array;\n\t\tif (!isPolygons) polygon = [polygon];\n\t\tvar i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t\tvar bxax, byay, l, ax, ay;\n\t\tvar len = polygon.length;\n\t\tvar toleranceSq = tolerance * tolerance;\n\t\tvar results = [];\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tpoly = polygon[i];\n\t\t\tplen = poly.length;\n\t\t\tif (plen === 0) continue;\n\t\t\tfor (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t\t\t{\n\t\t\t\tpoly2 = [];\n\t\t\t\tplen = poly.length;\n\t\t\t\t// the first have to added to the end, if first and last are not the same\n\t\t\t\t// this way we ensure that also the actual last point can be removed if needed\n\t\t\t\tif (poly[plen - 1].X !== poly[0].X || poly[plen - 1].Y !== poly[0].Y)\n\t\t\t\t{\n\t\t\t\t\taddlast = 1;\n\t\t\t\t\tpoly.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tX: poly[0].X,\n\t\t\t\t\t\tY: poly[0].Y\n\t\t\t\t\t});\n\t\t\t\t\tplen = poly.length;\n\t\t\t\t}\n\t\t\t\telse addlast = 0;\n\t\t\t\trem = []; // Indexes of removed points\n\t\t\t\tfor (j = 0; j < plen - 2; j++)\n\t\t\t\t{\n\t\t\t\t\tA = poly[j]; // Start point of line segment\n\t\t\t\t\tP = poly[j + 1]; // Middle point. This is the one to be removed.\n\t\t\t\t\tB = poly[j + 2]; // End point of line segment\n\t\t\t\t\tax = A.X;\n\t\t\t\t\tay = A.Y;\n\t\t\t\t\tbxax = B.X - ax;\n\t\t\t\t\tbyay = B.Y - ay;\n\t\t\t\t\tif (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t\t\t\t\t{\n\t\t\t\t\t\tl = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t\t\t\t\t\tif (l > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tax = B.X;\n\t\t\t\t\t\t\tay = B.Y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (l > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tax += bxax * l;\n\t\t\t\t\t\t\tay += byay * l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbxax = P.X - ax;\n\t\t\t\t\tbyay = P.Y - ay;\n\t\t\t\t\td = bxax * bxax + byay * byay;\n\t\t\t\t\tif (d <= toleranceSq)\n\t\t\t\t\t{\n\t\t\t\t\t\trem[j + 1] = 1;\n\t\t\t\t\t\tj++; // when removed, transfer the pointer to the next one\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// add all unremoved points to poly2\n\t\t\t\tpoly2.push(\n\t\t\t\t{\n\t\t\t\t\tX: poly[0].X,\n\t\t\t\t\tY: poly[0].Y\n\t\t\t\t});\n\t\t\t\tfor (j = 1; j < plen - 1; j++)\n\t\t\t\t\tif (!rem[j]) poly2.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tX: poly[j].X,\n\t\t\t\t\t\tY: poly[j].Y\n\t\t\t\t\t});\n\t\t\t\tpoly2.push(\n\t\t\t\t{\n\t\t\t\t\tX: poly[plen - 1].X,\n\t\t\t\t\tY: poly[plen - 1].Y\n\t\t\t\t});\n\t\t\t\t// if the first point was added to the end, remove it\n\t\t\t\tif (addlast) poly.pop();\n\t\t\t\t// break, if there was not anymore removed points\n\t\t\t\tif (!rem.length) break;\n\t\t\t\t// else continue looping using poly2, to check if there are points to remove\n\t\t\t\telse poly = poly2;\n\t\t\t}\n\t\t\tplen = poly2.length;\n\t\t\t// remove duplicate from end, if needed\n\t\t\tif (poly2[plen - 1].X === poly2[0].X && poly2[plen - 1].Y === poly2[0].Y)\n\t\t\t{\n\t\t\t\tpoly2.pop();\n\t\t\t}\n\t\t\tif (poly2.length > 2) // to avoid two-point-polygons\n\t\t\t\tresults.push(poly2);\n\t\t}\n\t\tif (!isPolygons)\n\t\t{\n\t\t\tresults = results[0];\n\t\t}\n\t\tif (typeof (results) === \"undefined\")\n\t\t{\n\t\t\tresults = [];\n\t\t}\n\t\treturn results;\n\t}\n\n\tClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t{\n\t\tif (typeof (path) === \"undefined\") return 0;\n\t\tvar sqrt = Math.sqrt;\n\t\tvar perimeter = 0.0;\n\t\tvar p1, p2, p1x = 0.0,\n\t\t\tp1y = 0.0,\n\t\t\tp2x = 0.0,\n\t\t\tp2y = 0.0;\n\t\tvar j = path.length;\n\t\tif (j < 2) return 0;\n\t\tif (closed)\n\t\t{\n\t\t\tpath[j] = path[0];\n\t\t\tj++;\n\t\t}\n\t\twhile (--j)\n\t\t{\n\t\t\tp1 = path[j];\n\t\t\tp1x = p1.X;\n\t\t\tp1y = p1.Y;\n\t\t\tp2 = path[j - 1];\n\t\t\tp2x = p2.X;\n\t\t\tp2y = p2.Y;\n\t\t\tperimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t\t}\n\t\tif (closed) path.pop();\n\t\treturn perimeter / scale;\n\t};\n\n\tClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t{\n\t\tif (!scale) scale = 1;\n\t\tvar perimeter = 0;\n\t\tfor (var i = 0; i < paths.length; i++)\n\t\t{\n\t\t\tperimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t\t}\n\t\treturn perimeter;\n\t};\n\n\tClipperLib.JS.ScaleDownPath = function (path, scale)\n\t{\n\t\tvar i, p;\n\t\tif (!scale) scale = 1;\n\t\ti = path.length;\n\t\twhile (i--)\n\t\t{\n\t\t\tp = path[i];\n\t\t\tp.X = p.X / scale;\n\t\t\tp.Y = p.Y / scale;\n\t\t}\n\t};\n\n\tClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t{\n\t\tvar i, j, p;\n\t\tif (!scale) scale = 1;\n\t\ti = paths.length;\n\t\twhile (i--)\n\t\t{\n\t\t\tj = paths[i].length;\n\t\t\twhile (j--)\n\t\t\t{\n\t\t\t\tp = paths[i][j];\n\t\t\t\tp.X = p.X / scale;\n\t\t\t\tp.Y = p.Y / scale;\n\t\t\t}\n\t\t}\n\t};\n\n\tClipperLib.JS.ScaleUpPath = function (path, scale)\n\t{\n\t\tvar i, p, round = Math.round;\n\t\tif (!scale) scale = 1;\n\t\ti = path.length;\n\t\twhile (i--)\n\t\t{\n\t\t\tp = path[i];\n\t\t\tp.X = round(p.X * scale);\n\t\t\tp.Y = round(p.Y * scale);\n\t\t}\n\t};\n\n\tClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t{\n\t\tvar i, j, p, round = Math.round;\n\t\tif (!scale) scale = 1;\n\t\ti = paths.length;\n\t\twhile (i--)\n\t\t{\n\t\t\tj = paths[i].length;\n\t\t\twhile (j--)\n\t\t\t{\n\t\t\t\tp = paths[i][j];\n\t\t\t\tp.X = round(p.X * scale);\n\t\t\t\tp.Y = round(p.Y * scale);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ExPolygons = function ()\n\t{\n\t\treturn [];\n\t}\n\t/**\n\t* @constructor\n\t*/\n\tClipperLib.ExPolygon = function ()\n\t{\n\t\tthis.outer = null;\n\t\tthis.holes = null;\n\t};\n\n\tClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t{\n\t\tvar ep = new ClipperLib.ExPolygon();\n\t\tep.outer = polynode.Contour();\n\t\tvar childs = polynode.Childs();\n\t\tvar ilen = childs.length;\n\t\tep.holes = new Array(ilen);\n\t\tvar node, n, i, j, childs2, jlen;\n\t\tfor (i = 0; i < ilen; i++)\n\t\t{\n\t\t\tnode = childs[i];\n\t\t\tep.holes[i] = node.Contour();\n\t\t\t//Add outer polygons contained by (nested within) holes ...\n\t\t\tfor (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t\t\t{\n\t\t\t\tn = childs2[j];\n\t\t\t\tClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t\t\t}\n\t\t}\n\t\texpolygons.push(ep);\n\t};\n\n\tClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t{\n\t\tvar a, i, alen, ilen;\n\t\tvar paths = new ClipperLib.Paths();\n\t\tfor (a = 0, alen = expolygons.length; a < alen; a++)\n\t\t{\n\t\t\tpaths.push(expolygons[a].outer);\n\t\t\tfor (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t\t\t{\n\t\t\t\tpaths.push(expolygons[a].holes[i]);\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\tClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t{\n\t\tvar expolygons = new ClipperLib.ExPolygons();\n\t\tvar node, i, childs, ilen;\n\t\tfor (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t\t{\n\t\t\tnode = childs[i];\n\t\t\tClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t\t}\n\t\treturn expolygons;\n\t};\n\n})();\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./node_modules/clipper-lib/clipper.js?");

/***/ }),

/***/ "./examples/wfc/js/mainRigidBody.js":
/*!******************************************!*\
  !*** ./examples/wfc/js/mainRigidBody.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../js/2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\n\nlet engine = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameEngine({\n    width: 30,\n    height: 20,\n    verticalPixels: 12,\n    canvas: document.querySelector('canvas'),\n})\n\n// engine.timeScale = .1\n\n;(0,_js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.fullScreen)(engine)\n\nlet scene = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameScene()\n\nscene.add()\n\nengine.setScene(scene)\nengine.start()\n\nscene.camera = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Camera()\nglobalThis.engine = engine\n\n\nlet solver = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Solver()\n\nscene.add(solver)\n\n_js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Spring.stiffness = 100\n_js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Spring.damping = 1\n\n\nlet g0 = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(-5, -2))\nlet g1 = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(-5, -5))\nlet g2 = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(0, -5))\nlet g3 = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(5, -5))\nlet g4 = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(5, -2))\nlet g5 = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(0, -2))\n\nlet frame = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Frame([g0, g1, g2, g3, g4], true, 100, 20, 0, 1)\n\nconsole.log(frame.springs.map(e => [e.stiffness, e.damping]))\n\nlet triangle = new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Frame([new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 6.5)), new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(-2, 3)), new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Point(new _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(2, 3))], false, 50, 5)\n\n// let t0 = new SoftBody.Point(new Vector(0, 6.5))\n// let t1 = new SoftBody.Point(new Vector(-2, 3))\n// let t2 = new SoftBody.Point(new Vector(2, 3))\n\n// let triangle = new SoftBody.Shape([t0, t1, t2])\n\n// let ts0 = new SoftBody.Spring(t0, t1, 500, 10)\n// let ts1 = new SoftBody.Spring(t1, t2, 500, 10)\n// let ts2 = new SoftBody.Spring(t2, t0, 500, 10)\n\nsolver.addConstraint(frame, triangle)\n\nsolver.addIntegrableBody(frame, triangle)\n\nsolver.addCollidableBody(frame, triangle)\n\nscene.update = (dt) => {\n\n    for (let integrable of solver.integrableBodies) {\n        for (let point of integrable.getPoints()) {\n\n            point.acceleration.set(0, 0)\n\n        }\n        for (let point of integrable.getPoints()) {\n\n            point.acceleration.set(0, -10)\n\n        }\n\n\n    }\n    let input = scene.engine.input\n\n    if (input.isDown('Space')) {\n\n        triangle.points[1].velocity.set(1, 2)\n\n    }\n\n    if (dt > 1 / 30) console.log(dt)\n\n}\n\nscene.add(triangle)\n\nscene.draw = (ctx) => {\n\n    // for (let index = 0; index < frame.structure.length; index++) {\n\n    //     ctx.strokeStyle = 'gray'\n    //     ctx.lineWidth = .15\n\n    //     let p0 = frame.structure[index]\n    //     let p1 = frame.structure[(index + 1) % frame.structure.length]\n\n    //     ctx.beginPath()\n    //     ctx.moveTo(...p0.position.arrayXY())\n    //     ctx.lineTo(...p1.position.arrayXY())\n    //     ctx.stroke()\n\n    // }\n\n    ctx.strokeStyle = 'yellow'\n    ctx.lineWidth = .1\n    for (let constraint of solver.constraints) {\n        if (constraint instanceof _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Spring) {\n\n            ctx.beginPath()\n            ctx.moveTo(...constraint.point_0.position.arrayXY())\n            ctx.lineTo(...constraint.point_1.position.arrayXY())\n            ctx.stroke()\n\n        }\n\n        if (constraint instanceof _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Frame) {\n\n            for (let spring of constraint.springs) {\n\n                ctx.beginPath()\n                ctx.moveTo(...spring.point_0.position.arrayXY())\n                ctx.lineTo(...spring.point_1.position.arrayXY())\n                ctx.stroke()\n\n            }\n\n        }\n\n    }\n\n    for (let integrable of solver.integrableBodies)\n        for (let point of integrable.getPoints()) {\n            ctx.fillStyle = 'blue'\n\n            ctx.strokeStyle = 'blue'\n\n\n            ctx.beginPath()\n            ctx.arc(point.position.x, point.position.y, .11, 0, Math.PI * 2)\n            ctx.fill()\n\n            ctx.beginPath()\n            ctx.moveTo(...point.position.arrayXY())\n            ctx.lineTo(...point.position.clone().add(point.velocity).arrayXY())\n            ctx.stroke()\n\n\n        }\n\n    ctx.strokeStyle = 'red'\n    for (let integrable of solver.integrableBodies)\n\n        if (integrable instanceof _js_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.SoftBody.Shape) {\n\n            let pts = integrable.getPoints()\n\n            for (let i = 0; i < pts.length; i++) {\n\n                let p0 = pts[i]\n                let p1 = pts[(i + 1) % pts.length]\n\n                ctx.beginPath()\n                ctx.moveTo(...p0.position.arrayXY())\n                ctx.lineTo(...p1.position.arrayXY())\n                ctx.stroke()\n\n            }\n\n        }\n\n\n\n}\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./examples/wfc/js/mainRigidBody.js?");

/***/ }),

/***/ "./js/2DGameEngine.js":
/*!****************************!*\
  !*** ./js/2DGameEngine.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* reexport safe */ _gui_Button_js__WEBPACK_IMPORTED_MODULE_20__.Button),\n/* harmony export */   CANVAS_RESOLUTION: () => (/* reexport safe */ _images_ImageManipulator_js__WEBPACK_IMPORTED_MODULE_30__.CANVAS_RESOLUTION),\n/* harmony export */   Camera: () => (/* reexport safe */ _camera_Camera_js__WEBPACK_IMPORTED_MODULE_5__.Camera),\n/* harmony export */   CameraDragComponent: () => (/* reexport safe */ _components_CameraDragComponent_js__WEBPACK_IMPORTED_MODULE_7__.CameraDragComponent),\n/* harmony export */   CatmullRomSpline: () => (/* reexport safe */ _geometry_CatmullRomSpline_js__WEBPACK_IMPORTED_MODULE_10__.CatmullRomSpline),\n/* harmony export */   CheckBox: () => (/* reexport safe */ _gui_Checkbox_js__WEBPACK_IMPORTED_MODULE_21__.CheckBox),\n/* harmony export */   Color: () => (/* reexport safe */ _math_Color_js__WEBPACK_IMPORTED_MODULE_34__.Color),\n/* harmony export */   ColorFormat: () => (/* reexport safe */ _math_Color_js__WEBPACK_IMPORTED_MODULE_34__.ColorFormat),\n/* harmony export */   ColorPicker: () => (/* reexport safe */ _gui_ColorPicker_js__WEBPACK_IMPORTED_MODULE_22__.ColorPicker),\n/* harmony export */   CubicBezier: () => (/* reexport safe */ _geometry_CubicBezier_js__WEBPACK_IMPORTED_MODULE_11__.CubicBezier),\n/* harmony export */   CubicBezierSpline: () => (/* reexport safe */ _geometry_CubicBezierSpline_js__WEBPACK_IMPORTED_MODULE_12__.CubicBezierSpline),\n/* harmony export */   Drawable: () => (/* reexport safe */ _images_Drawable_js__WEBPACK_IMPORTED_MODULE_29__.Drawable),\n/* harmony export */   FPSCounter: () => (/* reexport safe */ _gui_FPSCounter_js__WEBPACK_IMPORTED_MODULE_23__.FPSCounter),\n/* harmony export */   GameComponent: () => (/* reexport safe */ _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameComponent),\n/* harmony export */   GameEngine: () => (/* reexport safe */ _basics_GameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameEngine),\n/* harmony export */   GameObject: () => (/* reexport safe */ _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject),\n/* harmony export */   GameScene: () => (/* reexport safe */ _basics_GameScene_js__WEBPACK_IMPORTED_MODULE_2__.GameScene),\n/* harmony export */   GamepadControl: () => (/* reexport safe */ _basics_Input_js__WEBPACK_IMPORTED_MODULE_3__.GamepadControl),\n/* harmony export */   GamepadDisplay: () => (/* reexport safe */ _gui_GamepadDisplay_js__WEBPACK_IMPORTED_MODULE_24__.GamepadDisplay),\n/* harmony export */   Graph: () => (/* reexport safe */ _math_Graph_js__WEBPACK_IMPORTED_MODULE_35__.Graph),\n/* harmony export */   HermiteSpline: () => (/* reexport safe */ _geometry_HermiteSpline_js__WEBPACK_IMPORTED_MODULE_13__.HermiteSpline),\n/* harmony export */   HexOrientation: () => (/* reexport safe */ _math_HexVector_js__WEBPACK_IMPORTED_MODULE_36__.HexOrientation),\n/* harmony export */   HexVector: () => (/* reexport safe */ _math_HexVector_js__WEBPACK_IMPORTED_MODULE_36__.HexVector),\n/* harmony export */   Hexagon: () => (/* reexport safe */ _geometry_Hexagon_js__WEBPACK_IMPORTED_MODULE_14__.Hexagon),\n/* harmony export */   ImageManipulator: () => (/* reexport safe */ _images_ImageManipulator_js__WEBPACK_IMPORTED_MODULE_30__.ImageManipulator),\n/* harmony export */   Input: () => (/* reexport safe */ _basics_Input_js__WEBPACK_IMPORTED_MODULE_3__.Input),\n/* harmony export */   Label: () => (/* reexport safe */ _gui_Label_js__WEBPACK_IMPORTED_MODULE_25__.Label),\n/* harmony export */   LargeImageManipulator: () => (/* reexport safe */ _images_ImageManipulator_js__WEBPACK_IMPORTED_MODULE_30__.LargeImageManipulator),\n/* harmony export */   MouseCursor: () => (/* reexport safe */ _gui_MouseCursor_js__WEBPACK_IMPORTED_MODULE_26__.MouseCursor),\n/* harmony export */   Node: () => (/* reexport safe */ _math_Graph_js__WEBPACK_IMPORTED_MODULE_35__.Node),\n/* harmony export */   Path: () => (/* reexport safe */ _math_Graph_js__WEBPACK_IMPORTED_MODULE_35__.Path),\n/* harmony export */   PerlinNoise: () => (/* reexport safe */ _math_Random_js__WEBPACK_IMPORTED_MODULE_38__.PerlinNoise),\n/* harmony export */   Polygon: () => (/* reexport safe */ _geometry_Polygon_js__WEBPACK_IMPORTED_MODULE_15__.Polygon),\n/* harmony export */   PositionIntegrator: () => (/* reexport safe */ _math_PositionIntegrator_js__WEBPACK_IMPORTED_MODULE_37__.PositionIntegrator),\n/* harmony export */   PseudoRandom: () => (/* reexport safe */ _math_Random_js__WEBPACK_IMPORTED_MODULE_38__.PseudoRandom),\n/* harmony export */   Ray: () => (/* reexport safe */ _geometry_Ray_js__WEBPACK_IMPORTED_MODULE_16__.Ray),\n/* harmony export */   RayCastView: () => (/* reexport safe */ _geometry_RayCastView_js__WEBPACK_IMPORTED_MODULE_17__.RayCastView),\n/* harmony export */   Rectangle: () => (/* reexport safe */ _geometry_Rectangle_js__WEBPACK_IMPORTED_MODULE_18__.Rectangle),\n/* harmony export */   RenderingType: () => (/* reexport safe */ _basics_GameScene_js__WEBPACK_IMPORTED_MODULE_2__.RenderingType),\n/* harmony export */   RigitBodyComponent: () => (/* reexport safe */ _components_RigidBodyComponent_js__WEBPACK_IMPORTED_MODULE_8__.RigitBodyComponent),\n/* harmony export */   SVGStringToImage: () => (/* reexport safe */ _images_Utils_js__WEBPACK_IMPORTED_MODULE_33__.SVGStringToImage),\n/* harmony export */   Segment: () => (/* reexport safe */ _geometry_Segment_js__WEBPACK_IMPORTED_MODULE_19__.Segment),\n/* harmony export */   SoftBody: () => (/* reexport safe */ _physics_SoftBody_js__WEBPACK_IMPORTED_MODULE_46__.SoftBody),\n/* harmony export */   Sound: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.Sound),\n/* harmony export */   SpriteSheet: () => (/* reexport safe */ _images_SpriteSheet_js__WEBPACK_IMPORTED_MODULE_31__.SpriteSheet),\n/* harmony export */   StateMachine: () => (/* reexport safe */ _components_StateMachine_js__WEBPACK_IMPORTED_MODULE_9__.StateMachine),\n/* harmony export */   TextBox: () => (/* reexport safe */ _gui_TextBox_js__WEBPACK_IMPORTED_MODULE_27__.TextBox),\n/* harmony export */   TextureMapper: () => (/* reexport safe */ _images_TextureMapper_js__WEBPACK_IMPORTED_MODULE_32__.TextureMapper),\n/* harmony export */   Timer: () => (/* reexport safe */ _math_Timer_js__WEBPACK_IMPORTED_MODULE_39__.Timer),\n/* harmony export */   TrackingCamera: () => (/* reexport safe */ _camera_TrackingCamera_js__WEBPACK_IMPORTED_MODULE_6__.TrackingCamera),\n/* harmony export */   TrackingCameraDisableMode: () => (/* reexport safe */ _camera_TrackingCamera_js__WEBPACK_IMPORTED_MODULE_6__.TrackingCameraDisableMode),\n/* harmony export */   Transform: () => (/* reexport safe */ _math_Transform_js__WEBPACK_IMPORTED_MODULE_40__.Transform),\n/* harmony export */   TransformMatrix: () => (/* reexport safe */ _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_41__.TransformMatrix),\n/* harmony export */   ValueToggle: () => (/* reexport safe */ _math_ValueToggle_js__WEBPACK_IMPORTED_MODULE_43__.ValueToggle),\n/* harmony export */   Vector: () => (/* reexport safe */ _math_Vector_js__WEBPACK_IMPORTED_MODULE_44__.Vector),\n/* harmony export */   WFC: () => (/* reexport safe */ _math_WaveFunctionCollapse_js__WEBPACK_IMPORTED_MODULE_45__.WFC),\n/* harmony export */   WaveFunctionCollapse: () => (/* reexport safe */ _math_WaveFunctionCollapse_js__WEBPACK_IMPORTED_MODULE_45__.WaveFunctionCollapse),\n/* harmony export */   badclone: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.badclone),\n/* harmony export */   coserp: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.coserp),\n/* harmony export */   cubicBezier: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.cubicBezier),\n/* harmony export */   drawText: () => (/* reexport safe */ _gui_Utils_js__WEBPACK_IMPORTED_MODULE_28__.drawText),\n/* harmony export */   dummy: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.dummy),\n/* harmony export */   fillCanvasParent: () => (/* reexport safe */ _basics_GameEngine_js__WEBPACK_IMPORTED_MODULE_0__.fillCanvasParent),\n/* harmony export */   fullScreen: () => (/* reexport safe */ _basics_GameEngine_js__WEBPACK_IMPORTED_MODULE_0__.fullScreen),\n/* harmony export */   getCircularReplacer: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.getCircularReplacer),\n/* harmony export */   id: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.id),\n/* harmony export */   invLerp: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.invLerp),\n/* harmony export */   invLerpArray: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.invLerpArray),\n/* harmony export */   lerp: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.lerp),\n/* harmony export */   lerpArray: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.lerpArray),\n/* harmony export */   loadDataUrl: () => (/* reexport safe */ _images_Utils_js__WEBPACK_IMPORTED_MODULE_33__.loadDataUrl),\n/* harmony export */   loadImages: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.loadImages),\n/* harmony export */   loadSVGs: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.loadSVGs),\n/* harmony export */   loadSounds: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.loadSounds),\n/* harmony export */   map: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.map),\n/* harmony export */   minmax: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.minmax),\n/* harmony export */   quadBezier: () => (/* reexport safe */ _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__.quadBezier),\n/* harmony export */   range: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.range),\n/* harmony export */   resolveColorable: () => (/* reexport safe */ _math_Color_js__WEBPACK_IMPORTED_MODULE_34__.resolveColorable),\n/* harmony export */   resolveStringable: () => (/* reexport safe */ _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__.resolveStringable)\n/* harmony export */ });\n/* harmony import */ var _basics_GameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basics/GameEngine.js */ \"./js/basics/GameEngine.js\");\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _basics_GameScene_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basics/GameScene.js */ \"./js/basics/GameScene.js\");\n/* harmony import */ var _basics_Input_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basics/Input.js */ \"./js/basics/Input.js\");\n/* harmony import */ var _basics_Utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./basics/Utils.js */ \"./js/basics/Utils.js\");\n/* harmony import */ var _camera_Camera_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./camera/Camera.js */ \"./js/camera/Camera.js\");\n/* harmony import */ var _camera_TrackingCamera_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./camera/TrackingCamera.js */ \"./js/camera/TrackingCamera.js\");\n/* harmony import */ var _components_CameraDragComponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/CameraDragComponent.js */ \"./js/components/CameraDragComponent.js\");\n/* harmony import */ var _components_RigidBodyComponent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/RigidBodyComponent.js */ \"./js/components/RigidBodyComponent.js\");\n/* harmony import */ var _components_StateMachine_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/StateMachine.js */ \"./js/components/StateMachine.js\");\n/* harmony import */ var _geometry_CatmullRomSpline_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./geometry/CatmullRomSpline.js */ \"./js/geometry/CatmullRomSpline.js\");\n/* harmony import */ var _geometry_CubicBezier_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./geometry/CubicBezier.js */ \"./js/geometry/CubicBezier.js\");\n/* harmony import */ var _geometry_CubicBezierSpline_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./geometry/CubicBezierSpline.js */ \"./js/geometry/CubicBezierSpline.js\");\n/* harmony import */ var _geometry_HermiteSpline_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./geometry/HermiteSpline.js */ \"./js/geometry/HermiteSpline.js\");\n/* harmony import */ var _geometry_Hexagon_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./geometry/Hexagon.js */ \"./js/geometry/Hexagon.js\");\n/* harmony import */ var _geometry_Polygon_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./geometry/Polygon.js */ \"./js/geometry/Polygon.js\");\n/* harmony import */ var _geometry_Ray_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./geometry/Ray.js */ \"./js/geometry/Ray.js\");\n/* harmony import */ var _geometry_RayCastView_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./geometry/RayCastView.js */ \"./js/geometry/RayCastView.js\");\n/* harmony import */ var _geometry_Rectangle_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./geometry/Rectangle.js */ \"./js/geometry/Rectangle.js\");\n/* harmony import */ var _geometry_Segment_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./geometry/Segment.js */ \"./js/geometry/Segment.js\");\n/* harmony import */ var _gui_Button_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./gui/Button.js */ \"./js/gui/Button.js\");\n/* harmony import */ var _gui_Checkbox_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./gui/Checkbox.js */ \"./js/gui/Checkbox.js\");\n/* harmony import */ var _gui_ColorPicker_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./gui/ColorPicker.js */ \"./js/gui/ColorPicker.js\");\n/* harmony import */ var _gui_FPSCounter_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./gui/FPSCounter.js */ \"./js/gui/FPSCounter.js\");\n/* harmony import */ var _gui_GamepadDisplay_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./gui/GamepadDisplay.js */ \"./js/gui/GamepadDisplay.js\");\n/* harmony import */ var _gui_Label_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./gui/Label.js */ \"./js/gui/Label.js\");\n/* harmony import */ var _gui_MouseCursor_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./gui/MouseCursor.js */ \"./js/gui/MouseCursor.js\");\n/* harmony import */ var _gui_TextBox_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./gui/TextBox.js */ \"./js/gui/TextBox.js\");\n/* harmony import */ var _gui_Utils_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./gui/Utils.js */ \"./js/gui/Utils.js\");\n/* harmony import */ var _images_Drawable_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./images/Drawable.js */ \"./js/images/Drawable.js\");\n/* harmony import */ var _images_ImageManipulator_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./images/ImageManipulator.js */ \"./js/images/ImageManipulator.js\");\n/* harmony import */ var _images_SpriteSheet_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./images/SpriteSheet.js */ \"./js/images/SpriteSheet.js\");\n/* harmony import */ var _images_TextureMapper_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./images/TextureMapper.js */ \"./js/images/TextureMapper.js\");\n/* harmony import */ var _images_Utils_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./images/Utils.js */ \"./js/images/Utils.js\");\n/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./math/Color.js */ \"./js/math/Color.js\");\n/* harmony import */ var _math_Graph_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./math/Graph.js */ \"./js/math/Graph.js\");\n/* harmony import */ var _math_HexVector_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./math/HexVector.js */ \"./js/math/HexVector.js\");\n/* harmony import */ var _math_PositionIntegrator_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./math/PositionIntegrator.js */ \"./js/math/PositionIntegrator.js\");\n/* harmony import */ var _math_Random_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./math/Random.js */ \"./js/math/Random.js\");\n/* harmony import */ var _math_Timer_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./math/Timer.js */ \"./js/math/Timer.js\");\n/* harmony import */ var _math_Transform_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./math/Transform.js */ \"./js/math/Transform.js\");\n/* harmony import */ var _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./math/TransformMatrix.js */ \"./js/math/TransformMatrix.js\");\n/* harmony import */ var _math_Utils_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./math/Utils.js */ \"./js/math/Utils.js\");\n/* harmony import */ var _math_ValueToggle_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./math/ValueToggle.js */ \"./js/math/ValueToggle.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _math_WaveFunctionCollapse_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./math/WaveFunctionCollapse.js */ \"./js/math/WaveFunctionCollapse.js\");\n/* harmony import */ var _physics_SoftBody_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./physics/SoftBody.js */ \"./js/physics/SoftBody.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/2DGameEngine.js?");

/***/ }),

/***/ "./js/basics/GameEngine.js":
/*!*********************************!*\
  !*** ./js/basics/GameEngine.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameEngine: () => (/* binding */ GameEngine),\n/* harmony export */   fillCanvasParent: () => (/* binding */ fillCanvasParent),\n/* harmony export */   fullScreen: () => (/* binding */ fullScreen)\n/* harmony export */ });\n/* harmony import */ var _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/TransformMatrix.js */ \"./js/math/TransformMatrix.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _Input_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Input.js */ \"./js/basics/Input.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils.js */ \"./js/basics/Utils.js\");\n\n\n\n\nconst gameEngineConstructorArguments = {\n    width: innerWidth,\n    height: innerHeight,\n    verticalPixels: 100,\n    scaling: devicePixelRatio,\n    canvas: null,\n    images: [],\n    svgs: [],\n    sounds: []\n};\n/**\n * GameEngine is the class responsible for the execution of the game loop, the canvas and resize change, and the scene management\n */\nclass GameEngine {\n    /**\n     * The canvas on which the GameEngine will draw.\n     * Shall not be modified.\n     * Can be accessed to retrieved generated canvas if none is passed as argument.\n     */\n    canvas;\n    /**\n     * The context on which the GameEngine will draw.\n     * Shall not be modified.\n     */\n    ctx;\n    /**\n     * The input is here to query the keyboard inputs and the mouse inputs.\n     */\n    input = new _Input_js__WEBPACK_IMPORTED_MODULE_2__.Input();\n    #width = 0;\n    #height = 0;\n    #trueWidth = 0;\n    #trueHeight = 0;\n    #verticalPixels = 1;\n    #ratio = 1;\n    #scaling = 1;\n    #usableWidth = 0;\n    #usableHeight = 0;\n    #run = false;\n    #lastTime = Date.now();\n    #dt = 0;\n    #currentScene = null;\n    #nextScene = undefined;\n    timeScale = 1;\n    /**\n     * Contains all the images loaded at the engine contruction.\n     */\n    imageBank = new Map();\n    /**\n     * Contains all the svg loaded at the engine construction.\n     */\n    svgBank = new Map();\n    /**\n     * Contains all the sounds loaded at the engine construction.\n     */\n    soundBank = new Map();\n    #lock0 = true;\n    #locks = [true, true, true];\n    #loadedImagesCount = 0;\n    #imageToLoadCount = 0;\n    #loadedSVGCount = 0;\n    #svgToLoadCount = 0;\n    #loadedSoundCount = 0;\n    #soundToLoadCount = 0;\n    #ressourcesLoadedCallbacks = [];\n    #resume = false;\n    /**\n     * Create a new game engine using the given argument list, filling the gap with default value\n     *\n     * @param {width: number, height: number, verticalPixels: number, scaling: number, images: Image[]} args\n     */\n    constructor(args = gameEngineConstructorArguments) {\n        args = { ...gameEngineConstructorArguments, ...args };\n        this.canvas = args.canvas ?? document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d');\n        this.input.bindMouse(this.canvas, (vector) => {\n            let sc = this.usableScale;\n            let half = this.usableScale.clone().divS(2);\n            vector.mult(sc).sub(half);\n            vector.y *= -1;\n            if (this.#currentScene && this.#currentScene.camera) {\n                let matrix = this.#currentScene.camera.getWorldTransformMatrix();\n                vector = _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_0__.TransformMatrix.multVec(matrix, vector);\n            }\n            return vector;\n        });\n        this.canvas.style.position = 'relative';\n        this.canvas.style.backgroundColor = 'black';\n        this.resize(args.width, args.height, args.scaling ?? devicePixelRatio, args.verticalPixels);\n        this.#imageToLoadCount = args.images.length;\n        this.#svgToLoadCount = args.svgs.length;\n        this.#soundToLoadCount = args.sounds.map(e => e.srcs.length).reduce((a, b) => a + b, 0);\n        this.imageBank = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_3__.loadImages)(args.images ?? [], (n) => { this.#loadedImagesCount = n; }, () => {\n            this.#locks[0] = false;\n            this.#checkLocks();\n        });\n        this.soundBank = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_3__.loadSounds)(args.sounds ?? [], (n) => { this.#loadedSoundCount = n; }, () => {\n            this.#locks[1] = false;\n            this.#checkLocks();\n        });\n        this.svgBank = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_3__.loadSVGs)(args.svgs ?? [], (n) => { this.#loadedSVGCount = n; }, () => {\n            this.#locks[2] = false;\n            this.#checkLocks();\n        });\n        document.addEventListener('visibilitychange', () => {\n            if (document.visibilityState === 'hidden') {\n                if (this.#run) {\n                    this.#resume = true;\n                    this.stop();\n                }\n                else\n                    this.#resume = false;\n            }\n            else {\n                if (this.#resume) {\n                    this.#resume = false;\n                    this.#lastTime = Date.now();\n                    this.start();\n                }\n            }\n        });\n    }\n    get trueWidth() { return this.#trueWidth; }\n    get trueHeight() { return this.#trueHeight; }\n    get usableWidth() { return this.#usableWidth; }\n    get usableHeight() { return this.#usableHeight; }\n    get usableScale() { return new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(this.usableWidth, this.usableHeight); }\n    get verticalPixels() { return this.#verticalPixels; }\n    get dt() { return this.#dt; }\n    get scene() { return this.#currentScene; }\n    #checkLocks() {\n        if (this.#locks.every(lock => lock === false)) {\n            this.#lock0 = false;\n            this.#ressourcesLoadedCallbacks.forEach(func => func.call(this));\n        }\n    }\n    /**\n     * update the size of both canvas\n     * if a scene is curently used, update it's camera\n     *\n     * @param {number} width\n     * @param {number} height\n     */\n    resize(width, height, scaling = this.#scaling, pixels = this.#verticalPixels) {\n        this.#width = width;\n        this.#height = height;\n        this.#scaling = scaling;\n        this.#trueWidth = width * scaling;\n        this.#trueHeight = height * scaling;\n        this.canvas.width = width * scaling;\n        this.canvas.height = height * scaling;\n        this.canvas.style.width = width + 'px';\n        this.canvas.style.height = height + 'px';\n        this.setVerticalPixels(pixels);\n        if (this.#currentScene) {\n            this.#currentScene.onResize(width, height);\n        }\n    }\n    /**\n     * Set the number vertical virtual pixel.\n     * i.e. if a 1x1 square is drawn, it will take 1/pixels the space\n     *\n     * @param {number} pixels\n     */\n    setVerticalPixels(pixels = 1) {\n        this.#verticalPixels = pixels;\n        this.#ratio = this.#trueHeight / this.#verticalPixels;\n        this.#usableHeight = this.#verticalPixels;\n        this.#usableWidth = this.#trueWidth / this.#ratio;\n    }\n    /**\n     * Set the new scene to be displayed, can be null\n     *\n     * @param {GameScene | null} scene\n     */\n    setScene(scene) {\n        this.#nextScene = scene;\n    }\n    /**\n     * Effectively switch the scene to be displayed\n     * Is called at then end of the gameloop\n     */\n    #switchScene() {\n        if (this.#nextScene !== undefined) {\n            if (this.#currentScene) {\n                this.#currentScene.onUnSet();\n                this.#currentScene.engine = null;\n            }\n            this.#currentScene = this.#nextScene;\n            this.#nextScene = undefined;\n            this.resize(this.#width, this.#height, this.#scaling);\n            if (this.#currentScene) {\n                this.#currentScene.engine = this;\n                this.#currentScene.onSet();\n            }\n        }\n    }\n    /**\n     * Start the engine, running the gameloop\n     */\n    start() {\n        this.#run = true;\n        this.#loop();\n    }\n    /**\n     * Stop the engine, stopping the gameloop\n     */\n    stop() {\n        this.#run = false;\n    }\n    /**\n     * Execute the gameloop\n     *\n     * update -> draw -> repeat\n     *\n     * inputs are obtained using javascript event catcher\n     *\n     */\n    #loop() {\n        if (!this.#run)\n            return;\n        if (this.#lock0) {\n            let value = this.#loadedImagesCount + this.#loadedSVGCount + this.#loadedSoundCount;\n            let tot = this.#imageToLoadCount + this.#svgToLoadCount + this.#soundToLoadCount;\n            this.ctx.clearRect(0, 0, this.#trueWidth, this.trueHeight);\n            this.ctx.save();\n            this.ctx.fillStyle = 'red';\n            this.ctx.fillRect(0.1 * this.trueWidth, 0.45 * this.trueHeight, 0.8 * this.trueWidth * (value / tot), 0.1 * this.trueHeight);\n            this.ctx.restore();\n            requestAnimationFrame(this.#loop.bind(this));\n            return;\n        }\n        let time = Date.now();\n        this.#dt = (time - this.#lastTime) / 1000;\n        this.#lastTime = time;\n        this.#dt = Math.min(this.#dt, 0.05) * this.timeScale;\n        this.ctx.clearRect(0, 0, this.#trueWidth, this.trueHeight);\n        this.ctx.save();\n        this.ctx.translate(this.trueWidth / 2, this.trueHeight / 2);\n        this.ctx.scale(this.#ratio, -this.#ratio);\n        if (this.#currentScene) {\n            this.#currentScene.executeUpdate(this.#dt);\n            this.#currentScene.executePhysics(this.#dt);\n            this.#currentScene.executeDraw(this.ctx);\n        }\n        this.ctx.restore();\n        this.input.mouseLoop();\n        this.input.gamepadLoop();\n        this.#switchScene();\n        requestAnimationFrame(this.#loop.bind(this));\n    }\n    onResourcesLoaded(callback) {\n        if (this.#lock0) {\n            this.#ressourcesLoadedCallbacks.push(callback);\n        }\n        else\n            callback.call(this);\n    }\n}\nfunction fullScreen(engine) {\n    let verticalPixels = engine.verticalPixels;\n    const handler = () => {\n        if (innerHeight < innerWidth)\n            engine.resize(innerWidth, innerHeight, devicePixelRatio, verticalPixels);\n        else {\n            const ratio = innerHeight / innerWidth;\n            const adaptedVerticalPixels = verticalPixels * ratio;\n            engine.resize(innerWidth, innerHeight, devicePixelRatio, adaptedVerticalPixels);\n        }\n    };\n    window.addEventListener('resize', handler);\n    handler();\n    return handler;\n}\nfunction fillCanvasParent(engine) {\n    let verticalPixels = engine.verticalPixels;\n    const handler = () => {\n        let canvas = engine.canvas;\n        let parent = canvas.parentElement;\n        let width = parent.clientWidth;\n        let height = parent.clientHeight;\n        if (document.fullscreenElement === canvas) {\n            width = innerWidth;\n            height = innerHeight;\n        }\n        if (height < width)\n            engine.resize(width, height, devicePixelRatio, verticalPixels);\n        else {\n            const ratio = height / width;\n            const adaptedVerticalPixels = verticalPixels * ratio;\n            engine.resize(width, height, devicePixelRatio, adaptedVerticalPixels);\n        }\n    };\n    window.addEventListener('resize', handler);\n    handler();\n    return handler;\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/basics/GameEngine.js?");

/***/ }),

/***/ "./js/basics/GameObject.js":
/*!*********************************!*\
  !*** ./js/basics/GameObject.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameComponent: () => (/* binding */ GameComponent),\n/* harmony export */   GameObject: () => (/* binding */ GameObject)\n/* harmony export */ });\n/* harmony import */ var _math_Transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Transform.js */ \"./js/math/Transform.js\");\n/* harmony import */ var _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/TransformMatrix.js */ \"./js/math/TransformMatrix.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _GameScene_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GameScene.js */ \"./js/basics/GameScene.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils.js */ \"./js/basics/Utils.js\");\n\n\n\n\n\nconst PI2 = Math.PI * 2;\n/**\n * The GameObject class is the base brick class of the system, inhert from it to create any comonent of your system\n * Use the tags to retrieve groups of it from the scene perspective, children or not.\n */\nclass GameObject {\n    id = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_4__.id)();\n    children = [];\n    tags = ['$'];\n    updateEnabled = true;\n    childrenUpdateEnabled = true;\n    physicsEnabled = true;\n    childrenPhysicsEnabled = true;\n    drawEnabled = true;\n    childrenDrawEnabled = true;\n    parent = null;\n    #scene = null;\n    #drawBeforeChild = true;\n    transform = new _math_Transform_js__WEBPACK_IMPORTED_MODULE_0__.Transform();\n    zIndex = 0;\n    drawRange = 0; // If set to infinity, will always be rendered no matter the rendering style\n    renderingType = _GameScene_js__WEBPACK_IMPORTED_MODULE_3__.RenderingType.INFINITY;\n    /**\n     * Create a new raw GameObject\n     */\n    constructor() {\n    }\n    /**\n     * If the object or any parent object is in the scene, returns it\n     */\n    get scene() { return this.#scene ?? this.parent?.scene ?? null; }\n    /**\n     * Set the scene of the object\n     * Used by GameScene\n     */\n    set scene(scene) { this.#scene = scene; }\n    /**\n     * @returns {GameEngine}\n     */\n    get engine() { return this.scene?.engine ?? null; }\n    /**\n     * @returns {Input}\n     */\n    get input() { return this.engine?.input ?? null; }\n    /**\n     * Return true if object is either in a scene or has a parent object\n     */\n    get used() { return this.scene !== null || this.parent !== null; }\n    get position() { return this.transform.translation; }\n    get rotation() { return this.transform.rotation; }\n    set rotation(rotation) { this.transform.rotation = rotation; }\n    get size() { return this.transform.scale; }\n    /**\n     * Adds one or more tag to the object\n     *\n     * @param {...string} tag\n     */\n    addTag(...tag) {\n        this.tags.push(...tag);\n    }\n    /**\n     * Removes one or more tag from the object\n     *\n     * @param {...string} tag\n     */\n    removeTag(...tag) {\n        for (let t of tag) {\n            let index = this.tags.indexOf(t);\n            if (index !== -1)\n                this.tags.splice(index, 1);\n        }\n    }\n    /**\n     * Add the given object to this object children\n     *\n     * @param {...GameObject} object\n     * @returns {this}\n     */\n    add(...object) {\n        for (let obj of object)\n            if (obj instanceof GameObject) {\n                if (obj instanceof GameComponent && obj.unique && this.getComponent(obj.componentTag))\n                    throw `Cannot add more than one unique component of type \"${obj.componentTag}\"`;\n                if (obj.used)\n                    obj.kill();\n                obj.parent = this;\n                this.children.push(obj);\n                this.scene?.addTags(obj);\n                obj.onAdd();\n            }\n        return this;\n    }\n    /**\n     * Remove the given objects from this object children\n     *\n     * @param {...GameObject} object\n     * @returns {this}\n     */\n    remove(...object) {\n        for (let obj of object)\n            if (obj instanceof GameObject) {\n                let index = this.children.indexOf(obj);\n                if (index !== -1) {\n                    this.scene?.removeTags(obj);\n                    obj.parent = null;\n                    this.children.splice(index, 1);\n                    obj.onRemove();\n                }\n            }\n        return this;\n    }\n    /**\n     * Is called when the object is added to a scene or another object\n     * Is to be modified by the user\n     * Should not be called by the user\n     */\n    onAdd() { }\n    /**\n     * Is called when the object is removed from a scene or a parent object\n     * Is to be modified by the user\n     * Should not be called by the user\n     */\n    onRemove() { }\n    getComponent(componentTag) {\n        return this.children.find(child => child.tags.includes('component') &&\n            child.tags.includes(componentTag)) ?? null;\n    }\n    getComponents(componentTag) {\n        return this.children.filter(child => child.tags.includes('component') &&\n            child.tags.includes(componentTag));\n    }\n    doIf(predicate) {\n        this.updateIf(predicate);\n        this.physicsIf(predicate);\n        this.drawIf(predicate);\n    }\n    #updatePredicate = [];\n    updateIf(predicate) {\n        this.#updatePredicate.push(predicate);\n    }\n    /**\n    * Update the object and its child.\n    * Is called by the Scene or parent objects to update this object.\n    * Should not be called by the user.\n    *\n    * @param {number} dt\n    */\n    executeUpdate(dt) {\n        if (this.#updatePredicate.length && !this.#updatePredicate.every(predicate => predicate()))\n            return;\n        if (this.updateEnabled)\n            this.update(dt);\n        if (this.childrenUpdateEnabled)\n            for (let child of [...this.children])\n                if (child instanceof GameObject)\n                    child.executeUpdate(dt);\n    }\n    #physicsPredicate = [];\n    physicsIf(predicate) {\n        this.#physicsPredicate.push(predicate);\n    }\n    executePhysics(dt) {\n        if (this.#physicsPredicate.length && !this.#physicsPredicate.every(predicate => predicate()))\n            return;\n        if (this.physicsEnabled)\n            this.physics(dt);\n        if (this.childrenPhysicsEnabled)\n            for (let child of [...this.children])\n                if (child instanceof GameObject)\n                    child.executePhysics(dt);\n    }\n    childrenDrawFilter(children) { return children; }\n    #drawPredicate = [];\n    drawIf(predicate) {\n        this.#drawPredicate.push(predicate);\n    }\n    /**\n    * Draw the object and its child.\n    * Is called by the Scene or parent objects to draw this object.\n    * Should not be called by the user.\n    *\n    * @param {number} dt\n    */\n    executeDraw(ctx, drawRange = 0, cameraPosition = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector()) {\n        if (this.#drawPredicate.length && !this.#drawPredicate.every(predicate => predicate()))\n            return;\n        ctx.save();\n        ctx.transform(...this.transform.getMatrix());\n        if (this.#drawBeforeChild && this.drawEnabled)\n            this.draw(ctx);\n        if (this.childrenDrawEnabled) {\n            let children = this.childrenDrawFilter(this.children).sort((a, b) => a.zIndex != b.zIndex ? a.zIndex - b.zIndex : b.transform.translation.y - a.transform.translation.y);\n            if (this.renderingType === _GameScene_js__WEBPACK_IMPORTED_MODULE_3__.RenderingType.INFINITY) {\n                for (let child of children)\n                    if (child instanceof GameObject)\n                        child.executeDraw(ctx, drawRange, cameraPosition);\n            }\n            else if (this.renderingType === _GameScene_js__WEBPACK_IMPORTED_MODULE_3__.RenderingType.IN_VIEW) {\n                for (let child of children) {\n                    let childPosition = child.getWorldPosition();\n                    let distance = cameraPosition.distanceTo(childPosition);\n                    let maxChildRange = distance - drawRange;\n                    if (child.drawRange >= maxChildRange && child instanceof GameObject)\n                        child.executeDraw(ctx, drawRange, cameraPosition);\n                }\n            }\n        }\n        if (!this.#drawBeforeChild && this.drawEnabled)\n            this.draw(ctx);\n        ctx.restore();\n    }\n    /**\n     * Update the object specific operation\n     *\n     * Is called when the object is updated\n     * Is to be modified by the user\n     * Should not be called by the user\n     *\n     * @param {number} dt\n     */\n    update(dt) { }\n    /**\n     * Update the physics of the object\n     *\n     * Is called when the object physics is updated\n     * Is to be modified by the user\n     * Should not be called by the user\n     *\n     * @param {number} dt\n     */\n    physics(dt) { }\n    /**\n      * Draw the object specific element\n      *\n      * Is called when the object is drawn\n      * Is to be modified by the user\n      * Should not be called by the user\n      *\n      * @param {CanvasRenderingContext2D} ctx\n      */\n    draw(ctx) { }\n    /**\n     * Remove the object from its scene/parent\n     */\n    kill() {\n        if (this.parent !== null)\n            this.parent.remove(this);\n        if (this.scene !== null)\n            this.scene.remove(this);\n    }\n    /**\n     * Postpone the drawing of the object to after its children drawing\n     */\n    drawAfterChildren() { this.#drawBeforeChild = false; }\n    /**\n     * Return the world position of this object, thus taking into account all parent object\n     *\n     * @returns {Vector}\n     */\n    getWorldPosition(defaultPosition = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector()) {\n        let currentObject = this;\n        let currentPosition = defaultPosition;\n        while (currentObject) {\n            if (!currentObject.transform.scale.equalS(1, 1))\n                currentPosition.mult(currentObject.transform.scale);\n            if (currentObject.transform.rotation)\n                currentPosition.rotate(currentObject.transform.rotation);\n            if (!currentObject.transform.translation.nil())\n                currentPosition.add(currentObject.transform.translation);\n            currentObject = currentObject.parent;\n        }\n        return currentPosition;\n    }\n    /**\n     * Return the world rotation of this object, thus taking into account all parent object\n     *\n     * @returns {number}\n     */\n    getWorldRotation() {\n        let currentObject = this;\n        let rotation = 0;\n        while (currentObject) {\n            rotation += currentObject.transform.rotation;\n            currentObject = currentObject.parent;\n        }\n        return ((rotation % PI2) + PI2) % PI2;\n    }\n    getWorldTransformMatrix() {\n        let matrix = this.transform.getMatrix();\n        let currentObject = this.parent;\n        while (currentObject) {\n            matrix = _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_1__.TransformMatrix.multMat(currentObject.transform.getMatrix(), matrix);\n            currentObject = currentObject.parent;\n        }\n        return matrix;\n    }\n}\nclass GameComponent extends GameObject {\n    unique = false;\n    componentTag;\n    constructor(componentTag) {\n        super();\n        this.addTag('component');\n        this.addTag(componentTag);\n        this.componentTag = componentTag;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/basics/GameObject.js?");

/***/ }),

/***/ "./js/basics/GameScene.js":
/*!********************************!*\
  !*** ./js/basics/GameScene.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameScene: () => (/* binding */ GameScene),\n/* harmony export */   RenderingType: () => (/* binding */ RenderingType)\n/* harmony export */ });\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameObject.js */ \"./js/basics/GameObject.js\");\n\n\nvar RenderingType;\n(function (RenderingType) {\n    RenderingType[RenderingType[\"INFINITY\"] = 0] = \"INFINITY\";\n    // static IN_VIEW = 1 // Render only the object that are in the cameraview, or at default position and range if no camera is set // Distance to camera computation for all object // Recommended when lot of object with little child depth\n    RenderingType[RenderingType[\"IN_VIEW\"] = 1] = \"IN_VIEW\"; // Render only the object for which the root object is in camera range // Distance to camera computation for root object only // Recommended when lots of object with lots of child depth\n})(RenderingType = RenderingType || (RenderingType = {}));\n/**\n * GameScene is the class responsible for all the scene related operation such as camera definition, object adding, object grouping, scene update and rendering.\n * GameScene id is not used for scene unicity but for scene sorting regarding Network.\n * If you need multiple instance of the same scene, make sure ids are different but deterministic.\n * The deteministic side is needed when working with the Network\n * It is recommended to instanciate all your scene at the beginning if possible\n */\nclass GameScene {\n    static list = new Map();\n    id = 'GameScene';\n    tags = new Map();\n    children = [];\n    camera = null;\n    engine = null;\n    parentScene = null;\n    renderingType = RenderingType.INFINITY;\n    /**\n     * Create a new empty GameScene\n     */\n    constructor(parentScene = null) {\n        this.parentScene = parentScene;\n    }\n    store() { GameScene.list.set(this.id, this); }\n    exit() {\n        if (!this.engine)\n            return;\n        this.engine.setScene(this.parentScene);\n    }\n    /**\n     * Execute the scene update when not in use by an engine.\n     * Still requires an engine as a reference point.\n     */\n    executeBlindUpdate(engine, dt) {\n        if (this.engine)\n            return;\n        this.engine = engine;\n        this.executeUpdate(dt);\n        this.engine = null;\n    }\n    /**\n     * Execute the scene physics when not in use by an engine.\n     * Still requires an engine as a reference point.\n     */\n    executeBlindPhysics(engine, dt) {\n        if (this.engine)\n            return;\n        this.engine = engine;\n        this.executePhysics(dt);\n        this.engine = null;\n    }\n    /**\n     * Update the scene and its child\n     * Is called by the GameEngine to update the scene\n     * Should not be called by the user\n     *\n     * @param {number} dt\n     */\n    executeUpdate(dt) {\n        this.update(dt);\n        for (let child of [...this.children])\n            if (child instanceof _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject)\n                child.executeUpdate(dt);\n    }\n    executePhysics(dt) {\n        this.physics(dt);\n        for (let child of [...this.children])\n            if (child instanceof _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject)\n                child.executePhysics(dt);\n    }\n    childrenDrawFilter(children) { return children; }\n    getDrawRange() {\n        let drawRange = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector(this.engine.usableWidth, this.engine.usableHeight).length() / 2;\n        if (this.camera)\n            drawRange *= this.camera.getRange();\n        return drawRange;\n    }\n    getCameraPosition() {\n        return this.camera?.getWorldPosition() ?? new _math_Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0);\n    }\n    /**\n     * Draw the scene and its children (children first)\n     * Is called by the GameEngine to draw the scene\n     * Should not be called by the user\n     *\n     * @param ctx\n     */\n    executeDraw(ctx) {\n        let drawRange = this.getDrawRange();\n        let cameraPosition = this.getCameraPosition();\n        if (this.camera) {\n            ctx.transform(...this.camera.getViewTransformMatrix());\n        }\n        this.draw(ctx);\n        let children = this.childrenDrawFilter(this.children).sort((a, b) => a.zIndex != b.zIndex ? a.zIndex - b.zIndex : b.transform.translation.y - a.transform.translation.y);\n        if (this.renderingType === RenderingType.INFINITY) {\n            for (let child of children)\n                if (child instanceof _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject)\n                    child.executeDraw(ctx, drawRange, cameraPosition);\n        }\n        else if (this.renderingType === RenderingType.IN_VIEW) {\n            for (let child of children) {\n                let childPosition = child.getWorldPosition();\n                let distance = cameraPosition.distanceTo(childPosition);\n                let maxChildRange = distance - drawRange;\n                if (child.drawRange >= maxChildRange && child instanceof _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject)\n                    child.executeDraw(ctx, drawRange, cameraPosition);\n            }\n        }\n    }\n    /**\n     * Add one or more object to the scene sorting them out by their tages, removing them from previous parent/scene if needed\n     *\n     * @param {...GameObject} object\n     * @returns {this}\n     */\n    add(...object) {\n        for (let obj of object)\n            if (obj instanceof _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject) {\n                if (obj.used)\n                    obj.kill();\n                obj.scene = this;\n                this.children.push(obj);\n                this.addTags(obj);\n                obj.onAdd();\n            }\n        return this;\n    }\n    /**\n     * Sort the given objects and their children by their tags\n     * Should not be called by the user\n     *\n     * @param {...GameObject} object\n     * @returns {this}\n     */\n    addTags(...object) {\n        for (let obj of object)\n            if (obj instanceof _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject) {\n                for (let tag of obj.tags) {\n                    if (!this.tags.has(tag))\n                        this.tags.set(tag, []);\n                    this.tags.get(tag).push(obj);\n                }\n                this.addTags(...obj.children);\n            }\n        return this;\n    }\n    /**\n     * Remove one or more from the scene, object should be in the scene\n     *\n     * @param {...GameObject} object\n     * @returns {this}\n     */\n    remove(...object) {\n        for (let obj of object)\n            if (obj instanceof _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject) {\n                let index = this.children.indexOf(obj);\n                if (index !== -1) {\n                    this.removeTags(obj);\n                    obj.scene = null;\n                    this.children.splice(index, 1);\n                    obj.onRemove();\n                }\n            }\n        return this;\n    }\n    /**\n     * Remove the given objects and their children from the tag sorting lists\n     * Should not be called by the user\n     *\n     * @param {...GameObject} object\n     * @returns {this}\n     */\n    removeTags(...object) {\n        for (let obj of object)\n            if (obj instanceof _GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject) {\n                for (let tag of obj.tags) {\n                    let list = this.tags.get(tag);\n                    let index = list.indexOf(obj);\n                    if (index !== -1)\n                        list.splice(index, 1);\n                }\n                this.removeTags(...obj.children);\n            }\n        return this;\n    }\n    /**\n     * Get an immutable array of all the object using the given tag\n     *\n     * @param {string} tag\n     * @returns {GameObject[]}\n     */\n    getTags(tag) {\n        return [...(this.tags.get(tag) ?? [])];\n    }\n    /**\n     * Is called when the scene is set to a GameEngine\n     * Is to be modified by the user\n     * Should not be called by the user\n     */\n    onSet() {\n    }\n    /**\n     * Is called when the scene is unset from a GameEngine\n     * Is to be modified by the user\n     * Should not be called by the user\n     */\n    onUnSet() {\n    }\n    /**\n     * Is called when the canvas viewport changes when used by a GameEngine\n     * Is to be modified by the user\n     * Should not be called by the user\n     *\n     * @param {number} width\n     * @param {number} height\n     */\n    onResize(width, height) {\n    }\n    /**\n     * Update the scene specific operation\n     *\n     * Is called when the scene is updated\n     * Is to be modified by the user\n     * Should not be called by the user\n     *\n     * @param {number} dt\n     */\n    update(dt) { }\n    /**\n     * Update the scene physics specific operation\n     *\n     * Is called when the scene physics is updated\n     * Is to be modified by the user\n     * Should not be called by the user\n     *\n     * @param {number} dt\n     */\n    physics(dt) { }\n    /**\n     * Draw the scene specific element\n     *\n     * Is called when the scene is drawn\n     * Is to be modified by the user\n     * Should not be called by the user\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    draw(ctx) { }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/basics/GameScene.js?");

/***/ }),

/***/ "./js/basics/Input.js":
/*!****************************!*\
  !*** ./js/basics/Input.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GamepadControl: () => (/* binding */ GamepadControl),\n/* harmony export */   Input: () => (/* binding */ Input)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\nvar GamepadControl;\n(function (GamepadControl) {\n    GamepadControl[GamepadControl[\"left_joystick_right_dir\"] = 0] = \"left_joystick_right_dir\";\n    GamepadControl[GamepadControl[\"left_joystick_left_dir\"] = 1] = \"left_joystick_left_dir\";\n    GamepadControl[GamepadControl[\"left_joystick_up_dir\"] = 2] = \"left_joystick_up_dir\";\n    GamepadControl[GamepadControl[\"left_joystick_down_dir\"] = 3] = \"left_joystick_down_dir\";\n    GamepadControl[GamepadControl[\"left_joystick_button\"] = 4] = \"left_joystick_button\";\n    GamepadControl[GamepadControl[\"left_button\"] = 5] = \"left_button\";\n    GamepadControl[GamepadControl[\"left_trigger\"] = 6] = \"left_trigger\";\n    GamepadControl[GamepadControl[\"right_joystick_right_dir\"] = 7] = \"right_joystick_right_dir\";\n    GamepadControl[GamepadControl[\"right_joystick_left_dir\"] = 8] = \"right_joystick_left_dir\";\n    GamepadControl[GamepadControl[\"right_joystick_up_dir\"] = 9] = \"right_joystick_up_dir\";\n    GamepadControl[GamepadControl[\"right_joystick_down_dir\"] = 10] = \"right_joystick_down_dir\";\n    GamepadControl[GamepadControl[\"right_joystick_button\"] = 11] = \"right_joystick_button\";\n    GamepadControl[GamepadControl[\"right_button\"] = 12] = \"right_button\";\n    GamepadControl[GamepadControl[\"right_trigger\"] = 13] = \"right_trigger\";\n    GamepadControl[GamepadControl[\"button_A\"] = 14] = \"button_A\";\n    GamepadControl[GamepadControl[\"button_B\"] = 15] = \"button_B\";\n    GamepadControl[GamepadControl[\"button_X\"] = 16] = \"button_X\";\n    GamepadControl[GamepadControl[\"button_Y\"] = 17] = \"button_Y\";\n    GamepadControl[GamepadControl[\"button_left_arrow\"] = 18] = \"button_left_arrow\";\n    GamepadControl[GamepadControl[\"button_right_arrow\"] = 19] = \"button_right_arrow\";\n    GamepadControl[GamepadControl[\"button_up_arrow\"] = 20] = \"button_up_arrow\";\n    GamepadControl[GamepadControl[\"button_down_arrow\"] = 21] = \"button_down_arrow\";\n    GamepadControl[GamepadControl[\"button_back\"] = 22] = \"button_back\";\n    GamepadControl[GamepadControl[\"button_start\"] = 23] = \"button_start\";\n    GamepadControl[GamepadControl[\"button_home\"] = 24] = \"button_home\";\n})(GamepadControl = GamepadControl || (GamepadControl = {}));\n/**\n * The Input class is used to register keyboard input, and mouse input if linked to an element\n */\nclass Input {\n    #keylock = null;\n    #charDown = new Set();\n    #charOnce = new Set();\n    #keysDown = new Set();\n    #keysOnce = new Set();\n    constructor() {\n        window.addEventListener('keydown', (evt) => {\n            this.#charDown.add(evt.key);\n            this.#charOnce.add(evt.key);\n            this.#keysDown.add(evt.code);\n            this.#keysOnce.add(evt.code);\n        });\n        window.addEventListener('keyup', (evt) => {\n            this.#charDown.delete(evt.key);\n            this.#charOnce.delete(evt.key);\n            this.#keysDown.delete(evt.code);\n            this.#keysOnce.delete(evt.code);\n        });\n    }\n    lock(lock = '') {\n        if (this.#keylock)\n            return;\n        this.#keylock = lock;\n    }\n    unlock(lock = '') {\n        if (this.#keylock !== lock)\n            return;\n        this.#keylock = null;\n    }\n    clearChar(char) {\n        this.#charDown.delete(char);\n        this.#charOnce.delete(char);\n    }\n    clear(code) {\n        this.#keysDown.delete(code);\n        this.#keysOnce.delete(code);\n    }\n    /**\n     * Return true if the given char is down\n     *\n     * @param {string} char\n     * @returns {boolean}\n     */\n    isCharDown(char, lock) {\n        if (this.#keylock && this.#keylock !== lock)\n            return false;\n        return this.#charDown.has(char);\n    }\n    /**\n     * return true once if the given char is down, must be repressed to return true again\n     *\n     * @param {string} code\n     * @returns {boolean}\n     */\n    isCharPressed(char, lock) {\n        if (this.#keylock && this.#keylock !== lock)\n            return false;\n        if (this.#charOnce.has(char)) {\n            this.#charOnce.delete(char);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Return true if the given key is down\n     *\n     * @param {string} code\n     * @returns {boolean}\n     */\n    isDown(code, lock) {\n        if (this.#keylock && this.#keylock !== lock)\n            return false;\n        return this.#keysDown.has(code);\n    }\n    /**\n     * return true once if the given key is down, must be repressed to return true again\n     *\n     * @param {string} code\n     * @returns {boolean}\n     */\n    isPressed(code, lock) {\n        if (this.#keylock && this.#keylock !== lock)\n            return false;\n        if (this.#keysOnce.has(code)) {\n            this.#keysOnce.delete(code);\n            return true;\n        }\n        return false;\n    }\n    // Mouse\n    #bindedElement;\n    #mouseButtons = [false, false, false];\n    #mousePosition = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    #trueMousePosition = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    #mouseIn = false;\n    #mouseClick = [false, false, false];\n    #mouseScroll = 0;\n    #delta = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    #trueDelta = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    positionAdapter = function (Vector) { return Vector; };\n    /**\n     * Returns an instant of the mouse, click field if true will be available for one frame only\n     */\n    get mouse() {\n        let result = {\n            left: this.#mouseButtons[0],\n            middle: this.#mouseButtons[1],\n            right: this.#mouseButtons[2],\n            leftClick: this.#mouseClick[0],\n            middleClick: this.#mouseClick[1],\n            rightClick: this.#mouseClick[2],\n            position: this.#trueMousePosition.clone(),\n            delta: this.#trueDelta.clone(),\n            scroll: this.#mouseScroll,\n            in: this.#mouseIn\n        };\n        return result;\n    }\n    /**\n     * Bind the input object to an html element, a position adapter function can be passed to convert the 0 to 1 default output to a preferable unit\n     *\n     * @param {HTMLElement} element\n     * @param {(Vector:Vector)=>Vector} positionAdapter\n     */\n    bindMouse(element, positionAdapter = function (Vector) { return Vector; }) {\n        this.positionAdapter = positionAdapter;\n        this.#bindedElement = element;\n        element.addEventListener('contextmenu', evt => evt.preventDefault());\n        element.addEventListener('mousedown', this.#handleMouseEvent.bind(this));\n        element.addEventListener('mouseup', this.#handleMouseEvent.bind(this));\n        element.addEventListener('mousemove', this.#handleMouseEvent.bind(this));\n        element.addEventListener('mouseleave', this.#handleMouseEvent.bind(this));\n        element.addEventListener('mouseenter', this.#handleMouseEvent.bind(this));\n        element.addEventListener('wheel', this.#handleMouseEvent.bind(this));\n    }\n    mouseLoop() {\n        this.#to01();\n        for (let index = 0; index < 3; index++)\n            this.#mouseClick[index] = false;\n        this.#mouseScroll = 0;\n    }\n    /**\n     * Handle the mouse related operations\n     *\n     * @param {MouseEvent} evt\n     */\n    #handleMouseEvent(evt) {\n        let prev = [this.#mouseButtons[0], this.#mouseButtons[1], this.#mouseButtons[2]];\n        this.#handleButtons(evt.buttons);\n        this.#mousePosition.set(evt.offsetX, evt.offsetY);\n        this.#mouseIn = this.#mousePosition.x > 0 && this.#mousePosition.x < 1 &&\n            this.#mousePosition.y > 0 && this.#mousePosition.y < 1;\n        for (let index = 0; index < 3; index++)\n            if (!this.#mouseButtons[index] && prev[index])\n                this.#mouseClick[index] = true;\n        if (evt instanceof WheelEvent)\n            this.#mouseScroll += Math.sign(evt.deltaY);\n        this.#delta.add(new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(evt.movementX, evt.movementY));\n    }\n    /**\n     * Convert the buttons input number to the adapted button boolean\n     *\n     * @param buttons\n     */\n    #handleButtons(buttons) {\n        switch (buttons) {\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n                this.#mouseButtons[0] = true;\n                break;\n            default:\n                this.#mouseButtons[0] = false;\n                break;\n        }\n        switch (buttons) {\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n                this.#mouseButtons[1] = true;\n                break;\n            default:\n                this.#mouseButtons[1] = false;\n                break;\n        }\n        switch (buttons) {\n            case 2:\n            case 3:\n            case 6:\n            case 7:\n                this.#mouseButtons[2] = true;\n                break;\n            default:\n                this.#mouseButtons[2] = false;\n                break;\n        }\n    }\n    /**\n     * convert the position from the html element size to the 0-1 scale\n     *\n     * @param evt\n     * @returns\n     */\n    #to01() {\n        this.#trueMousePosition = this.positionAdapter(this.#mousePosition\n            .clone()\n            .div(new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(this.#bindedElement.offsetWidth, this.#bindedElement.offsetHeight)));\n        this.#trueDelta = this.#delta\n            .clone()\n            .div(new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(this.#bindedElement.offsetWidth, -this.#bindedElement.offsetHeight));\n        this.#delta.set(0, 0);\n    }\n    // Gamepad\n    #gamepadMap = new Map();\n    #gamepad = {\n        left_joystick: new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(),\n        left_joystick_right_dir: 0,\n        left_joystick_left_dir: 0,\n        left_joystick_up_dir: 0,\n        left_joystick_down_dir: 0,\n        left_joystick_button: 0,\n        left_button: 0,\n        left_trigger: 0,\n        right_joystick: new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(),\n        right_joystick_right_dir: 0,\n        right_joystick_left_dir: 0,\n        right_joystick_up_dir: 0,\n        right_joystick_down_dir: 0,\n        right_joystick_button: 0,\n        right_button: 0,\n        right_trigger: 0,\n        button_A: 0,\n        button_B: 0,\n        button_X: 0,\n        button_Y: 0,\n        button_left_arrow: 0,\n        button_right_arrow: 0,\n        button_up_arrow: 0,\n        button_down_arrow: 0,\n        button_back: 0,\n        button_start: 0,\n        button_home: 0,\n    };\n    #calibrated = false;\n    deadPoint = .1;\n    #recordInput = null;\n    #recordOK = null;\n    #recordKO = null;\n    #gamepadCalibration = null;\n    #axesDefaultValue = null;\n    get isGamepadCalibrating() { return this.#gamepadCalibration !== null; }\n    get gamepad() {\n        return {\n            left_joystick: this.#gamepad.left_joystick.clone(),\n            left_joystick_right_dir: this.#gamepad.left_joystick_right_dir,\n            left_joystick_left_dir: this.#gamepad.left_joystick_left_dir,\n            left_joystick_up_dir: this.#gamepad.left_joystick_up_dir,\n            left_joystick_down_dir: this.#gamepad.left_joystick_down_dir,\n            left_joystick_button: this.#gamepad.left_joystick_button,\n            left_button: this.#gamepad.left_button,\n            left_trigger: this.#gamepad.left_trigger,\n            right_joystick: this.#gamepad.right_joystick.clone(),\n            right_joystick_right_dir: this.#gamepad.right_joystick_right_dir,\n            right_joystick_left_dir: this.#gamepad.right_joystick_left_dir,\n            right_joystick_up_dir: this.#gamepad.right_joystick_up_dir,\n            right_joystick_down_dir: this.#gamepad.right_joystick_down_dir,\n            right_joystick_button: this.#gamepad.right_joystick_button,\n            right_button: this.#gamepad.right_button,\n            right_trigger: this.#gamepad.right_trigger,\n            button_A: this.#gamepad.button_A,\n            button_B: this.#gamepad.button_B,\n            button_X: this.#gamepad.button_X,\n            button_Y: this.#gamepad.button_Y,\n            button_left_arrow: this.#gamepad.button_left_arrow,\n            button_right_arrow: this.#gamepad.button_right_arrow,\n            button_up_arrow: this.#gamepad.button_up_arrow,\n            button_down_arrow: this.#gamepad.button_down_arrow,\n            button_back: this.#gamepad.button_back,\n            button_start: this.#gamepad.button_start,\n            button_home: this.#gamepad.button_home,\n            is_calibrating: this.isGamepadCalibrating,\n            is_calibrated: this.#calibrated,\n            has_gamepad: navigator.getGamepads?.().length != 0 ?? false\n        };\n    }\n    #getCorrectedAxisValue(gamepad, index) {\n        if (!this.#axesDefaultValue)\n            return 0;\n        let defaultValue = this.#axesDefaultValue[index];\n        let value = gamepad.axes[index];\n        if (defaultValue !== 0) {\n            if (defaultValue < 0)\n                value = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.map)(value, defaultValue, 1, 0, 1);\n            else\n                value = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.map)(value, defaultValue, -1, 0, 1);\n        }\n        return value;\n    }\n    // Calibreation\n    /**\n     * Start the process of calibrating the axes of the connected controller.\n     * This includes but is not limited to: Joysticks, Triggers, Cross buttons...\n     *\n     * @param {(axesStates: number[]) => void | null} updateCallback\n     * @returns {Promise<void>}\n     */\n    calibrateGamepad(updateCallback = null) {\n        return new Promise((ok, ko) => {\n            this.#gamepadCalibration = {\n                ok: ok,\n                update: updateCallback,\n                axesStates: null,\n                axesTimer: null,\n            };\n        });\n    }\n    #setupCalibration(gamepad) {\n        let axesCount = gamepad.axes.length;\n        if (!this.#gamepadCalibration)\n            return;\n        this.#gamepadCalibration.axesStates = [];\n        this.#gamepadCalibration.axesTimer = [];\n        this.#axesDefaultValue = [];\n        for (let i = 0; i < axesCount; i++) {\n            this.#gamepadCalibration.axesStates.push(0);\n            this.#gamepadCalibration.axesTimer.push({ timer: new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Timer(), value: 0 });\n            this.#axesDefaultValue.push(0);\n        }\n    }\n    #pickupAxesForCalibration(gamepad) {\n        this.#getAllCurrentGamepadInputs(gamepad)\n            .filter(entry => entry.type === 'axes')\n            .filter(entry => this.#gamepadCalibration?.axesStates?.[entry.index] === 0)\n            .forEach(entry => {\n            if (this.#gamepadCalibration?.axesStates?.[entry.index])\n                this.#gamepadCalibration.axesStates[entry.index]++;\n            this.#gamepadCalibration?.axesTimer?.[entry.index].timer.reset();\n            this.#gamepadCalibration?.update?.([...(this.#gamepadCalibration?.axesStates ?? [])]);\n        });\n    }\n    #calibratePickedupAxes(gamepad) {\n        if (!this.#gamepadCalibration?.axesStates)\n            return;\n        let axesCalibrating = this.#gamepadCalibration.axesStates\n            .map((entry, index) => entry === 1 ? index : -1)\n            .filter(entry => entry !== -1);\n        for (let axisIndex of axesCalibrating) {\n            let axisValue = gamepad.axes[axisIndex];\n            if (Math.abs(axisValue) < this.deadPoint)\n                axisValue = 0;\n            let axis = this.#gamepadCalibration.axesTimer[axisIndex];\n            if (axis.value !== axisValue) {\n                axis.timer.reset();\n                axis.value = axisValue;\n            }\n            else if (axis.timer.greaterThan(2000)) {\n                this.#gamepadCalibration.axesStates[axisIndex]++;\n                this.#axesDefaultValue[axisIndex] = axisValue;\n                this.#gamepadCalibration.update?.([...this.#gamepadCalibration.axesStates]);\n            }\n        }\n        if (this.#gamepadCalibration.axesStates.every(entry => entry === 2)) {\n            this.#gamepadCalibration.ok();\n            this.#gamepadCalibration = null;\n            this.#calibrated = true;\n        }\n    }\n    #calibrationLoop(gamepad) {\n        if (this.#gamepadCalibration && this.#gamepadCalibration.axesStates === null)\n            this.#setupCalibration(gamepad);\n        this.#pickupAxesForCalibration(gamepad);\n        this.#calibratePickedupAxes(gamepad);\n    }\n    // Record Controls\n    getGamepadControlAccess(gamepadControl) {\n        let gca = this.#gamepadMap.get(gamepadControl);\n        return gca ? { ...gca } : undefined;\n    }\n    #getAllCurrentGamepadInputs(gamepad) {\n        let axisInput = gamepad.axes\n            .map((axe, index) => {\n            axe = this.#getCorrectedAxisValue(gamepad, index);\n            return { data: { type: 'axes', index, inverted: axe < 0 }, value: Math.abs(axe) };\n        })\n            .filter(entry => entry.value > .5)\n            .map(entry => entry.data);\n        let buttonsInput = gamepad.buttons\n            .map((button, index) => ({ data: { type: 'buttons', index, inverted: button.value < 0 }, value: Math.abs(button.value) }))\n            .filter(entry => entry.value > .5)\n            .map(entry => entry.data);\n        return [...axisInput, ...buttonsInput];\n    }\n    #recordLoop(gamepad) {\n        let input = this.#getAllCurrentGamepadInputs(gamepad)[0];\n        if (input) {\n            let duplicate = [...this.#gamepadMap.entries()].find(([_, entry]) => entry.type === input.type && entry.index === input.index && entry.inverted === input.inverted);\n            if (duplicate)\n                this.#recordKO(duplicate[0]);\n            else {\n                this.#gamepadMap.set(this.#recordInput, input);\n                this.#recordOK();\n            }\n            this.#recordInput = this.#recordOK = this.#recordKO = null;\n        }\n    }\n    #processGamepadControl(gamepad, gamepadControl) {\n        let gamepadControlAccess = this.#gamepadMap.get(gamepadControl);\n        if (!gamepadControlAccess)\n            return 0;\n        let value = 0;\n        if (gamepadControlAccess.type === 'axes')\n            value = this.#getCorrectedAxisValue(gamepad, gamepadControlAccess.index);\n        else\n            value = gamepad.buttons[gamepadControlAccess.index].value;\n        if (Math.abs(value) < this.deadPoint)\n            value = 0;\n        if (gamepadControlAccess.inverted)\n            value *= -1;\n        return 0 > value ? 0 : value;\n    }\n    #gamepadInputUpdateLoop(gamepad) {\n        for (let key of Object.keys(GamepadControl))\n            this.#gamepad[key] = this.#processGamepadControl(gamepad, GamepadControl[key]);\n        this.#gamepad.left_joystick.set(this.#gamepad.left_joystick_right_dir - this.#gamepad.left_joystick_left_dir, this.#gamepad.left_joystick_up_dir - this.#gamepad.left_joystick_down_dir);\n        this.#gamepad.right_joystick.set(this.#gamepad.right_joystick_right_dir - this.#gamepad.right_joystick_left_dir, this.#gamepad.right_joystick_up_dir - this.#gamepad.right_joystick_down_dir);\n    }\n    gamepadLoop() {\n        let gamepad = navigator.getGamepads?.()[0] ?? null;\n        if (!gamepad)\n            return;\n        if (!this.#axesDefaultValue)\n            this.#axesDefaultValue = new Array().fill(0, 0, gamepad.axes.length);\n        if (this.isGamepadCalibrating)\n            this.#calibrationLoop(gamepad);\n        if (this.#recordOK)\n            this.#recordLoop(gamepad);\n        this.#gamepadInputUpdateLoop(gamepad);\n    }\n    recordGamepadControl(gamepadControl) {\n        return new Promise((ok, ko) => {\n            this.#gamepadMap.delete(gamepadControl);\n            this.#recordOK = ok;\n            this.#recordKO = ko;\n            this.#recordInput = gamepadControl;\n        });\n    }\n    unsetGamepadControl(gamepadControl) {\n        this.#gamepadMap.delete(gamepadControl);\n    }\n    /**\n     * Returns an array containing the if of the control that have been defined\n     *\n     * @returns {number[]}\n     */\n    getDefinedGamepadControls() {\n        return [...this.#gamepadMap.keys()];\n    }\n    /**\n     * Returns the control currently waiting for a the user to interact with the gamepad\n     *\n     * @returns {number | null}\n     */\n    getRecording() { return this.#recordInput; }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/basics/Input.js?");

/***/ }),

/***/ "./js/basics/Utils.js":
/*!****************************!*\
  !*** ./js/basics/Utils.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sound: () => (/* binding */ Sound),\n/* harmony export */   badclone: () => (/* binding */ badclone),\n/* harmony export */   dummy: () => (/* binding */ dummy),\n/* harmony export */   getCircularReplacer: () => (/* binding */ getCircularReplacer),\n/* harmony export */   id: () => (/* binding */ id),\n/* harmony export */   loadImages: () => (/* binding */ loadImages),\n/* harmony export */   loadSVGs: () => (/* binding */ loadSVGs),\n/* harmony export */   loadSounds: () => (/* binding */ loadSounds),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   resolveStringable: () => (/* binding */ resolveStringable)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _images_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../images/Utils.js */ \"./js/images/Utils.js\");\n/* harmony import */ var _GameObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameObject.js */ \"./js/basics/GameObject.js\");\n\n\n\n/**\n * loads multiple images and use callbacks for progression checks and at the end\n *\n * @param {{ name: string, src: string }[]} images\n * @param {(completed:number) => void} incrementCallback\n * @param {() => void}finishedCallback\n * @returns\n */\nfunction loadImages(images, incrementCallback, finishedCallback) {\n    let bank = new Map();\n    let completed = { n: 0 };\n    for (let image of images) {\n        let img = document.createElement('img');\n        img.src = image.src;\n        img.onload = function () {\n            completed.n++;\n            incrementCallback(completed.n);\n            if (completed.n == images.length)\n                finishedCallback();\n        };\n        img.onerror = function (err) {\n            console.error(`Could not load image \"${image.name}\" for source \"${image.src}\"`);\n            console.error(err);\n            completed.n++;\n            incrementCallback(completed.n);\n            if (completed.n == images.length)\n                finishedCallback();\n        };\n        bank.set(image.name, img);\n    }\n    if (images.length === 0)\n        finishedCallback();\n    return bank;\n}\nfunction loadSVGs(svgs, incrementCallback, finishedCallback) {\n    let bank = new Map();\n    let completed = { n: 0 };\n    for (let svg of svgs) {\n        let data = { raw: '', image: new Image() };\n        fetch(svg.src)\n            .then(res => {\n            if (res.ok)\n                return res.text();\n            throw res;\n        })\n            .then(svg => {\n            data.raw = svg;\n            return svg;\n        })\n            .then(_images_Utils_js__WEBPACK_IMPORTED_MODULE_1__.SVGStringToImage)\n            .then(image => {\n            data.image = image;\n            completed.n++;\n            incrementCallback(completed.n);\n        })\n            .catch(err => {\n            console.error(`Could not load image \"${svg.name}\" for source \"${svg.src}\"`);\n            console.error(err);\n            completed.n++;\n            incrementCallback(completed.n);\n        })\n            .finally(() => {\n            if (completed.n == svgs.length)\n                finishedCallback();\n        });\n        bank.set(svg.name, data);\n    }\n    if (svgs.length === 0)\n        finishedCallback();\n    return bank;\n}\nclass Sound {\n    volume = 1;\n    soundsFifo = [];\n    currentSound = 0;\n    constructor(soundsFifo) {\n        this.soundsFifo = soundsFifo;\n    }\n    play() {\n        let sounds = this.soundsFifo[this.currentSound];\n        for (let sound of sounds)\n            sound.pause();\n        let sound = sounds[Math.floor(Math.random() * sounds.length)];\n        sound.volume = this.volume;\n        sound.currentTime = 0;\n        sound.play();\n        this.currentSound += 1;\n        this.currentSound %= this.soundsFifo.length;\n    }\n    pause() {\n        for (let sounds of this.soundsFifo)\n            for (let sound of sounds)\n                sound.pause();\n    }\n    setVolume(volume) { this.volume = volume; }\n}\nfunction loadSounds(sounds, incrementCallback, finishedCallback) {\n    let bank = new Map();\n    let completed = { n: 0 };\n    let toComplete = { n: 0 };\n    for (let sound of sounds) {\n        let backups = [];\n        for (let index = 0; index < (sound.backup ?? 1); index++) {\n            let snds = [];\n            for (let src of sound.srcs) {\n                toComplete.n++;\n                let snd = document.createElement('audio');\n                snd.src = src;\n                snd.oncanplay = function () {\n                    completed.n++;\n                    incrementCallback(completed.n);\n                    if (completed.n == toComplete.n)\n                        finishedCallback();\n                };\n                snd.onerror = function (err) {\n                    console.error(`Could not load sound \"${sound.name}\" for source \"${src}\"`);\n                    console.error(err);\n                    completed.n++;\n                    incrementCallback(completed.n);\n                    if (completed.n == toComplete.n)\n                        finishedCallback();\n                };\n                snds.push(snd);\n            }\n            backups.push(snds);\n        }\n        bank.set(sound.name, new Sound(backups));\n    }\n    if (completed.n == toComplete.n)\n        finishedCallback();\n    return bank;\n}\nlet idCount = 0;\nfunction id() { return ++idCount; }\nfunction* range(min, max = null, step = 1) {\n    if (max === null || max === undefined) {\n        max = min;\n        min = 0;\n    }\n    for (let i = min; i < max; i += step)\n        yield i;\n}\nfunction getCircularReplacer() {\n    const seen = new WeakSet();\n    return (key, value) => {\n        if (typeof value === 'object' && value !== null) {\n            if (seen.has(value))\n                return;\n            seen.add(value);\n        }\n        return value;\n    };\n}\nfunction badclone(o) { return JSON.parse(JSON.stringify(o, getCircularReplacer())); }\nfunction resolveStringable(value) {\n    if (value === null)\n        return '';\n    return typeof value === 'string' ? value : value();\n}\nfunction dummy(x = 0, y = 0) {\n    let obj = new _GameObject_js__WEBPACK_IMPORTED_MODULE_2__.GameObject();\n    obj.position.set(x, y);\n    let rect = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 1, 1);\n    rect.fill = false;\n    rect.display = true;\n    obj.add(rect);\n    return obj;\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/basics/Utils.js?");

/***/ }),

/***/ "./js/camera/Camera.js":
/*!*****************************!*\
  !*** ./js/camera/Camera.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _math_Transform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Transform.js */ \"./js/math/Transform.js\");\n\n\n\n/**\n * The Camera class is used to set the center of the view inside a scene\n */\nclass Camera extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject {\n    /**\n     * Create a new Camera object\n     */\n    constructor() {\n        super();\n        this.updateEnabled = false;\n        this.physicsEnabled = false;\n        this.drawEnabled = false;\n        this.zIndex = Number.MAX_SAFE_INTEGER;\n    }\n    get viewRect() {\n        return new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Rectangle(this.position.x, this.position.y, this.engine.usableWidth * this.size.x, this.engine.usableHeight * this.size.y);\n    }\n    getViewTransformMatrix() {\n        let wpos = this.getWorldPosition();\n        let wrot = this.getWorldRotation();\n        return new _math_Transform_js__WEBPACK_IMPORTED_MODULE_2__.Transform(wpos, wrot, this.transform.scale).getInvertMatrix();\n    }\n    getRange() { return Math.max(this.transform.scale.x, this.transform.scale.y); }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/camera/Camera.js?");

/***/ }),

/***/ "./js/camera/TrackingCamera.js":
/*!*************************************!*\
  !*** ./js/camera/TrackingCamera.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrackingCamera: () => (/* binding */ TrackingCamera),\n/* harmony export */   TrackingCameraDisableMode: () => (/* binding */ TrackingCameraDisableMode)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _Camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Camera.js */ \"./js/camera/Camera.js\");\n\n\nvar TrackingCameraDisableMode;\n(function (TrackingCameraDisableMode) {\n    TrackingCameraDisableMode[TrackingCameraDisableMode[\"DISABLE\"] = 0] = \"DISABLE\";\n    TrackingCameraDisableMode[TrackingCameraDisableMode[\"DISABLE_ONCE\"] = 1] = \"DISABLE_ONCE\";\n    TrackingCameraDisableMode[TrackingCameraDisableMode[\"DONT_DISABLE\"] = 2] = \"DONT_DISABLE\";\n})(TrackingCameraDisableMode = TrackingCameraDisableMode || (TrackingCameraDisableMode = {}));\nclass TrackingCamera extends _Camera_js__WEBPACK_IMPORTED_MODULE_1__.Camera {\n    /**\n     * The object the camera should track, if null, stops tracking\n     */\n    trackedObject = null;\n    /**\n     * The number of second it should theorycally take to the camera to travel the current distance from the camera to the object.\n     */\n    trackLag = 1;\n    /**\n     * The minimum speed at which the camera should travel when the speed reach do to the track lag is to slow\n     */\n    minTrackSpeed = 1;\n    autoDisableTracking = TrackingCameraDisableMode.DONT_DISABLE;\n    trackedZoom = null;\n    zoomTrackLag = 1;\n    zoomMinTrackSpeed = 1;\n    autoDisableZoomTracking = TrackingCameraDisableMode.DONT_DISABLE;\n    constructor() {\n        super();\n        this.updateEnabled = true;\n    }\n    update(dt) {\n        if (this.trackedObject && (this.trackedObject instanceof _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector || this.scene === this.trackedObject.scene)) {\n            let cameraWorldPosition = this.getWorldPosition();\n            let objectWorldPosition = this.trackedObject instanceof _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector ? this.trackedObject.clone() : this.trackedObject.getWorldPosition();\n            if (!cameraWorldPosition.equal(objectWorldPosition)) {\n                let rawOffset = objectWorldPosition.clone().sub(cameraWorldPosition);\n                let offset = rawOffset.clone().divS(this.trackLag);\n                let len = offset.length();\n                if (len < this.minTrackSpeed)\n                    offset.normalize().multS(this.minTrackSpeed);\n                offset.multS(dt);\n                if (offset.length() > cameraWorldPosition.distanceTo(objectWorldPosition))\n                    this.transform.translation.add(rawOffset);\n                else\n                    this.transform.translation.add(offset);\n            }\n            else {\n                if (this.autoDisableTracking === TrackingCameraDisableMode.DISABLE_ONCE) {\n                    this.trackedObject = null;\n                    this.autoDisableTracking = TrackingCameraDisableMode.DONT_DISABLE;\n                }\n                else if (this.autoDisableTracking === TrackingCameraDisableMode.DISABLE)\n                    this.trackedObject = null;\n            }\n        }\n        if (this.trackedZoom) {\n            if (this.transform.scale.x !== this.trackedZoom) {\n                let rawZoomOffset = this.trackedZoom - this.transform.scale.x;\n                let offset = rawZoomOffset / this.zoomTrackLag;\n                let len = Math.abs(offset);\n                if (len < this.zoomMinTrackSpeed)\n                    offset = Math.sign(offset) * this.zoomMinTrackSpeed;\n                offset *= dt;\n                let trueDist = this.transform.scale.x - this.transform.scale.x * (1 + offset);\n                if (Math.abs(trueDist) > Math.abs(rawZoomOffset))\n                    this.transform.scale.set(this.trackedZoom, this.trackedZoom);\n                else\n                    this.transform.scale.multS(1 + offset);\n            }\n            else {\n                if (this.autoDisableZoomTracking === TrackingCameraDisableMode.DISABLE_ONCE) {\n                    this.trackedZoom = null;\n                    this.autoDisableZoomTracking = TrackingCameraDisableMode.DONT_DISABLE;\n                }\n                else if (this.autoDisableZoomTracking === TrackingCameraDisableMode.DISABLE)\n                    this.trackedZoom = null;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/camera/TrackingCamera.js?");

/***/ }),

/***/ "./js/components/CameraDragComponent.js":
/*!**********************************************!*\
  !*** ./js/components/CameraDragComponent.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraDragComponent: () => (/* binding */ CameraDragComponent)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _camera_Camera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../camera/Camera.js */ \"./js/camera/Camera.js\");\n\n\nclass CameraDragComponent extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameComponent {\n    unique = true;\n    static leftButton = 0;\n    static rightButton = 1;\n    static middleButton = 2;\n    button;\n    scrollZoomEnabled;\n    enabled = true;\n    constructor(button = 1, scrollZoomEnabled = true) {\n        super('camera-drag');\n        this.button = button;\n        this.scrollZoomEnabled = scrollZoomEnabled;\n    }\n    onAdd() {\n        if (!this.parent || !(this.parent instanceof _camera_Camera_js__WEBPACK_IMPORTED_MODULE_1__.Camera))\n            throw 'Parent of this component must be a Camera';\n    }\n    #target = null;\n    update(dt) {\n        if (!this.enabled)\n            return;\n        let mouse = this.input.mouse;\n        let button = false;\n        if (this.button === 0)\n            button = mouse.left;\n        else if (this.button === 1)\n            button = mouse.right;\n        else if (this.button === 2)\n            button = mouse.middle;\n        if (button) {\n            if (!this.#target)\n                this.#target = mouse.position.clone();\n            let delta = this.#target.clone().sub(mouse.position);\n            this.parent.transform.translation.add(delta);\n        }\n        else\n            this.#target = null;\n        if (this.scrollZoomEnabled && mouse.scroll) {\n            let scale = 1.1 ** mouse.scroll;\n            let delta = mouse.position.clone().sub(this.parent.transform.translation);\n            this.parent.transform.translation.add(delta);\n            this.parent.transform.scale.multS(scale);\n            this.parent.transform.translation.sub(delta.multS(scale));\n        }\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/components/CameraDragComponent.js?");

/***/ }),

/***/ "./js/components/RigidBodyComponent.js":
/*!*********************************************!*\
  !*** ./js/components/RigidBodyComponent.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigitBodyComponent: () => (/* binding */ RigitBodyComponent)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\nclass RigitBodyComponent extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameComponent {\n    unique = true;\n    velocity = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    acceleration = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    momentsOfInertia = [];\n    momentOfInertia = 1;\n    angularVelocity = 0;\n    angularAcceleration = 0;\n    polygon;\n    mass;\n    constructor(polygon, weight) {\n        super('RigitBody');\n        this.updatePolygon(polygon, weight);\n    }\n    updatePolygon(polygon, weight) {\n        this.mass = weight;\n        let centerOfMass = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n        for (let point of polygon.outer) {\n            centerOfMass.add(point);\n        }\n        centerOfMass.divS(polygon.outer.length);\n        this.polygon = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Polygon(polygon.outer.map(point => point.clone().sub(centerOfMass)));\n        this.momentsOfInertia = this.polygon.outer.map(({ x, y }) => this.mass / this.polygon.outer.length * (x * x + y * y));\n        this.momentOfInertia = this.momentsOfInertia.reduce((a, b) => a + b);\n    }\n    physics(dt) {\n        let dt2 = dt * dt;\n        let delta = this.velocity.clone().multS(dt)\n            .add(this.acceleration.clone().multS(dt2 * .5));\n        this.velocity.add(this.acceleration.clone().multS(dt));\n        this.acceleration.set(0, 0);\n        this.parent.position.copy(delta);\n        let deltaAngle = this.angularVelocity * dt + this.angularAcceleration * dt2 * .5;\n        this.angularVelocity += this.angularAcceleration * dt;\n        this.angularAcceleration = 0;\n        this.parent.rotation += deltaAngle;\n    }\n    applyForce(position, force) {\n        this.acceleration.add(force.clone().divS(this.mass));\n        this.angularAcceleration += (position.x * force.y - position.y * force.x) / this.momentOfInertia;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/components/RigidBodyComponent.js?");

/***/ }),

/***/ "./js/components/StateMachine.js":
/*!***************************************!*\
  !*** ./js/components/StateMachine.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StateMachine: () => (/* binding */ StateMachine)\n/* harmony export */ });\nclass StateMachine {\n    unique = true;\n    boundObject;\n    state = [];\n    statesActions = {};\n    constructor(boundObject, startState = [0]) {\n        this.boundObject = boundObject;\n        this.state = startState;\n    }\n    setState(state) {\n        let stateString = this.#computeStateString(this.state);\n        for (let stateActions of this.statesActions[stateString] ?? [])\n            stateActions.leave?.(this.boundObject);\n        this.state = state;\n        stateString = this.#computeStateString(this.state);\n        for (let stateActions of this.statesActions[stateString] ?? [])\n            stateActions.enter?.(this.boundObject);\n    }\n    isState(state) {\n        for (let index in state)\n            if (state[index] !== this.state[index])\n                return false;\n        return true;\n    }\n    #computeStateString(state, postState = false) { return state.join('_') + (postState ? '_post' : ''); }\n    addStateActions(state, stateActions, postState = false) {\n        let stateString = this.#computeStateString(state, postState);\n        if (!this.statesActions[stateString])\n            this.statesActions[stateString] = [];\n        this.statesActions[stateString].push(stateActions);\n    }\n    /**\n     * Execute the current state callback\n     * If a callback in the chain, returns a non null value, the other callback in the chain will not be executed and the current state will change\n     * Post state will always be executed, on the reached level, i.e. if root levels change state before, leaf levels, leaf level will not be executed (including they post callback), but the root level post callback will be executed\n     *\n     * @param dt\n     */\n    update(dt) {\n        let state = [];\n        let nextState = null;\n        stateLoop: while (state.length < this.state.length + 1) {\n            let stateString = this.#computeStateString(state);\n            for (let stateActions of this.statesActions[stateString] ?? []) {\n                nextState = stateActions.update?.(this.boundObject, dt) ?? null;\n                if (!nextState)\n                    continue;\n                break stateLoop;\n            }\n            state.push(this.state[state.length]);\n        }\n        while (state.length != 0) {\n            let stateString = this.#computeStateString(state, true);\n            for (let stateActions of this.statesActions[stateString] ?? [])\n                stateActions.update?.(this.boundObject, dt);\n            state.pop();\n        }\n        for (let stateActions of this.statesActions[this.#computeStateString([], true)] ?? [])\n            stateActions.update?.(this.boundObject, dt);\n        if (nextState) {\n            let stateString = this.#computeStateString(this.state);\n            for (let stateActions of this.statesActions[stateString] ?? [])\n                stateActions.leave?.(this.boundObject);\n            this.state = nextState;\n            stateString = this.#computeStateString(this.state);\n            for (let stateActions of this.statesActions[stateString] ?? [])\n                stateActions.enter?.(this.boundObject);\n        }\n    }\n    physics(dt) {\n        let state = [];\n        while (state.length < this.state.length + 1) {\n            let stateString = this.#computeStateString(state);\n            for (let stateActions of this.statesActions[stateString] ?? [])\n                stateActions.physics?.(this.boundObject, dt);\n            state.push(this.state[state.length]);\n        }\n        while (state.length != 0) {\n            let stateString = this.#computeStateString(state, true);\n            for (let stateActions of this.statesActions[stateString] ?? [])\n                stateActions.physics?.(this.boundObject, dt);\n            state.pop();\n        }\n        for (let stateActions of this.statesActions[this.#computeStateString([], true)] ?? [])\n            stateActions.physics?.(this.boundObject, dt);\n    }\n    draw(ctx) {\n        let state = [];\n        while (state.length < this.state.length + 1) {\n            let stateString = this.#computeStateString(state);\n            for (let stateActions of this.statesActions[stateString] ?? [])\n                stateActions.draw?.(this.boundObject, ctx);\n            state.push(this.state[state.length]);\n        }\n        while (state.length != 0) {\n            let stateString = this.#computeStateString(state, true);\n            for (let stateActions of this.statesActions[stateString] ?? [])\n                stateActions.draw?.(this.boundObject, ctx);\n            state.pop();\n        }\n        for (let stateActions of this.statesActions[this.#computeStateString([], true)] ?? [])\n            stateActions.draw?.(this.boundObject, ctx);\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/components/StateMachine.js?");

/***/ }),

/***/ "./js/geometry/CatmullRomSpline.js":
/*!*****************************************!*\
  !*** ./js/geometry/CatmullRomSpline.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CatmullRomSpline: () => (/* binding */ CatmullRomSpline)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _HermiteSpline_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HermiteSpline.js */ \"./js/geometry/HermiteSpline.js\");\n\n\nclass CatmullRomSpline extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    points = [];\n    loop = false;\n    constructor(points, loop = false) {\n        super();\n        this.points = points;\n        this.loop = loop;\n    }\n    getHermiteSpline() {\n        if (this.points.length < 3)\n            return null;\n        let nodes = [];\n        let points = [...this.points];\n        if (this.loop) {\n            points.unshift(this.points[this.points.length - 1]);\n            points.push(this.points[0], this.points[1]);\n        }\n        for (let index = 1; index < points.length - 1; index++) {\n            let p_0 = points[index - 1];\n            let p_1 = points[index];\n            let p_2 = points[index + 1];\n            let dir = p_2.clone().sub(p_0).divS(2);\n            nodes.push({ position: p_1.clone(), direction: dir });\n        }\n        return new _HermiteSpline_js__WEBPACK_IMPORTED_MODULE_1__.HermiteSpline(nodes);\n    }\n    draw(ctx) {\n        this.getHermiteSpline()?.executeDraw(ctx);\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/CatmullRomSpline.js?");

/***/ }),

/***/ "./js/geometry/CubicBezier.js":
/*!************************************!*\
  !*** ./js/geometry/CubicBezier.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CubicBezier: () => (/* binding */ CubicBezier)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\nclass CubicBezier extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    #point_0;\n    #control_0;\n    #control_1;\n    #point_1;\n    get point_0() { return this.#point_0; }\n    get control_0() { return this.#control_0; }\n    get control_1() { return this.#control_1; }\n    get point_1() { return this.#point_1; }\n    #lengthCache = null;\n    #lengthToT = new Map();\n    #tToLength = new Map();\n    lineWidth = 0.01;\n    strokeStyle = 'black';\n    drawTangents = false;\n    /**\n     *\n     * @param point_0\n     * @param control_0\n     * @param control_1\n     * @param point_1\n     */\n    constructor(point_0, control_0, control_1, point_1) {\n        super();\n        let handler = this.#proxyHandler();\n        this.#point_0 = new Proxy(point_0.clone(), handler);\n        this.#control_0 = new Proxy(control_0.clone(), handler);\n        this.#control_1 = new Proxy(control_1.clone(), handler);\n        this.#point_1 = new Proxy(point_1.clone(), handler);\n    }\n    #proxyHandler() {\n        let me = this;\n        return {\n            set(target, p, newValue, receiver) {\n                me.invalidateCache();\n                return Reflect.set(target, p, newValue, receiver);\n            }\n        };\n    }\n    get(t) {\n        return new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(...(0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.cubicBezier)([this.#point_0.x, this.#point_0.y], [this.#control_0.x, this.#control_0.y], [this.#control_1.x, this.#control_1.y], [this.#point_1.x, this.#point_1.y], t));\n    }\n    getLengthAtT(t) {\n        if (this.#lengthToT.size === 0)\n            this.#computeLengthToT();\n        t = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, t, 1);\n        if (t === 0)\n            return 0;\n        if (t == 1)\n            return this.#tToLength.get(1);\n        let subt = Math.floor(t * 100) / 100;\n        return (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(this.#tToLength.get(subt), this.#tToLength.get(subt + 0.01), t - subt);\n    }\n    getTAtLength(length) {\n        if (this.#lengthToT.size === 0)\n            this.#computeLengthToT();\n        length = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, length, this.#tToLength.get(1));\n        if (length === this.#tToLength.get(1))\n            return 1;\n        if (length === 0)\n            return 0;\n        let keys = [...this.#lengthToT.keys()].sort((a, b) => a - b);\n        let keyindex = keys.indexOf(keys.find(key => length >= key));\n        let d0 = keys[keyindex];\n        let d1 = keys[keyindex + 1];\n        let d = d1 - d0;\n        let t = (length - d0) / d;\n        let t0 = this.#lengthToT.get(d0);\n        let t1 = this.#lengthToT.get(d1);\n        return (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(t0, t1, t);\n    }\n    #computeLengthToT() {\n        this.#lengthToT.clear();\n        this.#tToLength.clear();\n        let length = 0;\n        let prev = this.get(0);\n        this.#lengthToT.set(0, 0);\n        this.#tToLength.set(0, 0);\n        for (let t = 0.01; t <= 1; t += 0.01) {\n            let current = this.get(t);\n            length += _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector.distanceBetween(prev, current);\n            this.#lengthToT.set(length, t);\n            this.#tToLength.set(t, length);\n            prev = current;\n        }\n    }\n    length() {\n        if (this.#lengthCache !== null)\n            return this.#lengthCache;\n        let length = 0;\n        let prev = this.get(0);\n        for (let t = 0.01; t <= 1; t += 0.01) {\n            let current = this.get(t);\n            length += _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector.distanceBetween(prev, current);\n            prev = current;\n        }\n        this.#lengthCache = length;\n        this.#computeLengthToT();\n        return length;\n    }\n    invalidateCache() {\n        this.#lengthCache = null;\n        this.#lengthToT.clear();\n        this.#tToLength.clear();\n    }\n    draw(ctx) {\n        ctx.save();\n        ctx.lineWidth = this.lineWidth;\n        ctx.strokeStyle = this.strokeStyle;\n        ctx.beginPath();\n        ctx.moveTo(this.#point_0.x, this.#point_0.y);\n        ctx.bezierCurveTo(this.#control_0.x, this.#control_0.y, this.#control_1.x, this.#control_1.y, this.#point_1.x, this.#point_1.y);\n        ctx.stroke();\n        if (this.drawTangents) {\n            ctx.strokeStyle = 'red';\n            ctx.beginPath();\n            ctx.moveTo(this.#point_0.x, this.#point_0.y);\n            ctx.lineTo(this.#control_0.x, this.#control_0.y);\n            ctx.moveTo(this.#point_1.x, this.#point_1.y);\n            ctx.lineTo(this.#control_1.x, this.#control_1.y);\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/CubicBezier.js?");

/***/ }),

/***/ "./js/geometry/CubicBezierSpline.js":
/*!******************************************!*\
  !*** ./js/geometry/CubicBezierSpline.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CubicBezierSpline: () => (/* binding */ CubicBezierSpline)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\nclass CubicBezierSpline extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    cubicBeziers = [];\n    constructor(cubicBeziers) {\n        super();\n        this.cubicBeziers = cubicBeziers;\n    }\n    get(t) {\n        t = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, t, this.cubicBeziers.length);\n        let floorT = Math.floor((0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, t, this.cubicBeziers.length - 1));\n        return this.cubicBeziers[floorT]?.get(t - floorT) ?? null;\n    }\n    getLengthAtT(t) {\n        t = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, t, this.cubicBeziers.length);\n        let floorT = Math.floor((0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, t, this.cubicBeziers.length - 1));\n        let length = 0;\n        for (let index = 0; index < floorT; index++)\n            length += this.cubicBeziers[index].length();\n        return length + this.cubicBeziers[floorT].getLengthAtT(t - floorT);\n    }\n    getTAtLength(length) {\n        length = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, length, this.length());\n        let t = 0;\n        for (let cb of this.cubicBeziers) {\n            let cbLength = cb.length();\n            if (cbLength < length) {\n                length -= cbLength;\n                t += 1;\n            }\n            else {\n                t += cb.getTAtLength(length);\n                return t;\n            }\n        }\n        return t;\n    }\n    length() {\n        let length = 0;\n        for (let cb of this.cubicBeziers)\n            length += cb.length();\n        return length;\n    }\n    draw(ctx) {\n        for (let cb of this.cubicBeziers)\n            cb.executeDraw(ctx);\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/CubicBezierSpline.js?");

/***/ }),

/***/ "./js/geometry/HermiteSpline.js":
/*!**************************************!*\
  !*** ./js/geometry/HermiteSpline.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HermiteSpline: () => (/* binding */ HermiteSpline)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _CubicBezier_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CubicBezier.js */ \"./js/geometry/CubicBezier.js\");\n/* harmony import */ var _CubicBezierSpline_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CubicBezierSpline.js */ \"./js/geometry/CubicBezierSpline.js\");\n\n\n\nclass HermiteSpline extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    nodes = [];\n    constructor(nodes) {\n        super();\n        this.nodes = nodes;\n    }\n    getCubicBezierSpline() {\n        let beziers = [];\n        for (let index = 0; index < this.nodes.length - 1; index++) {\n            let node_0 = this.nodes[index];\n            let node_1 = this.nodes[index + 1];\n            let p0 = node_0.position.clone();\n            let p1 = node_1.position.clone();\n            let c0 = p0.clone().add(node_0.direction.clone().divS(3));\n            let c1 = p1.clone().sub(node_1.direction.clone().divS(3));\n            beziers.push(new _CubicBezier_js__WEBPACK_IMPORTED_MODULE_1__.CubicBezier(p0, c0, c1, p1));\n        }\n        return new _CubicBezierSpline_js__WEBPACK_IMPORTED_MODULE_2__.CubicBezierSpline(beziers);\n    }\n    draw(ctx) {\n        this.getCubicBezierSpline().executeDraw(ctx);\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/HermiteSpline.js?");

/***/ }),

/***/ "./js/geometry/Hexagon.js":
/*!********************************!*\
  !*** ./js/geometry/Hexagon.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hexagon: () => (/* binding */ Hexagon)\n/* harmony export */ });\n/* harmony import */ var _math_HexVector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/HexVector.js */ \"./js/math/HexVector.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Polygon.js */ \"./js/geometry/Polygon.js\");\n\n\n\nclass Hexagon extends _Polygon_js__WEBPACK_IMPORTED_MODULE_2__.Polygon {\n    unit;\n    orientation;\n    display = false;\n    color = 'red';\n    constructor(position = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(), orientation = _math_HexVector_js__WEBPACK_IMPORTED_MODULE_0__.HexOrientation.pointy, unit = 1) {\n        super();\n        this.addTag('hexagon');\n        this.transform.translation.copy(position);\n        this.unit = unit;\n        this.orientation = orientation;\n    }\n    getLinear() {\n        let points = [];\n        let angleOffset = this.orientation === _math_HexVector_js__WEBPACK_IMPORTED_MODULE_0__.HexOrientation.pointy ? Math.PI / 6 : 0;\n        let radius = this.unit;\n        for (let i = 0; i < 6; i++) {\n            let angle = Math.PI / 3 * i + angleOffset;\n            points.push(new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(Math.cos(angle) * radius, Math.sin(angle) * radius));\n        }\n        return points;\n    }\n    static ctxPath(ctx, orientation, unit) {\n        let angleOffset = orientation === _math_HexVector_js__WEBPACK_IMPORTED_MODULE_0__.HexOrientation.pointy ? Math.PI / 6 : 0;\n        ctx.moveTo(Math.cos(angleOffset) * unit, Math.sin(angleOffset) * unit);\n        for (let i = 1; i < 7; i++) {\n            let angle = Math.PI / 3 * i + angleOffset;\n            ctx.lineTo(Math.cos(angle) * unit, Math.sin(angle) * unit);\n        }\n        ctx.closePath();\n    }\n    ctxPath(ctx) {\n        Hexagon.ctxPath(ctx, this.orientation, this.unit);\n    }\n    draw(ctx) {\n        if (!this.display)\n            return;\n        ctx.lineWidth = .1;\n        ctx.strokeStyle = this.color;\n        ctx.beginPath();\n        this.ctxPath(ctx);\n        ctx.stroke();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/Hexagon.js?");

/***/ }),

/***/ "./js/geometry/Polygon.js":
/*!********************************!*\
  !*** ./js/geometry/Polygon.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polygon: () => (/* binding */ Polygon)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/TransformMatrix.js */ \"./js/math/TransformMatrix.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _Ray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Ray.js */ \"./js/geometry/Ray.js\");\n/* harmony import */ var _Segment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Segment.js */ \"./js/geometry/Segment.js\");\n/* harmony import */ var clipper_lib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! clipper-lib */ \"./node_modules/clipper-lib/clipper.js\");\n\n\n\n\n\n\nglobalThis.ClipperLib = clipper_lib__WEBPACK_IMPORTED_MODULE_5__;\n\n/**\n * The Polygon represent a N point polygon\n * To work properly, it needs at least 3 point to close\n */\nclass Polygon extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    #points = [];\n    outer = [];\n    inners = [];\n    fill = false;\n    /**\n     * Create a new polygon using the given points\n     *\n     * @param points\n     */\n    constructor(outer = [], ...inners) {\n        super();\n        this.addTag('polygon');\n        this.outer = outer;\n        this.inners = inners;\n    }\n    static isClockwise(vectors) {\n        let sum = 0;\n        for (let index_0 = 0; index_0 < vectors.length; index_0++) {\n            let index_1 = (index_0 + 1) % vectors.length;\n            let vec_0 = vectors[index_0];\n            let vec_1 = vectors[index_1];\n            sum += ((vec_1.x - vec_0.x) * (vec_1.y + vec_0.y));\n        }\n        return sum > 0;\n    }\n    clone() {\n        return new Polygon([...this.outer], ...this.inners.map(inner => inner.map(vec => vec.clone())));\n    }\n    /**\n     * Returns a list of points, such that it represents the polygon with theorically no holes. Duplicates the first Vector at the end of the list for practical purposes\n     *\n     * @returns {Vector[]}\n     */\n    getLinear() {\n        let points = [...this.outer, this.outer[0]];\n        return points;\n    }\n    getWorldLinear() {\n        let matrix = this.getWorldTransformMatrix();\n        let points = this.getLinear();\n        return points.map(point => _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_1__.TransformMatrix.multVec(matrix, point));\n    }\n    /**\n     * Get the list of segments between the points in order\n     * Returns an empty list if there is only one point\n     *\n     * @returns {Segment[]}\n     */\n    getSegments() {\n        let segments = [];\n        let points = this.getLinear();\n        if (points.length < 3)\n            return segments;\n        for (let index = 0; index < points.length - 1; index++) {\n            segments.push(new _Segment_js__WEBPACK_IMPORTED_MODULE_4__.Segment(points[index].clone(), points[index + 1].clone()));\n        }\n        return segments;\n    }\n    getWorldSegment() {\n        let segments = [];\n        let points = this.getWorldLinear();\n        if (points.length < 2)\n            return segments;\n        for (let index = 0; index < points.length; index++) {\n            segments.push(new _Segment_js__WEBPACK_IMPORTED_MODULE_4__.Segment(points[index].clone(), points[(index + 1) % points.length].clone()));\n        }\n        return segments;\n    }\n    /**\n     * Draw the polygon\n     * Should not be called by the user\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    draw(ctx) {\n        if (this.outer.length < 3)\n            return;\n        ctx.fillStyle = ctx.strokeStyle = 'yellow';\n        ctx.lineWidth = .1;\n        this.path(ctx);\n        if (this.fill)\n            ctx.fill();\n        else\n            ctx.stroke();\n    }\n    path(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(this.outer[0].x, this.outer[0].y);\n        for (let index = 1; index <= this.outer.length; index++) {\n            ctx.lineTo(this.outer[index % this.outer.length].x, this.outer[index % this.outer.length].y);\n        }\n        ctx.closePath();\n        for (let inner of this.inners) {\n            ctx.moveTo(inner[0].x, inner[0].y);\n            for (let index = 1; index <= inner.length; index++)\n                ctx.lineTo(inner[index % inner.length].x, inner[index % inner.length].y);\n            ctx.closePath();\n        }\n    }\n    containsVector(vector) {\n        let segments = this.getSegments();\n        let count = 0;\n        let ray = new _Ray_js__WEBPACK_IMPORTED_MODULE_3__.Ray(vector, new _math_Vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector(1, 0));\n        for (let segment of segments)\n            if (ray.intersect(segment))\n                count++;\n        return (count & 1) === 1;\n    }\n    containsWorldVector(vector) {\n        let segments = this.getWorldSegment();\n        let count = 0;\n        let ray = new _Ray_js__WEBPACK_IMPORTED_MODULE_3__.Ray(vector, new _math_Vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector(1, 0));\n        for (let segment of segments)\n            if (ray.intersect(segment))\n                count++;\n        return (count & 1) === 1;\n    }\n    get clipperpaths() {\n        return [\n            this.outer.map(v => ({ X: v.x, Y: v.y })),\n            ...this.inners.map(vs => vs.map(v => ({ X: v.x, Y: v.y })))\n        ];\n    }\n    // set polybool(polybool: polybool) {\n    //     this.outer = polybool.regions[0].map(point => new Vector(...point))\n    //     this.inners = polybool.regions.slice(1).map(region => region.map(point => new Vector(...point)))\n    // }\n    static clip(sourcePaths, clippingPaths, clipType, subjectPolyFillType = window.ClipperLib.PolyFillType.pftEvenOdd, clipperPolyFillType = window.ClipperLib.PolyFillType.pftEvenOdd) {\n        let clipper = new window.ClipperLib.Clipper();\n        clipper.AddPaths(sourcePaths, window.ClipperLib.PolyType.ptSubject, true);\n        clipper.AddPaths(clippingPaths, window.ClipperLib.PolyType.ptClip, true);\n        let solution = [];\n        let success = clipper.Execute(clipType, solution, subjectPolyFillType, clipperPolyFillType);\n        return solution;\n    }\n    static union(source, clipper) {\n        return this.clip(source, clipper, window.ClipperLib.ClipType.ctUnion);\n    }\n    static intersect(source, clipper) {\n        return this.clip(source, clipper, window.ClipperLib.ClipType.ctIntersection);\n    }\n    static difference(source, clipper) {\n        return this.clip(source, clipper, window.ClipperLib.ClipType.ctDifference);\n    }\n    // static differenceRev(source: Polygon[], clipper: Polygon[]): Polygon[] {\n    //     return this.#clip(source, clipper, window.PolyBool.differenceRev)\n    // }\n    // static xor(source: Polygon[], clipper: Polygon[]): Polygon[] {\n    //     return this.#clip(source, clipper, window.PolyBool.xor)\n    // }\n    // Scale float to reduce precision loss\n    static deFloat(paths, precision = 6) {\n        let ratio = 10 ** precision;\n        return paths.map(region => region.map(point => ({\n            X: Math.round(point.X * ratio),\n            Y: Math.round(point.Y * ratio)\n        })));\n    }\n    static inFloat(paths, precision = 6) {\n        let ratio = 10 ** precision;\n        return paths.map(region => region.map(point => ({\n            X: point.X / ratio,\n            Y: point.Y / ratio\n        })));\n    }\n    static pathClipperPaths(ctx, clipperpaths) {\n        ctx.beginPath();\n        for (let clipperpath of clipperpaths) {\n            for (let [index, { X, Y }] of clipperpath.entries()) {\n                if (!index)\n                    ctx.moveTo(X, Y);\n                else\n                    ctx.lineTo(X, Y);\n            }\n            ctx.closePath();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/Polygon.js?");

/***/ }),

/***/ "./js/geometry/Ray.js":
/*!****************************!*\
  !*** ./js/geometry/Ray.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ray: () => (/* binding */ Ray)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n\n\nclass Ray extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    direction = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector();\n    constructor(position, direction) {\n        super();\n        this.transform.translation.copy(position);\n        this.direction = direction;\n    }\n    intersect(segment) {\n        let sega = segment.getWorldPosition(segment.a.clone());\n        let segb = segment.getWorldPosition(segment.b.clone());\n        let wp = this.getWorldPosition();\n        let wpdir = this.getWorldPosition(this.direction.clone().normalize());\n        let x1 = sega.x;\n        let y1 = sega.y;\n        let x2 = segb.x;\n        let y2 = segb.y;\n        let x3 = wp.x;\n        let y3 = wp.y;\n        let x4 = wpdir.x;\n        let y4 = wpdir.y;\n        let denum = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (denum === 0)\n            return null;\n        let t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denum;\n        let u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / denum;\n        if (t < 0 || t > 1 || u < 0)\n            return null;\n        return new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(x1 + t * (x2 - x1), y1 + t * (y2 - y1));\n    }\n    cast(segments) {\n        let result = null;\n        let length = 0;\n        for (let segment of segments) {\n            let intersect = this.intersect(segment);\n            if (intersect) {\n                let intersectLength = this.transform.translation.distanceTo(intersect);\n                if (result === null || intersectLength < length) {\n                    result = intersect;\n                    length = intersectLength;\n                }\n            }\n        }\n        return result;\n    }\n    draw(ctx) {\n        ctx.strokeStyle = 'blue';\n        ctx.strokeRect(-this.transform.scale.x, -this.transform.scale.y, this.transform.scale.x * 2, this.transform.scale.y * 2);\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(this.direction.x * this.transform.scale.x * 5, this.direction.y * this.transform.scale.y * 5);\n        ctx.stroke();\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/Ray.js?");

/***/ }),

/***/ "./js/geometry/RayCastView.js":
/*!************************************!*\
  !*** ./js/geometry/RayCastView.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RayCastView: () => (/* binding */ RayCastView)\n/* harmony export */ });\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Polygon.js */ \"./js/geometry/Polygon.js\");\n/* harmony import */ var _Ray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Ray.js */ \"./js/geometry/Ray.js\");\n/* harmony import */ var _Segment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Segment.js */ \"./js/geometry/Segment.js\");\n\n\n\n\nclass RayCastView {\n    static compute(position, segments, infinity = 1000, infinityPoints = 4, centeredOnPosition = true) {\n        let border = [];\n        infinityPoints = Math.max(infinityPoints, 4);\n        for (let index = 0; index < infinityPoints; index++)\n            border.push(_math_Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector.fromAngle(Math.PI * 2 / infinityPoints * index + Math.PI / 4).multS(infinity).add(centeredOnPosition ? position : new _math_Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector()));\n        segments = [...segments];\n        for (let index = 0; index < infinityPoints; index++)\n            segments.push(new _Segment_js__WEBPACK_IMPORTED_MODULE_3__.Segment(border[index], border[(index + 1) % infinityPoints]));\n        let uniques = [];\n        for (let segment of segments) {\n            let sega = segment.getWorldPosition(segment.a.clone());\n            let segb = segment.getWorldPosition(segment.b.clone());\n            if (!uniques.some(pt => pt.equal(sega)))\n                uniques.push(sega);\n            if (!uniques.some(pt => pt.equal(segb)))\n                uniques.push(segb);\n        }\n        let points = [];\n        for (let unique of uniques) {\n            let angle = unique.clone().sub(position).angle();\n            let delta = 0.00001;\n            let angle1 = angle + delta;\n            let angle2 = angle - delta;\n            let ray = new _Ray_js__WEBPACK_IMPORTED_MODULE_2__.Ray(position.clone(), _math_Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector.fromAngle(angle));\n            let ray1 = new _Ray_js__WEBPACK_IMPORTED_MODULE_2__.Ray(position.clone(), _math_Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector.fromAngle(angle1));\n            let ray2 = new _Ray_js__WEBPACK_IMPORTED_MODULE_2__.Ray(position.clone(), _math_Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector.fromAngle(angle2));\n            let pt = ray.cast(segments);\n            let pt1 = ray1.cast(segments);\n            let pt2 = ray2.cast(segments);\n            points.push([angle, pt ?? position.clone().add(ray.direction.multS(infinity)), pt?.clone().sub(position) ?? ray.direction]);\n            points.push([angle1, pt1 ?? position.clone().add(ray1.direction.multS(infinity)), pt1?.clone().sub(position) ?? ray1.direction]);\n            points.push([angle2, pt2 ?? position.clone().add(ray2.direction.multS(infinity)), pt2?.clone().sub(position) ?? ray2.direction]);\n        }\n        points.sort((a, b) => b[0] - a[0]);\n        let polygon = new _Polygon_js__WEBPACK_IMPORTED_MODULE_1__.Polygon(points.map(e => e[2].add(position)));\n        return polygon;\n    }\n    static cropPolygon(ctx, polygon) {\n        let points = polygon.getLinear();\n        if (points.length < 4)\n            return;\n        ctx.globalCompositeOperation = 'destination-in';\n        ctx.fillStyle = 'white';\n        ctx.beginPath();\n        ctx.moveTo(points[0].x, points[0].y);\n        for (let index = 1; index < points.length - 1; index++)\n            ctx.lineTo(points[index].x, points[index].y);\n        ctx.fill();\n        ctx.globalCompositeOperation = 'source-over';\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/RayCastView.js?");

/***/ }),

/***/ "./js/geometry/Rectangle.js":
/*!**********************************!*\
  !*** ./js/geometry/Rectangle.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rectangle: () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Polygon.js */ \"./js/geometry/Polygon.js\");\n\n\n\n/**\n *\n */\nclass Rectangle extends _Polygon_js__WEBPACK_IMPORTED_MODULE_2__.Polygon {\n    display = false;\n    displayColor = 'red';\n    #ptmem = [new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(), new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector()];\n    constructor(x = 0, y = 0, w = 1, h = 1, display = false, displayColor = 'red') {\n        super([], []);\n        this.addTag('rectangle');\n        this.transform.translation.set(x, y);\n        this.transform.scale.set(w, h);\n        this.#ptmem[0].copy(this.transform.translation);\n        this.#ptmem[1].copy(this.transform.scale);\n        this.display = display;\n        this.displayColor = displayColor;\n    }\n    getLinear() {\n        if (this.outer.length === 0 || !this.#ptmem[0].equal(this.transform.translation) || !this.#ptmem[1].equal(this.transform.scale)) {\n            this.outer = [this.bottomleft, this.topleft, this.topright, this.bottomright];\n            this.#ptmem[0].copy(this.transform.translation);\n            this.#ptmem[1].copy(this.transform.scale);\n        }\n        return super.getLinear();\n    }\n    getWorldLinear() {\n        let matrix = this.parent?.getWorldTransformMatrix() ?? _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.TransformMatrix.default();\n        let points = this.getLinear();\n        return points.map(point => _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.TransformMatrix.multVec(matrix, point));\n    }\n    get x() { return this.transform.translation.x; }\n    set x(n) { this.transform.translation.x = n; }\n    get y() { return this.transform.translation.y; }\n    set y(n) { this.transform.translation.y = n; }\n    get w() { return this.transform.scale.x; }\n    set w(n) { this.transform.scale.x = n; }\n    get h() { return this.transform.scale.y; }\n    set h(n) { this.transform.scale.y = n; }\n    get halfW() { return this.transform.scale.x / 2; }\n    set halfW(n) { this.transform.scale.x = n * 2; }\n    get halfH() { return this.transform.scale.y / 2; }\n    set halfH(n) { this.transform.scale.y = n * 2; }\n    get left() { return this.transform.translation.x - this.halfW; }\n    set left(n) { this.transform.translation.x = n + this.halfW; }\n    get right() { return this.transform.translation.x + this.halfW; }\n    set right(n) { this.transform.translation.x = n - this.halfW; }\n    get bottom() { return this.transform.translation.y - this.halfH; }\n    set bottom(n) { this.transform.translation.y = n + this.halfH; }\n    get top() { return this.transform.translation.y + this.halfH; }\n    set top(n) { this.transform.translation.y = n - this.halfH; }\n    get topleft() { return new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(this.left, this.top); }\n    set topleft(v) { this.left = v.x; this.top = v.y; }\n    get bottomleft() { return new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(this.left, this.bottom); }\n    set bottomleft(v) { this.left = v.x; this.bottom = v.y; }\n    get topright() { return new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(this.right, this.top); }\n    set topright(v) { this.right = v.x; this.top = v.y; }\n    get bottomright() { return new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(this.right, this.bottom); }\n    set bottomright(v) { this.right = v.x; this.bottom = v.y; }\n    contains(vector) { return vector.x <= this.right && vector.x >= this.left && vector.y <= this.top && vector.y >= this.bottom; }\n    collide(rect) {\n        return this.left < rect.right &&\n            rect.left < this.right &&\n            this.bottom < rect.top &&\n            rect.bottom < this.top;\n    }\n    draw(ctx) {\n        if (this.display) {\n            ctx.save();\n            // ctx.scale(1 / this.w, 1 / this.h)\n            if (this.fill) {\n                ctx.fillStyle = this.displayColor;\n                ctx.fillRect(-.5, -.5, 1, 1);\n            }\n            else {\n                ctx.lineWidth = .05;\n                ctx.strokeStyle = this.displayColor;\n                ctx.strokeRect(-.5, -.5, 1, 1);\n            }\n            ctx.restore();\n        }\n        return true;\n    }\n    clone() {\n        return new Rectangle(this.x, this.y, this.w, this.h);\n    }\n    copy(rectangle) {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.w = rectangle.w;\n        this.h = rectangle.h;\n        return this;\n    }\n    toString() {\n        return `Rectangle(${this.x}, ${this.y}, ${this.w}, ${this.h})`;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/Rectangle.js?");

/***/ }),

/***/ "./js/geometry/Segment.js":
/*!********************************!*\
  !*** ./js/geometry/Segment.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Segment: () => (/* binding */ Segment)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n\n\nconst PI_DIV_2 = Math.PI / 2;\nclass Segment extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    a = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector();\n    b = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector();\n    display = false;\n    lineWidth = 1;\n    constructor(a, b, display = false) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.display = display;\n    }\n    intersect(segment) {\n        let seg1a = segment.getWorldPosition(segment.a.clone());\n        let seg1b = segment.getWorldPosition(segment.b.clone());\n        let seg2a = this.getWorldPosition(this.a.clone());\n        let seg2b = this.getWorldPosition(this.b.clone());\n        let x1 = seg1a.x;\n        let y1 = seg1a.y;\n        let x2 = seg1b.x;\n        let y2 = seg1b.y;\n        let x3 = seg2a.x;\n        let y3 = seg2a.y;\n        let x4 = seg2b.x;\n        let y4 = seg2b.y;\n        let denum = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (denum === 0)\n            return null;\n        let t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denum;\n        let u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / denum;\n        if (t < 0 || t > 1 || u < 0 || u > 1)\n            return null;\n        return new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector(x1 + t * (x2 - x1), y1 + t * (y2 - y1));\n    }\n    directionVector() {\n        return this.b.clone().sub(this.a).normalize();\n    }\n    project(point) {\n        return point.projectOn(this.directionVector());\n    }\n    length() {\n        return this.a.distanceTo(this.b);\n    }\n    draw(ctx) {\n        if (this.display) {\n            ctx.strokeStyle = 'red';\n            ctx.beginPath();\n            ctx.lineWidth = this.lineWidth;\n            ctx.moveTo(this.a.x, this.a.y);\n            ctx.lineTo(this.b.x, this.b.y);\n            ctx.stroke();\n        }\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/geometry/Segment.js?");

/***/ }),

/***/ "./js/gui/Button.js":
/*!**************************!*\
  !*** ./js/gui/Button.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _geometry_Rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/Rectangle.js */ \"./js/geometry/Rectangle.js\");\n/* harmony import */ var _math_Timer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Timer.js */ \"./js/math/Timer.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils.js */ \"./js/gui/Utils.js\");\n\n\n\n\n\nclass Button extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject {\n    text = '';\n    #active = new _math_Timer_js__WEBPACK_IMPORTED_MODULE_3__.Timer(0);\n    rect = new _geometry_Rectangle_js__WEBPACK_IMPORTED_MODULE_2__.Rectangle(0, 0, 1, 1);\n    get active() { return this.#active.lessThan(150); }\n    options = {};\n    color = 'white';\n    activeColor = 'gray';\n    onSound;\n    constructor(text, options = {}, onSound = null, margin = 0) {\n        super();\n        this.text = text;\n        this.options = options;\n        this.onSound = onSound;\n        this.position.set(options.posX ?? 0, options.posY ?? 0);\n        options.posX = 0;\n        options.posY = 0;\n        this.rect.transform.scale.set((options.maxWidth ?? 100) * 1.1 + margin, (options.size ?? 16) * 1.1 + margin);\n        if (options.align === 'right')\n            this.rect.x = -this.rect.w / 2;\n        if (options.align === 'left')\n            this.rect.x = this.rect.w / 2;\n        this.add(this.rect);\n        this.drawAfterChildren();\n    }\n    get currentColor() { return (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.resolveStringable)(this.active ? this.activeColor : this.color); }\n    update(dt) {\n        let mouse = this.input.mouse;\n        if (mouse.leftClick) {\n            if (this.rect.containsWorldVector(mouse.position) && !this.active) {\n                this.#active.reset();\n                this.onClick();\n                if (this.onSound)\n                    this.engine.soundBank.get(this.onSound)?.play();\n            }\n        }\n        if (this.active)\n            this.rect.displayColor = 'blue';\n        else\n            this.rect.displayColor = 'red';\n    }\n    onClick() { }\n    draw(ctx) {\n        (0,_Utils_js__WEBPACK_IMPORTED_MODULE_4__.drawText)(ctx, this.text, this.options);\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/Button.js?");

/***/ }),

/***/ "./js/gui/Checkbox.js":
/*!****************************!*\
  !*** ./js/gui/Checkbox.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckBox: () => (/* binding */ CheckBox)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _geometry_Rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/Rectangle.js */ \"./js/geometry/Rectangle.js\");\n\n\n\nclass CheckBox extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject {\n    checked = false;\n    rect = new _geometry_Rectangle_js__WEBPACK_IMPORTED_MODULE_2__.Rectangle(0, 0, 1, 1);\n    options = {};\n    sound;\n    constructor(checked = false, options = {}, sound = null) {\n        super();\n        this.checked = checked;\n        this.options = options;\n        this.sound = sound;\n        this.position.set(options.posX ?? 0, options.posY ?? 0);\n        options.posX = 0;\n        options.posY = 0;\n        let size = this.options.size ?? 1;\n        this.rect.transform.scale.set(size, size);\n        this.add(this.rect);\n    }\n    update(dt) {\n        let mouse = this.input.mouse;\n        if (this.rect.containsWorldVector(mouse.position) && mouse.leftClick) {\n            this.checked = !this.checked;\n            this.onChange();\n            if (this.sound)\n                this.engine.soundBank.get(this.sound)?.play();\n        }\n    }\n    onChange() { }\n    draw(ctx) {\n        let size = this.options.size ?? 1;\n        let hs = size / 2;\n        ctx.lineWidth = this.options.lineWidth ?? .1;\n        if (this.checked) {\n            ctx.strokeStyle = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.resolveStringable)(this.options.outlineColor ?? 'black');\n            ctx.beginPath();\n            ctx.moveTo(-hs, -hs);\n            ctx.lineTo(hs, hs);\n            ctx.moveTo(-hs, hs);\n            ctx.lineTo(hs, -hs);\n            ctx.stroke();\n        }\n        ctx.strokeStyle = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.resolveStringable)(this.options.color ?? 'black');\n        ctx.strokeRect(-hs, -hs, size, size);\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/Checkbox.js?");

/***/ }),

/***/ "./js/gui/ColorPicker.js":
/*!*******************************!*\
  !*** ./js/gui/ColorPicker.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColorPicker: () => (/* binding */ ColorPicker)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\nconst ctx = document.createElement('canvas').getContext('2d');\nconst rainbow = ctx.createLinearGradient(-1, 0, .5, 0);\nrainbow.addColorStop(0, 'hsl(0, 100%, 50%');\nrainbow.addColorStop(1 / 6, 'hsl(60, 100%, 50%');\nrainbow.addColorStop(1 / 3, 'hsl(120, 100%, 50%');\nrainbow.addColorStop(1 / 2, 'hsl(180, 100%, 50%');\nrainbow.addColorStop(2 / 3, 'hsl(240, 100%, 50%');\nrainbow.addColorStop(5 / 6, 'hsl(300, 100%, 50%');\nrainbow.addColorStop(1, 'hsl(360, 100%, 50%');\nlet textboxOptions = {\n    size: .15,\n    font: 'sans-serif',\n    color: 'black',\n    outlineColor: 'white',\n    lineWidth: 0.1,\n    maxWidth: .4,\n    align: 'center',\n    baseline: 'middle'\n};\nclass ColorPicker extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    color = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Color();\n    htb = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.TextBox('0', textboxOptions);\n    stb = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.TextBox('100', textboxOptions);\n    ltb = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.TextBox('50', textboxOptions);\n    constructor() {\n        super();\n        this.color.HSL = [0, 100, 50];\n        this.htb.transform.translation.set(.75, 0.375);\n        this.htb.onChange = (str) => {\n            if (!isNaN(parseInt(str)))\n                this.color.h = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, parseInt(str), 360);\n            this.htb.text = this.color.h.toString();\n            this.onChange(this.color.clone());\n        };\n        this.add(this.htb);\n        this.stb.transform.translation.set(.75, 0.125);\n        this.stb.onChange = (str) => {\n            if (!isNaN(parseInt(str)))\n                this.color.s = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, parseInt(str), 100);\n            this.stb.text = this.color.s.toString();\n            this.onChange(this.color.clone());\n        };\n        this.add(this.stb);\n        this.ltb.transform.translation.set(.75, -0.125);\n        this.ltb.onChange = (str) => {\n            if (!isNaN(parseInt(str)))\n                this.color.l = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.minmax)(0, parseInt(str), 100);\n            this.ltb.text = this.color.l.toString();\n            this.onChange(this.color.clone());\n        };\n        this.add(this.ltb);\n    }\n    onChange(color) { }\n    update(dt) {\n        let mouse = this.input.mouse;\n        let rect = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 2.5, 1);\n        rect.parent = this;\n        if ((mouse.left || mouse.leftClick) && rect.containsWorldVector(mouse.position)) {\n            let wtm = this.getWorldTransformMatrix();\n            rect.w = 1.5;\n            rect.h = .125;\n            rect.left = -1;\n            rect.bottom = 0.3125;\n            let left = _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.TransformMatrix.multVec(wtm, new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(rect.left, rect.y));\n            let right = _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.TransformMatrix.multVec(wtm, new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(rect.right, rect.y));\n            let p = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Segment(left, right).project(mouse.position);\n            let t = 0;\n            if (p.distanceTo(right) > left.distanceTo(right))\n                t = 0;\n            else if (p.distanceTo(left) > left.distanceTo(right))\n                t = 0;\n            else\n                t = p.distanceTo(left) / left.distanceTo(right);\n            if (rect.containsWorldVector(mouse.position) && !mouse.leftClick) {\n                this.color.h = Math.round(360 * t);\n                this.htb.text = this.color.h.toString();\n                return;\n            }\n            rect.bottom = 0.0625;\n            if (rect.containsWorldVector(mouse.position) && !mouse.leftClick) {\n                this.color.s = Math.round(100 * t);\n                this.stb.text = this.color.s.toString();\n                return;\n            }\n            rect.bottom = -0.1875;\n            if (rect.containsWorldVector(mouse.position) && !mouse.leftClick) {\n                this.color.l = Math.round(100 * t);\n                this.ltb.text = this.color.l.toString();\n                return;\n            }\n            if (mouse.leftClick)\n                this.onChange(this.color.clone());\n        }\n    }\n    draw(ctx) {\n        ctx.strokeStyle = 'black';\n        ctx.lineWidth = .01;\n        ctx.fillStyle = rainbow;\n        ctx.fillRect(-1, 0.3125, 1.5, .125);\n        const saturation = ctx.createLinearGradient(-1, 0, .5, 0);\n        saturation.addColorStop(0, `hsl(${this.color.h}, 0%, ${this.color.l}%)`);\n        saturation.addColorStop(1, `hsl(${this.color.h}, 100%, ${this.color.l}%)`);\n        ctx.fillStyle = saturation;\n        ctx.fillRect(-1, 0.0625, 1.5, .125);\n        const lightness = ctx.createLinearGradient(-1, 0, .5, 0);\n        lightness.addColorStop(0, `hsl(${this.color.h}, ${this.color.s}%, 0%)`);\n        lightness.addColorStop(.5, `hsl(${this.color.h}, ${this.color.s}%, 50%)`);\n        lightness.addColorStop(1, `hsl(${this.color.h}, ${this.color.s}%, 100%)`);\n        ctx.fillStyle = lightness;\n        ctx.fillRect(-1, -0.1875, 1.5, .125);\n        ctx.fillStyle = this.color.toString();\n        ctx.fillRect(-1, -0.4375, 1.5, .125);\n        let h = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.map)(Number(this.color.h), 0, 360, -1, .5);\n        let s = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.map)(Number(this.color.s), 0, 100, -1, .5);\n        let l = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.map)(Number(this.color.l), 0, 100, -1, .5);\n        ctx.beginPath();\n        ctx.moveTo(h, .5);\n        ctx.lineTo(h, .25);\n        ctx.moveTo(s, .25);\n        ctx.lineTo(s, 0);\n        ctx.moveTo(l, 0);\n        ctx.lineTo(l, -.25);\n        ctx.stroke();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/ColorPicker.js?");

/***/ }),

/***/ "./js/gui/FPSCounter.js":
/*!******************************!*\
  !*** ./js/gui/FPSCounter.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FPSCounter: () => (/* binding */ FPSCounter)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _math_Timer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Timer.js */ \"./js/math/Timer.js\");\n\n\n/**\n * The FPSCounter class is, as its name says, used to display the number of FPS of the game on the top left corner of the screen in a given font size\n */\nclass FPSCounter extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    timer = new _math_Timer_js__WEBPACK_IMPORTED_MODULE_1__.Timer();\n    frameCount = 0;\n    fps = 0;\n    fontSize = 12;\n    /**\n     * Create a new FPSCounter with a given font size\n     *\n     * @param fontsize\n     */\n    constructor(fontsize = 10) {\n        super();\n        this.fontSize = fontsize;\n    }\n    /**\n     * Update the timer\n     * Should not be called by the user\n     *\n     * @param {number} dt\n     * @returns {boolean}\n     */\n    update(dt) {\n        this.frameCount++;\n        if (this.timer.greaterThan(1000)) {\n            this.fps = this.frameCount;\n            this.frameCount = 0;\n            this.timer.reset();\n        }\n        return true;\n    }\n    /**\n     * Draw the timer on the top left corner\n     * Should not be called by the user\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @return {boolean}\n     */\n    draw(ctx) {\n        ctx.save();\n        let engine = this.engine;\n        ctx.translate(-engine.usableWidth / 2, engine.usableHeight / 2);\n        ctx.scale(1, -1);\n        ctx.font = `${this.fontSize}px sans-serif`;\n        ctx.fillStyle = 'red';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        ctx.fillText(this.fps.toString(), this.fontSize / 2, this.fontSize / 2);\n        ctx.restore();\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/FPSCounter.js?");

/***/ }),

/***/ "./js/gui/GamepadDisplay.js":
/*!**********************************!*\
  !*** ./js/gui/GamepadDisplay.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GamepadDisplay: () => (/* binding */ GamepadDisplay)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basics/Input.js */ \"./js/basics/Input.js\");\n/* harmony import */ var _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/TransformMatrix.js */ \"./js/math/TransformMatrix.js\");\n/* harmony import */ var _math_Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Utils.js */ \"./js/math/Utils.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n\n\n\n\n\nconst minRange = .2;\nclass InputButton extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    button = 'left_button';\n    text = 'LB';\n    constructor(button, text) {\n        super();\n        this.button = button;\n        this.text = text;\n        this.transform.scale.set(.1, .1);\n    }\n    update(dt) {\n        let input = this.input;\n        let mouse = input.mouse;\n        if (mouse.leftClick) {\n            if (input.getRecording())\n                return;\n            let wtm = this.getWorldTransformMatrix();\n            let myPosition = _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_2__.TransformMatrix.multVec(wtm, new _math_Vector_js__WEBPACK_IMPORTED_MODULE_4__.Vector());\n            let range = _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_2__.TransformMatrix.multVec(wtm, new _math_Vector_js__WEBPACK_IMPORTED_MODULE_4__.Vector(.5, 0)).distanceTo(myPosition);\n            let delta = mouse.position.clone().sub(myPosition);\n            let mouseToCenter = delta.length();\n            if (mouseToCenter < range) {\n                if (input.getGamepadControlAccess(_basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[this.button]))\n                    input.unsetGamepadControl(_basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[this.button]);\n                else\n                    input.recordGamepadControl(_basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[this.button]);\n            }\n        }\n    }\n    draw(ctx) {\n        let input = this.input;\n        let gamepad = input.gamepad;\n        let defined = input.getDefinedGamepadControls();\n        let recording = input.getRecording();\n        ctx.strokeStyle = 'black';\n        ctx.fillStyle = '#30303030';\n        ctx.beginPath();\n        ctx.arc(0, 0, .5, 0, 2 * Math.PI);\n        ctx.fill();\n        let button = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[this.button];\n        if (defined.includes(button)) {\n            let range = (0,_math_Utils_js__WEBPACK_IMPORTED_MODULE_3__.map)(gamepad[this.button], 0, 1, 0, .5);\n            ctx.fillStyle = '#00ff00';\n            ctx.beginPath();\n            ctx.arc(0, 0, range, 0, Math.PI * 2, true);\n            ctx.fill();\n        }\n        else {\n            if (recording === button)\n                ctx.fillStyle = '#0000ff30';\n            else\n                ctx.fillStyle = '#ff000030';\n            ctx.beginPath();\n            ctx.arc(0, 0, .5, 0, Math.PI * 2, true);\n            ctx.fill();\n        }\n        ctx.strokeStyle = 'black';\n        ctx.fillStyle = '#30303030';\n        ctx.lineWidth = .025;\n        ctx.beginPath();\n        ctx.arc(0, 0, .5, 0, 2 * Math.PI);\n        ctx.stroke();\n        ctx.save();\n        ctx.scale(.5, -.5);\n        ctx.fillStyle = 'black';\n        ctx.font = '1px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(this.text, 0, 0);\n        ctx.restore();\n    }\n}\nclass JoystickDisplay extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    joystick = 'left_joystick';\n    constructor(joystick) {\n        super();\n        this.joystick = joystick;\n        this.transform.scale.set(.2, .2);\n    }\n    update(dt) {\n        let input = this.input;\n        let mouse = input.mouse;\n        if (mouse.leftClick) {\n            if (input.getRecording())\n                return;\n            let wtm = this.getWorldTransformMatrix();\n            let myPosition = _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_2__.TransformMatrix.multVec(wtm, new _math_Vector_js__WEBPACK_IMPORTED_MODULE_4__.Vector());\n            let range = _math_TransformMatrix_js__WEBPACK_IMPORTED_MODULE_2__.TransformMatrix.multVec(wtm, new _math_Vector_js__WEBPACK_IMPORTED_MODULE_4__.Vector(.5, 0)).distanceTo(myPosition);\n            let delta = mouse.position.clone().sub(myPosition);\n            let mouseToCenter = delta.length();\n            if (mouseToCenter < range) {\n                if (mouseToCenter > range * minRange) {\n                    let control = -1;\n                    if (Math.abs(delta.x) > Math.abs(delta.y))\n                        if (delta.x > 0)\n                            control = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_right_dir`];\n                        else\n                            control = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_left_dir`];\n                    else if (delta.y > 0)\n                        control = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_up_dir`];\n                    else\n                        control = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_down_dir`];\n                    if (input.getGamepadControlAccess(control))\n                        input.unsetGamepadControl(control);\n                    else\n                        input.recordGamepadControl(control);\n                }\n                else {\n                    if (input.getGamepadControlAccess(_basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_button`]))\n                        input.unsetGamepadControl(_basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_button`]);\n                    else\n                        input.recordGamepadControl(_basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_button`]);\n                }\n            }\n        }\n    }\n    draw(ctx) {\n        let input = this.input;\n        let gamepad = input.gamepad;\n        let defined = input.getDefinedGamepadControls();\n        let recording = input.getRecording();\n        ctx.strokeStyle = 'black';\n        ctx.fillStyle = '#30303030';\n        ctx.beginPath();\n        ctx.arc(0, 0, .5, 0, 2 * Math.PI);\n        ctx.fill();\n        let right = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_right_dir`];\n        if (defined.includes(right)) {\n            let range = (0,_math_Utils_js__WEBPACK_IMPORTED_MODULE_3__.map)(gamepad[`${this.joystick}_right_dir`], 0, 1, minRange, .5);\n            ctx.fillStyle = '#00ff00';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, Math.PI / 4, -Math.PI / 4, true);\n            ctx.arc(0, 0, range, -Math.PI / 4, Math.PI / 4);\n            ctx.fill();\n        }\n        else {\n            if (recording === right)\n                ctx.fillStyle = '#0000ff30';\n            else\n                ctx.fillStyle = '#ff000030';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, Math.PI / 4, -Math.PI / 4, true);\n            ctx.arc(0, 0, .5, -Math.PI / 4, Math.PI / 4);\n            ctx.fill();\n        }\n        let left = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_left_dir`];\n        if (defined.includes(left)) {\n            let range = (0,_math_Utils_js__WEBPACK_IMPORTED_MODULE_3__.map)(gamepad[`${this.joystick}_left_dir`], 0, 1, minRange, .5);\n            ctx.fillStyle = '#00ff00';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, Math.PI + Math.PI / 4, Math.PI + -Math.PI / 4, true);\n            ctx.arc(0, 0, range, Math.PI + -Math.PI / 4, Math.PI + Math.PI / 4);\n            ctx.fill();\n        }\n        else {\n            if (recording === left)\n                ctx.fillStyle = '#0000ff30';\n            else\n                ctx.fillStyle = '#ff000030';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, Math.PI + Math.PI / 4, Math.PI + -Math.PI / 4, true);\n            ctx.arc(0, 0, .5, Math.PI + -Math.PI / 4, Math.PI + Math.PI / 4);\n            ctx.fill();\n        }\n        let up = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_up_dir`];\n        if (defined.includes(up)) {\n            let range = (0,_math_Utils_js__WEBPACK_IMPORTED_MODULE_3__.map)(gamepad[`${this.joystick}_up_dir`], 0, 1, minRange, .5);\n            ctx.fillStyle = '#00ff00';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, Math.PI / 2 + Math.PI / 4, Math.PI / 2 + -Math.PI / 4, true);\n            ctx.arc(0, 0, range, Math.PI / 2 + -Math.PI / 4, Math.PI / 2 + Math.PI / 4);\n            ctx.fill();\n        }\n        else {\n            if (recording === up)\n                ctx.fillStyle = '#0000ff30';\n            else\n                ctx.fillStyle = '#ff000030';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, Math.PI / 2 + Math.PI / 4, Math.PI / 2 + -Math.PI / 4, true);\n            ctx.arc(0, 0, .5, Math.PI / 2 + -Math.PI / 4, Math.PI / 2 + Math.PI / 4);\n            ctx.fill();\n        }\n        let down = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_down_dir`];\n        if (defined.includes(down)) {\n            let range = (0,_math_Utils_js__WEBPACK_IMPORTED_MODULE_3__.map)(gamepad[`${this.joystick}_down_dir`], 0, 1, minRange, .5);\n            ctx.fillStyle = '#00ff00';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, -Math.PI / 2 + Math.PI / 4, -Math.PI / 2 + -Math.PI / 4, true);\n            ctx.arc(0, 0, range, -Math.PI / 2 + -Math.PI / 4, -Math.PI / 2 + Math.PI / 4);\n            ctx.fill();\n        }\n        else {\n            if (recording === down)\n                ctx.fillStyle = '#0000ff30';\n            else\n                ctx.fillStyle = '#ff000030';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, -Math.PI / 2 + Math.PI / 4, -Math.PI / 2 + -Math.PI / 4, true);\n            ctx.arc(0, 0, .5, -Math.PI / 2 + -Math.PI / 4, -Math.PI / 2 + Math.PI / 4);\n            ctx.fill();\n        }\n        let button = _basics_Input_js__WEBPACK_IMPORTED_MODULE_1__.GamepadControl[`${this.joystick}_button`];\n        if (defined.includes(button)) {\n            let range = (0,_math_Utils_js__WEBPACK_IMPORTED_MODULE_3__.map)(gamepad[`${this.joystick}_button`], 0, 1, 0, minRange);\n            ctx.fillStyle = '#00ff00';\n            ctx.beginPath();\n            ctx.arc(0, 0, range, 0, Math.PI * 2, true);\n            ctx.fill();\n        }\n        else {\n            if (recording === button)\n                ctx.fillStyle = '#0000ff30';\n            else\n                ctx.fillStyle = '#ff000030';\n            ctx.beginPath();\n            ctx.arc(0, 0, minRange, 0, Math.PI * 2, true);\n            ctx.fill();\n        }\n        ctx.strokeStyle = 'black';\n        ctx.fillStyle = '#30303030';\n        ctx.lineWidth = .025;\n        ctx.beginPath();\n        ctx.arc(0, 0, minRange, 0, 2 * Math.PI);\n        ctx.stroke();\n        ctx.lineWidth = .025;\n        ctx.beginPath();\n        ctx.arc(0, 0, .5, 0, 2 * Math.PI);\n        ctx.stroke();\n    }\n}\nclass GamepadDisplay extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    leftJoystick = new JoystickDisplay('left_joystick');\n    rightJoystick = new JoystickDisplay('right_joystick');\n    buttonLeft = new InputButton('left_button', 'LB');\n    buttonRight = new InputButton('right_button', 'RB');\n    triggerLeft = new InputButton('left_trigger', 'LT');\n    triggerRight = new InputButton('right_trigger', 'RT');\n    up = new InputButton('button_up_arrow', '^');\n    down = new InputButton('button_down_arrow', 'v');\n    left = new InputButton('button_left_arrow', '<');\n    right = new InputButton('button_right_arrow', '>');\n    A = new InputButton('button_A', 'A');\n    B = new InputButton('button_B', 'B');\n    X = new InputButton('button_X', 'X');\n    Y = new InputButton('button_Y', 'Y');\n    back = new InputButton('button_back', 'B');\n    home = new InputButton('button_home', 'H');\n    start = new InputButton('button_start', 'S');\n    calibrationMessage;\n    noController;\n    constructor(calibrationMessage, noController) {\n        super();\n        this.calibrationMessage = calibrationMessage;\n        this.noController = noController;\n        this.leftJoystick.transform.translation.set(-.3, 0);\n        this.rightJoystick.transform.translation.set(.2, -.3);\n        this.buttonLeft.transform.translation.set(-.3, .2);\n        this.buttonRight.transform.translation.set(.3, .2);\n        this.triggerLeft.transform.translation.set(-.3, .3);\n        this.triggerRight.transform.translation.set(.3, .3);\n        this.up.transform.translation.set(-.2, -.225);\n        this.down.transform.translation.set(-.2, -.375);\n        this.left.transform.translation.set(-.275, -.3);\n        this.right.transform.translation.set(-.125, -.3);\n        this.Y.transform.translation.set(.3, .075);\n        this.A.transform.translation.set(.3, -.075);\n        this.B.transform.translation.set(.375, 0);\n        this.X.transform.translation.set(.225, 0);\n        this.back.transform.translation.set(-.075, .1);\n        this.home.transform.translation.set(0, .175);\n        this.start.transform.translation.set(.075, .1);\n        this.add(this.leftJoystick, this.rightJoystick);\n        this.add(this.buttonLeft, this.buttonRight);\n        this.add(this.triggerLeft, this.triggerRight);\n        this.add(this.up, this.down, this.left, this.right);\n        this.add(this.A, this.B, this.X, this.Y);\n        this.add(this.back, this.home, this.start);\n    }\n    states = [];\n    update(dt) {\n        let input = this.input;\n        let gamepad = input.gamepad;\n        this.childrenDrawEnabled = gamepad.is_calibrated;\n        if (gamepad.has_gamepad && !gamepad.is_calibrated && !gamepad.is_calibrating) {\n            input.calibrateGamepad((states) => {\n                this.states = states;\n            });\n        }\n    }\n    draw(ctx) {\n        if (!this.input.gamepad.has_gamepad) {\n            ctx.save();\n            ctx.scale(1 / 20, -1 / 20);\n            ctx.fillStyle = 'gray';\n            ctx.font = '1px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(this.noController, 0, 0);\n            ctx.restore();\n        }\n        if (this.input.isGamepadCalibrating) {\n            let radius = .2;\n            if (this.states.length > 0) {\n                let s0 = this.states.filter(e => e === 0).length;\n                let s1 = this.states.filter(e => e === 1).length;\n                let s2 = this.states.filter(e => e === 2).length;\n                let section = 1 / this.states.length * 2 * Math.PI;\n                ctx.fillStyle = 'lime';\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.arc(0, 0, radius, Math.PI / 2, Math.PI / 2 - s2 * section, true);\n                ctx.fill();\n                ctx.fillStyle = 'blue';\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.arc(0, 0, radius, Math.PI / 2 - s2 * section, Math.PI / 2 - s2 * section - s1 * section, true);\n                ctx.fill();\n                ctx.fillStyle = 'red';\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.arc(0, 0, radius, Math.PI / 2 - s2 * section - s1 * section, Math.PI / 2 - s2 * section - s1 * section - s0 * section, true);\n                ctx.fill();\n            }\n            else {\n                ctx.fillStyle = 'red';\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.arc(0, 0, radius, 0, Math.PI * 2, false);\n                ctx.fill();\n            }\n            ctx.save();\n            ctx.scale(1 / 20, -1 / 20);\n            ctx.fillStyle = 'gray';\n            ctx.font = '1px sans-serif';\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.fillText(this.calibrationMessage, 0, 0);\n            ctx.restore();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/GamepadDisplay.js?");

/***/ }),

/***/ "./js/gui/Label.js":
/*!*************************!*\
  !*** ./js/gui/Label.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Label: () => (/* binding */ Label)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.js */ \"./js/gui/Utils.js\");\n\n\nclass Label extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    text = '';\n    options = {};\n    /**\n     *\n     * @param {string} text\n     * @param {CanvasTextAlign} align\n     * @param {number} fontSize\n     * @param {string} font\n     * @param {string} color\n     * @param {CanvasTextBaseline} baseline\n     * @param {number} maxWidth\n     */\n    constructor(text, options = {}) {\n        super();\n        this.text = text;\n        this.options = options;\n        this.drawAfterChildren();\n    }\n    draw(ctx) {\n        (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.drawText)(ctx, this.text, this.options);\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/Label.js?");

/***/ }),

/***/ "./js/gui/MouseCursor.js":
/*!*******************************!*\
  !*** ./js/gui/MouseCursor.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MouseCursor: () => (/* binding */ MouseCursor)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n\nclass MouseCursor extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    constructor() {\n        super();\n    }\n    update(dt) {\n        let mouse = this.engine.input.mouse;\n        this.transform.translation.copy(mouse.position);\n    }\n    draw(ctx) {\n        ctx.fillStyle = 'red';\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, -5);\n        ctx.lineTo(4, -4);\n        ctx.lineTo(0, 0);\n        ctx.fill();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/MouseCursor.js?");

/***/ }),

/***/ "./js/gui/TextBox.js":
/*!***************************!*\
  !*** ./js/gui/TextBox.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextBox: () => (/* binding */ TextBox)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _geometry_Rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/Rectangle.js */ \"./js/geometry/Rectangle.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils.js */ \"./js/gui/Utils.js\");\n\n\n\n\nclass TextBox extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject {\n    static lock = false;\n    enabled = true;\n    text = '';\n    active = false;\n    cursorPosition = 0;\n    rect = new _geometry_Rectangle_js__WEBPACK_IMPORTED_MODULE_2__.Rectangle(0, 0, 1, 1);\n    options = {};\n    onSound;\n    offSound;\n    placeholder = '';\n    constructor(placeholder = '', options = {}, onSound = null, offSound = null) {\n        super();\n        this.placeholder = placeholder;\n        this.options = options;\n        this.onSound = onSound;\n        this.offSound = offSound;\n        this.position.set(options.posX ?? 0, options.posY ?? 0);\n        options.posX = 0;\n        options.posY = 0;\n        options.size = options.size ?? 1;\n        options.maxWidth = options.maxWidth ?? 1;\n        this.rect.transform.scale.set(options.maxWidth * 1.1, options.size * 1.1);\n        this.add(this.rect);\n        window.addEventListener('keydown', async (event) => {\n            if (this.active) {\n                if (event.code === 'KeyV' && event.ctrlKey) {\n                    this.#addStr(await navigator.clipboard.readText());\n                }\n                else if (event.key.length === 1) {\n                    this.#addStr(event.key);\n                }\n                else if (event.key === 'Backspace') {\n                    this.text = this.text.slice(0, Math.max(0, this.cursorPosition - 1)) + this.text.slice(this.cursorPosition);\n                    this.cursorPosition = Math.max(this.cursorPosition - 1, 0);\n                }\n                else if (event.key === 'Delete') {\n                    this.text = this.text.slice(0, this.cursorPosition) + this.text.slice(this.cursorPosition + 1);\n                }\n                else if (event.key === 'Enter')\n                    this.toggleOff();\n                else if (event.code === 'ArrowLeft')\n                    this.cursorPosition = Math.max(this.cursorPosition - 1, 0);\n                else if (event.code === 'ArrowRight')\n                    this.cursorPosition = Math.min(this.cursorPosition + 1, this.text.length);\n            }\n        });\n        this.drawAfterChildren();\n    }\n    #addStr(str) {\n        this.text = this.text.slice(0, this.cursorPosition) + str + this.text.slice(this.cursorPosition);\n        this.cursorPosition += str.length;\n    }\n    toggleOn() {\n        if (this.active || TextBox.lock || !this.enabled)\n            return;\n        this.rect.displayColor = 'blue';\n        this.active = true;\n        this.input.lock('TextBox');\n        this.cursorPosition = this.text.length;\n        TextBox.lock = true;\n        if (this.onSound)\n            this.engine.soundBank.get(this.onSound)?.play();\n    }\n    toggleOff() {\n        if (!this.active)\n            return;\n        this.rect.displayColor = 'red';\n        this.active = false;\n        this.input.unlock('TextBox');\n        TextBox.lock = false;\n        if (this.offSound)\n            this.engine.soundBank.get(this.offSound)?.play();\n        this.onChange(this.text);\n    }\n    toggle() {\n        if (!this.active)\n            this.toggleOn();\n        else\n            this.toggleOff();\n    }\n    onChange(text) { }\n    update(dt) {\n        let mouse = this.input.mouse;\n        if (mouse.leftClick) {\n            if (this.rect.containsWorldVector(mouse.position)) {\n                if (!this.active)\n                    this.toggleOn();\n            }\n            else if (this.active)\n                this.toggleOff();\n        }\n    }\n    draw(ctx) {\n        ctx.save();\n        if (this.options.align === 'left')\n            ctx.translate(-(this.options.maxWidth ?? 100) / 2, 0);\n        else if (this.options.align === 'right')\n            ctx.translate((this.options.maxWidth ?? 100) / 2, 0);\n        let txt = this.text.slice(0, this.cursorPosition) + (this.active ? '_' : '') + (this.text.slice(this.cursorPosition));\n        if (txt.length === 0)\n            txt = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.resolveStringable)(this.placeholder);\n        (0,_Utils_js__WEBPACK_IMPORTED_MODULE_3__.drawText)(ctx, txt, this.options);\n        ctx.restore();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/TextBox.js?");

/***/ }),

/***/ "./js/gui/Utils.js":
/*!*************************!*\
  !*** ./js/gui/Utils.js ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   drawText: () => (/* binding */ drawText)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\nfunction drawText(ctx, text, textoptions) {\n    let color = textoptions.color ? (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.resolveStringable)(textoptions.color) : null;\n    let outlineColor = textoptions.outlineColor ? (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.resolveStringable)(textoptions.outlineColor) : null;\n    if (!color && !outlineColor)\n        return;\n    let value = (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.resolveStringable)(text);\n    let size = textoptions.size ?? 1;\n    let font = textoptions.font ?? 'sans-serif';\n    let align = textoptions.align ?? 'center';\n    let baseline = textoptions.baseline ?? 'middle';\n    let maxWidth = textoptions.maxWidth ?? 1000000;\n    ctx.save();\n    ctx.transform(size, 0, 0, -size, textoptions.posX ?? 0, textoptions.posY ?? 0);\n    ctx.font = `1px ${font}`;\n    ctx.textAlign = align;\n    ctx.textBaseline = baseline;\n    if (color) {\n        ctx.fillStyle = color;\n        ctx.fillText(value, 0, 0, maxWidth / size);\n    }\n    if (outlineColor) {\n        ctx.lineWidth = textoptions.lineWidth ?? 1;\n        ctx.strokeStyle = outlineColor;\n        ctx.strokeText(value, 0, 0, maxWidth / size);\n    }\n    ctx.restore();\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/gui/Utils.js?");

/***/ }),

/***/ "./js/images/Drawable.js":
/*!*******************************!*\
  !*** ./js/images/Drawable.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Drawable: () => (/* binding */ Drawable)\n/* harmony export */ });\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n/* harmony import */ var _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector.js */ \"./js/math/Vector.js\");\n/* harmony import */ var _ImageManipulator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ImageManipulator.js */ \"./js/images/ImageManipulator.js\");\n\n\n\nclass Drawable extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n    images = [];\n    imageSize = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector();\n    halfSize = new _math_Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector();\n    imageSmoothing = true;\n    constructor(...images) {\n        super();\n        if (images.length === 0)\n            throw 'There is no image!';\n        this.images = images;\n        this.imageSize.set(this.images[0].width, this.images[0].height);\n        this.halfSize.copy(this.imageSize).divS(2);\n    }\n    render(resolution = this.imageSize, margin = 0, smoothing = false) {\n        let imageManipulator = new _ImageManipulator_js__WEBPACK_IMPORTED_MODULE_2__.ImageManipulator(resolution.x + margin * 2, resolution.y + margin * 2);\n        imageManipulator.ctx.imageSmoothingEnabled = smoothing;\n        imageManipulator.setCtxToCenter();\n        imageManipulator.ctx.scale(...resolution.clone().div(resolution.clone().addS(margin, margin)).arrayXY());\n        this.executeDraw(imageManipulator.ctx);\n        return imageManipulator;\n    }\n    draw(ctx) {\n        ctx.save();\n        ctx.imageSmoothingEnabled = this.imageSmoothing;\n        ctx.scale(1 / this.imageSize.x, -1 / this.imageSize.y);\n        for (let image of this.images)\n            ctx.drawImage(image, -this.halfSize.x, -this.halfSize.y);\n        ctx.restore();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/images/Drawable.js?");

/***/ }),

/***/ "./js/images/ImageManipulator.js":
/*!***************************************!*\
  !*** ./js/images/ImageManipulator.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CANVAS_RESOLUTION: () => (/* binding */ CANVAS_RESOLUTION),\n/* harmony export */   ImageManipulator: () => (/* binding */ ImageManipulator),\n/* harmony export */   LargeImageManipulator: () => (/* binding */ LargeImageManipulator)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n/* harmony import */ var _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basics/GameObject.js */ \"./js/basics/GameObject.js\");\n\n\nclass ImageManipulator extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject {\n    canvas;\n    ctx;\n    smooth = true;\n    constructor(width = 1, height = 1) {\n        super();\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.ctx = this.canvas.getContext('2d');\n        this.ctx.imageSmoothingEnabled = false;\n    }\n    get width() { return this.canvas.width; }\n    get height() { return this.canvas.height; }\n    setCtxToCenter() {\n        this.ctx.setTransform(this.width, 0, 0, -this.height, this.width / 2, this.height / 2);\n    }\n    setSize(width, height) {\n        let tmpcanvas = document.createElement('canvas');\n        tmpcanvas.width = this.canvas.width;\n        tmpcanvas.height = this.canvas.height;\n        let tmpctx = tmpcanvas.getContext('2d');\n        tmpctx.imageSmoothingEnabled = false;\n        tmpctx.drawImage(this.canvas, 0, 0);\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.ctx.imageSmoothingEnabled = false;\n        this.ctx.drawImage(tmpcanvas, 0, 0);\n    }\n    setPixel(x, y, color) {\n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(x, y, 1, 1);\n    }\n    setPixelRGBA(x, y, r, g, b, a) {\n        let imageData = new ImageData(1, 1);\n        imageData.data.set([r, g, b, a]);\n        this.ctx.putImageData(imageData, x, y);\n    }\n    getPixel(x, y) {\n        let data = this.ctx.getImageData(x, y, 1, 1);\n        return [data.data[0], data.data[1], data.data[2], data.data[3]];\n    }\n    print() { return this.canvas.toDataURL('image/png'); }\n    download(name, addSize = false) {\n        let a = document.createElement('a');\n        a.href = this.print();\n        a.download = `${name}${addSize ? `_${this.width}x${this.height}` : ''}.png`;\n        document.body.appendChild(a);\n        a.click();\n        a.remove();\n    }\n    getImage() {\n        return new Promise((ok, ko) => {\n            let image = document.createElement('img');\n            image.onload = () => ok(image);\n            image.onerror = () => ko(null);\n            image.src = this.print();\n        });\n    }\n    toString() { return this.print(); }\n    clone() {\n        let im = new ImageManipulator(this.width, this.height);\n        im.ctx.drawImage(this.canvas, 0, 0);\n        return im;\n    }\n    flipV() {\n        let im = this.clone();\n        this.ctx.save();\n        this.ctx.scale(1, -1);\n        this.ctx.drawImage(im.canvas, 0, -im.height);\n        this.ctx.restore();\n        return this;\n    }\n    flipH() {\n        let im = this.clone();\n        this.ctx.save();\n        this.ctx.scale(-1, 1);\n        this.ctx.drawImage(im.canvas, -im.width, 0);\n        this.ctx.restore();\n        return this;\n    }\n    rotate270() {\n        let clone = this.clone();\n        this.setSize(clone.height, clone.width);\n        this.ctx.save();\n        this.setCtxToCenter();\n        this.ctx.rotate(Math.PI / 2);\n        this.ctx.drawImage(clone.canvas, -clone.width / 2, -clone.height / 2);\n        this.ctx.restore();\n    }\n    rotate90() {\n        let clone = this.clone();\n        this.setSize(clone.height, clone.width);\n        this.ctx.save();\n        this.ctx.translate(this.width / 2, this.height / 2);\n        this.ctx.rotate(Math.PI / 2);\n        this.ctx.drawImage(clone.canvas, -clone.width / 2, -clone.height / 2);\n        this.ctx.restore();\n    }\n    static fromImage(image) {\n        let im = new ImageManipulator(image.width, image.height);\n        im.ctx.drawImage(image, 0, 0);\n        return im;\n    }\n    draw(ctx) {\n        ctx.save();\n        ctx.imageSmoothingEnabled = this.smooth;\n        ctx.scale(1 / this.width, -1 / this.height);\n        ctx.drawImage(this.canvas, -this.width / 2, -this.height / 2);\n        ctx.restore();\n    }\n}\nconst CANVAS_RESOLUTION = 2048;\nclass LargeImageManipulator extends _basics_GameObject_js__WEBPACK_IMPORTED_MODULE_1__.GameObject {\n    canvases;\n    fullSize = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    gridSize = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    smooth = true;\n    constructor(width, height) {\n        super();\n        this.updateSize(width, height);\n    }\n    updateSize(width, height) {\n        let horizontalCount = Math.ceil(width / CANVAS_RESOLUTION);\n        let verticalCount = Math.ceil(height / CANVAS_RESOLUTION);\n        this.fullSize.set(width, height);\n        if (this.gridSize.equalS(horizontalCount, verticalCount))\n            return;\n        this.gridSize.set(horizontalCount, verticalCount);\n        let oldCanvases = this.canvases;\n        this.canvases = [];\n        let techicalWidth = (horizontalCount - 1) / 2;\n        let techicalHeight = (verticalCount - 1) / 2;\n        for (let x = -techicalWidth; x <= techicalWidth; x++)\n            for (let y = -techicalHeight; y <= techicalHeight; y++) {\n                let canvas = document.createElement('canvas');\n                canvas.width = canvas.height = CANVAS_RESOLUTION;\n                let ctx = canvas.getContext('2d');\n                this.canvases.push({\n                    canvas,\n                    ctx,\n                    position: new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector(x, y)\n                });\n            }\n        if (oldCanvases)\n            this.run((ctx) => {\n                for (let { canvas, position } of oldCanvases) {\n                    position.subS(.5, .5).multS(CANVAS_RESOLUTION);\n                    ctx.drawImage(canvas, position.x, position.y);\n                }\n            });\n    }\n    /**\n     * Call the callback on each stored canvas, with the area associated.\n     * Edge canvas are automatically clipped out.\n     * area Rectangle is freely modifyable\n     */\n    run(callback, invertVertical = false) {\n        let vinv = invertVertical ? -1 : 1;\n        let hw = -this.fullSize.x / 2;\n        let hh = -this.fullSize.y / 2;\n        for (let { ctx, position } of this.canvases) {\n            let effectivePosition = position.clone().multS(CANVAS_RESOLUTION);\n            ctx.save();\n            ctx.setTransform(1, 0, 0, -1, -effectivePosition.x + CANVAS_RESOLUTION / 2, effectivePosition.y + CANVAS_RESOLUTION / 2);\n            ctx.beginPath();\n            ctx.rect(hw, hh, this.fullSize.x, this.fullSize.y);\n            ctx.clip();\n            callback(ctx, new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Rectangle(effectivePosition.x, effectivePosition.y, CANVAS_RESOLUTION, CANVAS_RESOLUTION));\n            ctx.restore();\n        }\n    }\n    async export() {\n        let result = {\n            width: this.fullSize.x,\n            height: this.fullSize.y,\n            data: []\n        };\n        for (let { canvas, ctx, position } of this.canvases) {\n            result.data.push({\n                image: canvas.toDataURL(),\n                x: position.x * CANVAS_RESOLUTION,\n                y: position.y * CANVAS_RESOLUTION\n            });\n        }\n        return result;\n    }\n    import(raw) {\n        if (!raw)\n            return;\n        let { width, height, data } = raw;\n        for (let { x, y, image } of data) {\n            (0,_2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.loadDataUrl)(image)\n                .then(image => this.run((ctx) => {\n                ctx.scale(1, -1);\n                ctx.drawImage(image, x - CANVAS_RESOLUTION / 2, -y - CANVAS_RESOLUTION / 2);\n            }));\n        }\n    }\n    draw(ctx) {\n        ctx.save();\n        ctx.imageSmoothingEnabled = this.smooth;\n        ctx.scale(1 / this.fullSize.x, -1 / this.fullSize.y);\n        for (let { canvas, position } of this.canvases) {\n            let positionOnCanvas = position.clone().multS(CANVAS_RESOLUTION).subS(CANVAS_RESOLUTION / 2, -CANVAS_RESOLUTION / 2);\n            ctx.drawImage(canvas, positionOnCanvas.x, -positionOnCanvas.y);\n        }\n        ctx.restore();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/images/ImageManipulator.js?");

/***/ }),

/***/ "./js/images/SpriteSheet.js":
/*!**********************************!*\
  !*** ./js/images/SpriteSheet.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpriteSheet: () => (/* binding */ SpriteSheet)\n/* harmony export */ });\n/* harmony import */ var _Drawable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Drawable.js */ \"./js/images/Drawable.js\");\n\nconst SpriteSheetOptions = {\n    cellWidth: 16,\n    cellHeight: 16,\n};\nclass SpriteSheet extends _Drawable_js__WEBPACK_IMPORTED_MODULE_0__.Drawable {\n    options;\n    horizontalCount;\n    cursor = 0;\n    loopOrigin = 0;\n    tileInLoop = 1;\n    savedLoop = new Map();\n    constructor(image, options = SpriteSheetOptions) {\n        super(image);\n        this.options = { ...SpriteSheetOptions, ...options };\n        this.horizontalCount = this.images[0].width / this.options.cellWidth;\n        this.imageSize.set(this.options.cellWidth, this.options.cellHeight);\n        this.halfSize.copy(this.imageSize).divS(2);\n    }\n    XYToIndex(x, y) {\n        return x + y * this.horizontalCount;\n    }\n    indexToXY(index) {\n        let x = index % this.horizontalCount;\n        let y = Math.floor(index / this.horizontalCount);\n        return [x, y];\n    }\n    saveLoop(name, loopOrigin, tileInLoop) { this.savedLoop.set(name, [loopOrigin, tileInLoop]); }\n    useLoop(name, index = 0) { this.setLoop(...this.savedLoop.get(name) ?? [0, 0], index); }\n    isLoop(name) { return this.loopOrigin == this.savedLoop.get(name)?.[0] ?? false; }\n    setLoop(loopOrigin, tileInLoop, startIndex = 0) {\n        this.loopOrigin = loopOrigin;\n        this.tileInLoop = tileInLoop;\n        this.cursor = this.loopOrigin + startIndex % tileInLoop;\n    }\n    getLoopIndex() { return this.cursor - this.loopOrigin; }\n    next() { this.cursor = this.loopOrigin + (this.getLoopIndex() + 1) % this.tileInLoop; }\n    draw(ctx) {\n        ctx.save();\n        let x = this.cursor % this.horizontalCount;\n        let y = Math.floor(this.cursor / this.horizontalCount);\n        x *= this.imageSize.x;\n        y *= this.imageSize.y;\n        ctx.scale(1 / this.imageSize.x, -1 / this.imageSize.y);\n        ctx.drawImage(this.images[0], x, y, this.imageSize.x, this.imageSize.y, -this.halfSize.x, -this.halfSize.y, this.imageSize.x, this.imageSize.y);\n        ctx.restore();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/images/SpriteSheet.js?");

/***/ }),

/***/ "./js/images/TextureMapper.js":
/*!************************************!*\
  !*** ./js/images/TextureMapper.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextureMapper: () => (/* binding */ TextureMapper)\n/* harmony export */ });\n/* harmony import */ var _ImageManipulator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageManipulator.js */ \"./js/images/ImageManipulator.js\");\n\nclass TextureMapper {\n    static map(modelIM, colorChartIM, textureIM) {\n        let outputIM = new _ImageManipulator_js__WEBPACK_IMPORTED_MODULE_0__.ImageManipulator(modelIM.width, modelIM.height);\n        for (let x = 0; x < modelIM.width; x++)\n            for (let y = 0; y < modelIM.height; y++) {\n                let modelColor = modelIM.getPixel(x, y);\n                if (modelColor[3] == 0)\n                    continue;\n                // console.log(modelColor)\n                let pixelLocation = TextureMapper.#findPixelWithColorInImage(colorChartIM, ...modelColor);\n                // console.log(pixelLocation)\n                if (!pixelLocation)\n                    continue;\n                let color = textureIM.getPixel(...pixelLocation);\n                // console.log(color)\n                outputIM.setPixelRGBA(x, y, ...color);\n            }\n        return outputIM;\n    }\n    static #findPixelWithColorInImage(image, r, g, b, a) {\n        for (let x = 0; x < image.width; x++)\n            for (let y = 0; y < image.height; y++) {\n                let data = image.getPixel(x, y);\n                if (data[3] == a && data[0] == r && data[1] == g && data[2] == b)\n                    return [x, y];\n            }\n        return null;\n    }\n    static downloadStandardColorChart(width, height) {\n        if (width < 1 || width > 256 || height < 0 || height > 256)\n            throw `Invalid dimensions`;\n        let im = new _ImageManipulator_js__WEBPACK_IMPORTED_MODULE_0__.ImageManipulator(width, height);\n        for (let r = 0; r < width; r++)\n            for (let g = 0; g < height; g++) {\n                let color = `rgb(${255 - r * 256 / width}, ${255 - g * 256 / height}, ${Math.max(r * 256 / width, g * 256 / height)})`;\n                console.log(r, g, color);\n                im.setPixel(r, g, color);\n            }\n        im.download('colorchart');\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/images/TextureMapper.js?");

/***/ }),

/***/ "./js/images/Utils.js":
/*!****************************!*\
  !*** ./js/images/Utils.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SVGStringToImage: () => (/* binding */ SVGStringToImage),\n/* harmony export */   loadDataUrl: () => (/* binding */ loadDataUrl)\n/* harmony export */ });\nfunction SVGStringToImage(svg) {\n    let blob = new Blob([svg], { type: 'image/svg+xml' });\n    let url = URL.createObjectURL(blob);\n    return new Promise((ok, ko) => {\n        let image = new Image();\n        image.onload = () => { ok(image); };\n        image.onerror = (err) => { ko(err); };\n        image.src = url;\n    });\n}\nfunction loadDataUrl(dataurl) {\n    return new Promise((ok) => {\n        let image = new Image();\n        image.onload = () => ok(image);\n        image.onerror = () => ok(image);\n        image.src = dataurl;\n    });\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/images/Utils.js?");

/***/ }),

/***/ "./js/math/Block.js":
/*!**************************!*\
  !*** ./js/math/Block.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Block: () => (/* binding */ Block)\n/* harmony export */ });\nclass Block {\n    width = 1;\n    height = 1;\n    depth = 1;\n    cells;\n    constructor(width, height, depth, cellBuilder) {\n        if (width < 1 || height < 1 || depth < 1)\n            throw 'Block dimension cannot be less than 1x1x1';\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.cells = [];\n        for (let index = 0; index < width * height * depth; index++) {\n            let [x, y, z] = this.indexToPosition(index);\n            this.cells.push(cellBuilder(x, y, z, index));\n        }\n    }\n    getCellAtIndex(index) { return this.cells[index]; }\n    getCellAtPosition(x, y, z) {\n        if (!this.containsPosition(x, y, z))\n            return null;\n        return this.cells[this.positionToIndex(x, y, z)] ?? null;\n    }\n    indexToPosition(index) {\n        let x = index % this.width;\n        let y = Math.floor(index / this.width) % this.height;\n        let z = Math.floor(index / (this.width * this.height));\n        return [x, y, z];\n    }\n    positionToIndex(x, y, z) {\n        return x + y * this.width + z * (this.width * this.height);\n    }\n    containsPosition(x, y, z) {\n        return 0 <= x && x < this.width && 0 <= y && y < this.height && 0 <= z && z < this.depth;\n    }\n    neighborOf(x, y, z, side) {\n        let [sx, sy, sz] = Block.sideToDir(side);\n        x += sx;\n        y += sy;\n        z += sz;\n        if (this.containsPosition(x, y, z))\n            return [x, y, z];\n        return null;\n    }\n    static blockPositionToId(position) {\n        return position.join('|');\n    }\n    static idToBlockPosition(id) {\n        return id.split('|').map(Number);\n    }\n}\n(function (Block) {\n    let Side;\n    (function (Side) {\n        Side[Side[\"LEFT\"] = 0] = \"LEFT\";\n        Side[Side[\"RIGHT\"] = 1] = \"RIGHT\";\n        Side[Side[\"DOWN\"] = 2] = \"DOWN\";\n        Side[Side[\"UP\"] = 3] = \"UP\";\n        Side[Side[\"BACK\"] = 4] = \"BACK\";\n        Side[Side[\"FRONT\"] = 5] = \"FRONT\";\n    })(Side = Block.Side || (Block.Side = {}));\n    function sideToDir(side) {\n        let x = 0, y = 0, z = 0;\n        switch (side) {\n            case Block.Side.LEFT:\n                x--;\n                break;\n            case Block.Side.RIGHT:\n                x++;\n                break;\n            case Block.Side.DOWN:\n                y--;\n                break;\n            case Block.Side.UP:\n                y++;\n                break;\n            case Block.Side.BACK:\n                z--;\n                break;\n            case Block.Side.FRONT:\n                z++;\n                break;\n            default:\n                y++;\n        }\n        return [x, y, z];\n    }\n    Block.sideToDir = sideToDir;\n    function dirToSide(x, y, z) {\n        if (x < 0)\n            return Side.LEFT;\n        if (x > 0)\n            return Side.RIGHT;\n        if (y < 0)\n            return Side.DOWN;\n        if (y > 0)\n            return Side.UP;\n        if (z < 0)\n            return Side.BACK;\n        if (z > 0)\n            return Side.FRONT;\n        return Side.UP;\n    }\n    Block.dirToSide = dirToSide;\n})(Block = Block || (Block = {}));\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/Block.js?");

/***/ }),

/***/ "./js/math/Color.js":
/*!**************************!*\
  !*** ./js/math/Color.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Color: () => (/* binding */ Color),\n/* harmony export */   ColorFormat: () => (/* binding */ ColorFormat),\n/* harmony export */   resolveColorable: () => (/* binding */ resolveColorable)\n/* harmony export */ });\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.js */ \"./js/math/Utils.js\");\n\nvar ColorFormat;\n(function (ColorFormat) {\n    ColorFormat[ColorFormat[\"HSL\"] = 0] = \"HSL\";\n    ColorFormat[ColorFormat[\"RGB\"] = 1] = \"RGB\";\n    ColorFormat[ColorFormat[\"Hex\"] = 2] = \"Hex\";\n})(ColorFormat = ColorFormat || (ColorFormat = {}));\nclass Color {\n    h;\n    s;\n    l;\n    constructor() {\n        this.h = 0;\n        this.s = 0;\n        this.l = 0;\n    }\n    get HSL() { return [this.h, this.s, this.l]; }\n    set HSL([h, s, l]) {\n        this.h = h;\n        this.s = s;\n        this.l = l;\n    }\n    get RGB() { return Color.HSLtoRGB(this.HSL); }\n    set RGB(rgb) { this.HSL = Color.RGBtoHSL(rgb); }\n    get Hex() { return Color.RBGtoHEX(this.RGB); }\n    set Hex(hex) { this.RGB = Color.HEXtoRGB(hex); }\n    get XYZ() {\n        let [r, g, b] = this.RGB;\n        let x = 0.4124564 * r + 0.3575761 * g + 0.1804375 * b;\n        let y = 0.2126729 * r + 0.7151522 * g + 0.0721750 * b;\n        let z = 0.0193339 * r + 0.1191920 * g + 0.9503041 * b;\n        return [x, y, z];\n    }\n    set XYZ([x, y, z]) {\n        let r = 3.2404542 * x + -1.5371385 * y + -0.4985314 * z;\n        let g = -0.9692660 * x + 1.8760108 * y + 0.0415560 * z;\n        let b = 0.0556434 * x + -0.2040259 * y + 1.0572252 * z;\n    }\n    get HCL() {\n        let [x, y, z] = this.XYZ;\n        let h = Math.atan2(y, x) * 180 / Math.PI;\n        if (h < 0)\n            h += 360;\n        let c = Math.sqrt(x ** 2 + y ** 2);\n        let l = z;\n        return [h, c, l];\n    }\n    set HCL([h, c, l]) {\n        let rad = h * Math.PI / 180;\n        let chroma = c / 100;\n        let x = chroma * Math.cos(rad);\n        let y = l / 100;\n        let z = chroma * Math.sin(rad);\n        this.XYZ = [x, y, z];\n    }\n    clone() { return Color.HSL(this.HSL); }\n    toString(type = ColorFormat.HSL) {\n        switch (type) {\n            case ColorFormat.HSL:\n                return `hsl(${this.h},${this.s}%,${this.l}%)`;\n            case ColorFormat.RGB:\n                return `rgb(${this.RGB.join(',')})`;\n            case ColorFormat.Hex:\n                return this.Hex;\n            default:\n                return `hsl(${this.h},${this.s}%,${this.l}%)`;\n        }\n    }\n    // Creation\n    static HSL([h, s, l]) {\n        let color = new Color();\n        color.h = h;\n        color.s = s;\n        color.l = l;\n        return color;\n    }\n    static RGB(rgb) {\n        return this.HSL(this.RGBtoHSL(rgb));\n    }\n    static Hex(hex) {\n        return this.RGB(this.HEXtoRGB(hex));\n    }\n    // conversion\n    static HSLtoRGB([h, s, l]) {\n        s /= 100;\n        l /= 100;\n        let k = n => (n + h / 30) % 12;\n        let a = s * Math.min(l, 1 - l);\n        let f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));\n        return [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))];\n    }\n    static RGBtoHSL([r, g, b]) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        const l = Math.max(r, g, b);\n        const s = l - Math.min(r, g, b);\n        const h = s\n            ? l === r\n                ? (g - b) / s\n                : l === g\n                    ? 2 + (b - r) / s\n                    : 4 + (r - g) / s\n            : 0;\n        return [\n            Math.round(60 * h < 0 ? 60 * h + 360 : 60 * h),\n            Math.round(100 * (s ? (l <= 0.5 ? s / (2 * l - s) : s / (2 - (2 * l - s))) : 0)),\n            Math.round((100 * (2 * l - s)) / 2),\n        ];\n    }\n    static HEXtoRGB(hexColor) {\n        let match;\n        if ((match = /^#?([0-9a-fA-F]{3})$/.exec(hexColor))) {\n            return match[1]\n                .split('')\n                .map(v => v + v)\n                .map(v => parseInt(v, 16));\n        }\n        if ((match = /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/.exec(hexColor))) {\n            return match.slice(1, 4).map(v => parseInt(v, 16));\n        }\n        return [0, 0, 0];\n    }\n    static RBGtoHEX([r, g, b]) {\n        let rStr = r.toString(16);\n        if (rStr.length === 1)\n            rStr = '0' + rStr;\n        let gStr = g.toString(16);\n        if (gStr.length === 1)\n            gStr = '0' + gStr;\n        let bStr = b.toString(16);\n        if (bStr.length === 1)\n            bStr = '0' + bStr;\n        return `#${rStr}${gStr}${bStr}`;\n    }\n    // Lerp\n    static lerpRGB(a, b, t) {\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lerpArray)(a, b, t);\n    }\n    static lerpHSL(a, b, t) {\n        let h0 = a[0];\n        let h1 = b[0];\n        let d = Math.abs(h1 - h0);\n        let h;\n        if (h0 < h1) {\n            if (d > 180)\n                h = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(h0 + 360, h1, t) % 360;\n            else\n                h = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(h0, h1, t);\n        }\n        else {\n            if (d > 180)\n                h = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(h0, h1 + 360, t) % 360;\n            else\n                h = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(h0, h1, t);\n        }\n        return [h, (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(a[1], b[1], t), (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(a[2], b[2], t)];\n    }\n}\nfunction resolveColorable(value) {\n    if (value === null || value === undefined)\n        return '#000';\n    if (value instanceof Color)\n        return value.toString();\n    return typeof value === 'string' ? value : value();\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/Color.js?");

/***/ }),

/***/ "./js/math/Graph.js":
/*!**************************!*\
  !*** ./js/math/Graph.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Graph: () => (/* binding */ Graph),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Path: () => (/* binding */ Path)\n/* harmony export */ });\n/* harmony import */ var _Block_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Block.js */ \"./js/math/Block.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector.js */ \"./js/math/Vector.js\");\n\n\nclass Graph {\n    nodes = new Set();\n    nodesObjects = new Map();\n    links = new Map();\n    constructor() {\n    }\n    addNode(...nodes) {\n        for (let [node, object] of nodes) {\n            if (!this.nodes.has(node)) {\n                this.nodes.add(node);\n                this.nodesObjects.set(node, object);\n                this.links.set(node, new Set());\n            }\n        }\n    }\n    removeNode(...nodes) {\n        for (let node of nodes)\n            if (this.hasNode(node)) {\n                this.nodes.delete(node);\n                this.nodesObjects.delete(node);\n                this.links.delete(node);\n                for (let [, map] of this.links)\n                    map.delete(node);\n            }\n    }\n    /**\n     *\n     * @param {I} node\n     * @returns {boolean}\n     */\n    hasNode(node) { return this.nodes.has(node); }\n    /**\n     *\n     * @param {...{source:I, target:I, data:any}} links\n     */\n    addLink(...links) {\n        for (let link of links) {\n            if (!this.hasNode(link[0]) || !this.hasNode(link[1]))\n                continue;\n            this.links.get(link[0]).add(link[1]);\n        }\n    }\n    /**\n     *\n     * @param {...{source:I, target:I}} links\n     */\n    removeLink(...links) {\n        for (let link of links)\n            if (this.hasLink(link[0], link[1])) {\n                this.links.get(link[0]).delete(link[1]);\n            }\n    }\n    hasLink(source, target) { return this.links.has(source) && this.links.get(source).has(target); }\n    isConnectedTo(source, target) {\n        if (!this.hasNode(source))\n            return false;\n        if (!this.hasNode(target))\n            return false;\n        let nodeSet;\n        let currentSet = new Set([source]);\n        do {\n            nodeSet = currentSet;\n            currentSet = new Set(nodeSet);\n            for (let node of nodeSet)\n                for (let target of this.links.get(node).keys())\n                    currentSet.add(target);\n        } while (nodeSet.size != currentSet.size);\n        return nodeSet.has(target);\n    }\n    isConnected(node) {\n        if (!this.hasNode(node))\n            return true;\n        let nodeSet;\n        let currentSet = new Set([node]);\n        do {\n            nodeSet = currentSet;\n            currentSet = new Set(nodeSet);\n            for (let node of nodeSet)\n                for (let target of this.links.get(node).keys())\n                    currentSet.add(target);\n        } while (nodeSet.size != currentSet.size);\n        return nodeSet.size == this.nodes.size;\n    }\n    isFullyConnected() {\n        for (let node of this.nodes)\n            if (!this.isConnected(node))\n                return false;\n        return true;\n    }\n    getShortestPathBetween(source, target, estimateDistance) {\n        if (!this.hasNode(source) || !this.hasNode(target))\n            return null;\n        let nodes = new Map();\n        this.nodes.forEach(id => nodes.set(id, new Node(id)));\n        let start = nodes.get(source);\n        let end = nodes.get(target);\n        let closed = [];\n        let opened = [start];\n        while (opened.length) {\n            let current = opened.splice(opened.indexOf(opened.reduce((a, b) => a.heuristic < b.heuristic ? a : b)), 1)[0];\n            let currentObject = this.nodesObjects.get(current.id);\n            if (current == end) {\n                let list = [end.id];\n                let node = end;\n                while (node.previous) {\n                    node = node.previous;\n                    list.push(node.id);\n                }\n                return list.reverse();\n            }\n            for (let neighbour of this.links.get(current.id)) {\n                let node = nodes.get(neighbour);\n                let cost = current.cost + estimateDistance(currentObject, this.nodesObjects.get(node.id));\n                if (!(closed.includes(node) || (opened.includes(node) && node.cost <= cost))) {\n                    node.cost = cost;\n                    node.heuristic = node.cost + estimateDistance(this.nodesObjects.get(node.id), this.nodesObjects.get(end.id));\n                    node.previous = current;\n                    opened.push(node);\n                }\n            }\n            closed.push(current);\n        }\n        return null;\n    }\n    getFlood(source, maxDistance = Number.MAX_SAFE_INTEGER, estimateDistance) {\n        if (!this.hasNode(source))\n            return null;\n        let nodes = new Map();\n        this.nodes.forEach(id => nodes.set(id, new Node(id)));\n        let start = nodes.get(source);\n        let closed = [];\n        let opened = [start];\n        while (opened.length) {\n            // Get the nearest path\n            let current = opened.splice(opened.indexOf(opened.reduce((a, b) => a.cost < b.cost ? a : b)), 1)[0];\n            let currentObject = this.nodesObjects.get(current.id);\n            closed.push(current);\n            for (let neighbour of this.links.get(current.id)) {\n                let node = nodes.get(neighbour);\n                if (node === start)\n                    continue;\n                let cost = current.cost + estimateDistance(currentObject, this.nodesObjects.get(node.id));\n                if (node.previous) {\n                    // If the cost is same or greater, we can ignore\n                    if (node.cost <= cost)\n                        continue;\n                    node.cost = cost;\n                    node.previous = current;\n                    // If it was closed, unclose it\n                    if (closed.includes(node))\n                        closed.splice(closed.indexOf(node), 1);\n                    // Open it to update neighbors the same way\n                    if (!opened.includes(node))\n                        opened.push(node);\n                }\n                else {\n                    // If cost it too great, ignore node\n                    if (cost > maxDistance)\n                        continue;\n                    node.cost = cost;\n                    // No heuristic used here\n                    node.previous = current;\n                    opened.push(node);\n                }\n            }\n        }\n        let paths = new Map();\n        for (let closedNode of closed) {\n            if (closedNode === start)\n                continue;\n            let list = [closedNode.id];\n            let node = closedNode;\n            while (node.previous) {\n                node = node.previous;\n                list.push(node.id);\n            }\n            paths.set(closedNode.id, list.reverse());\n        }\n        return paths;\n    }\n    populate(nodes) { return nodes.map(id => this.nodesObjects.get(id)); }\n    clone() {\n        let graph = new Graph();\n        graph.addNode(...this.nodesObjects.entries());\n        graph.addLink(...[...this.links.entries()].map(([source, targets]) => [...targets].map((target) => [source, target])).flat());\n        return graph;\n    }\n    static generate(data, dataToId, dataToObj, getIdNeighbors) {\n        let graph = new Graph();\n        let dataEntries = data.map(dataEntry => [dataToId(dataEntry), dataToObj(dataEntry)]);\n        graph.addNode(...dataEntries);\n        dataEntries.forEach(entry => graph.addLink(...getIdNeighbors(...entry).map(id => [entry[0], id])));\n        return graph;\n    }\n    static generateFromBlock(block, linkExtractor) {\n        return this.generate([...block.cells.entries()], ([index, cell]) => _Block_js__WEBPACK_IMPORTED_MODULE_0__.Block.blockPositionToId(block.indexToPosition(index)), ([index, cell]) => cell, (id, obj) => linkExtractor(_Block_js__WEBPACK_IMPORTED_MODULE_0__.Block.idToBlockPosition(id), obj).map(_Block_js__WEBPACK_IMPORTED_MODULE_0__.Block.blockPositionToId));\n    }\n}\nclass Node {\n    cost = 0;\n    heuristic = 0;\n    previous = null;\n    id;\n    constructor(id) { this.id = id; }\n}\nclass Path {\n    points = [];\n    currentPosition = new _Vector_js__WEBPACK_IMPORTED_MODULE_1__.Vector();\n    currentSegment = 1;\n    constructor(Vectors3) {\n        this.points = Vectors3;\n        this.currentPosition.copy(this.points[0]);\n    }\n    get endPosition() {\n        return this.points[this.points.length - 1].clone();\n    }\n    length() {\n        let length = 0;\n        for (let index = 0; index < this.points.length - 1; index++)\n            length += this.points[index].distanceTo(this.points[index + 1]);\n        return length;\n    }\n    reset() {\n        this.currentPosition.copy(this.points[0]);\n        this.currentSegment = 0;\n    }\n    end() { return this.points.length == this.currentSegment; }\n    follow(length) {\n        if (this.end())\n            return this.currentPosition.clone();\n        let next = this.points[this.currentSegment];\n        let distance = this.currentPosition.distanceTo(next);\n        while (distance <= length) {\n            length -= distance;\n            this.currentPosition.copy(next);\n            next = this.points[++this.currentSegment];\n            distance = this.currentPosition.distanceTo(next);\n            if (this.currentSegment == this.points.length)\n                return this.currentPosition.clone();\n        }\n        this.currentPosition.add(next.clone().sub(this.currentPosition).normalize().multS(length));\n        return this.currentPosition.clone();\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/Graph.js?");

/***/ }),

/***/ "./js/math/HexVector.js":
/*!******************************!*\
  !*** ./js/math/HexVector.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HexOrientation: () => (/* binding */ HexOrientation),\n/* harmony export */   HexVector: () => (/* binding */ HexVector)\n/* harmony export */ });\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector.js */ \"./js/math/Vector.js\");\n\nvar HexOrientation;\n(function (HexOrientation) {\n    HexOrientation[HexOrientation[\"flat\"] = 0] = \"flat\";\n    HexOrientation[HexOrientation[\"pointy\"] = 1] = \"pointy\";\n})(HexOrientation = HexOrientation || (HexOrientation = {}));\nclass HexVector {\n    orientation;\n    #q = 0;\n    #r = 0;\n    #s = 0;\n    vector;\n    unit;\n    constructor(orientation = HexOrientation.pointy, unit = 1, q = 0, r = 0, s = 0, vector = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector()) {\n        this.orientation = orientation;\n        this.unit = unit;\n        this.vector = vector;\n        this.setS(q, r, s);\n    }\n    static fromVector(orientation = HexOrientation.pointy, unit = 1, vector) {\n        let hex = new HexVector(orientation, unit);\n        hex.vector.copy(vector);\n        hex.updateFromVector();\n        return hex;\n    }\n    get q() { return this.#q; }\n    get r() { return this.#r; }\n    get s() { return this.#s; }\n    setS(q, r, s) {\n        let sum = q + r + s;\n        if (sum !== 0)\n            throw `Check sum for hex positioning should be equal to zero q(${this.#q + q}) + r(${this.#r + r}) + s(${this.#s + s}) === ${sum}`;\n        this.#q = q;\n        this.#r = r;\n        this.#s = s;\n        this.updateVector();\n        return this;\n    }\n    set(hexVector) {\n        return this.setS(hexVector.q, hexVector.r, hexVector.s);\n    }\n    addS(q, r, s) {\n        let sum = this.#q + q + this.#r + r + this.#s + s;\n        if (sum !== 0)\n            throw `Check sum for hex positioning should be equal to zero q(${this.#q + q}) + r(${this.#r + r}) + s(${this.#s + s}) === ${sum}`;\n        this.#q += q;\n        this.#r += r;\n        this.#s += s;\n        this.updateVector();\n        return this;\n    }\n    add(hexVector) {\n        return this.addS(hexVector.q, hexVector.r, hexVector.s);\n    }\n    updateVector() {\n        let sqrt3 = Math.sqrt(3);\n        if (this.orientation === HexOrientation.pointy)\n            this.vector.set(this.unit * (sqrt3 * this.#q + sqrt3 / 2 * this.#r), this.unit * (3 / 2 * this.#r));\n        else\n            this.vector.set(this.unit * (3 / 2 * this.#q), this.unit * (sqrt3 / 2 * this.#q + sqrt3 * this.#r));\n    }\n    updateFromVector() {\n        let fracQ, fracR;\n        if (this.orientation === HexOrientation.pointy) {\n            fracQ = (Math.sqrt(3) / 3 * this.vector.x - 1 / 3 * this.vector.y) / this.unit;\n            fracR = (2 / 3 * this.vector.y) / this.unit;\n        }\n        else {\n            fracQ = (2 / 3 * this.vector.x) / this.unit;\n            fracR = (-1 / 3 * this.vector.x + Math.sqrt(3) / 3 * this.vector.y) / this.unit;\n        }\n        let fracS = -fracQ - fracR;\n        let q = Math.round(fracQ);\n        let r = Math.round(fracR);\n        let s = Math.round(fracS);\n        let qDiff = Math.abs(q - fracQ);\n        let rDiff = Math.abs(r - fracR);\n        let sDiff = Math.abs(s - fracS);\n        if (qDiff > rDiff && qDiff > sDiff)\n            q = -r - s;\n        else if (rDiff > sDiff)\n            r = -q - s;\n        else\n            s = -q - r;\n        this.setS(q, r, s);\n    }\n    distanceTo(hexVector) {\n        if (this.orientation !== hexVector.orientation)\n            throw 'HexVector have incompatible orientations';\n        return (Math.abs(this.q - hexVector.q) + Math.abs(this.r - hexVector.r) + Math.abs(this.s - hexVector.s)) / 2;\n    }\n    equal(hexVector) { return this.#q === hexVector.q && this.#r === hexVector.r && this.#s === hexVector.s; }\n    equalS(q, r, s) { return this.#q === q && this.#r === r && this.#s === s; }\n    clone() { return new HexVector(this.orientation, this.unit, this.#q, this.#r, this.#s); }\n    neighbors() {\n        return this.units().map((hexVector) => hexVector.add(this));\n    }\n    units() { return HexVector.units(this.orientation, this.unit); }\n    static units(orientation, unit) {\n        return [\n            new HexVector(orientation, unit, 1, -1, 0),\n            new HexVector(orientation, unit, -1, 1, 0),\n            new HexVector(orientation, unit, 0, 1, -1),\n            new HexVector(orientation, unit, 0, -1, 1),\n            new HexVector(orientation, unit, 1, 0, -1),\n            new HexVector(orientation, unit, -1, 0, 1),\n        ];\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/HexVector.js?");

/***/ }),

/***/ "./js/math/PositionIntegrator.js":
/*!***************************************!*\
  !*** ./js/math/PositionIntegrator.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PositionIntegrator: () => (/* binding */ PositionIntegrator)\n/* harmony export */ });\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector.js */ \"./js/math/Vector.js\");\n\nclass PositionIntegrator {\n    previousPosition = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    previousVelocity = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    previousAcceleration = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    position = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    velocity = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    acceleration = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    constructor() { }\n    integrate(t) {\n        let tt = t * t;\n        this.previousPosition.copy(this.position);\n        this.previousVelocity.copy(this.velocity);\n        this.previousAcceleration.copy(this.acceleration);\n        this.position\n            .add(this.velocity.clone().multS(t))\n            .add(this.acceleration.clone().multS(tt * .5));\n        this.velocity.add(this.acceleration.clone().multS(t));\n    }\n    positionHasChanged() { return !this.previousPosition.equal(this.position); }\n    velocityHasChanged() { return !this.previousVelocity.equal(this.velocity); }\n    accelerationHasChanged() { return !this.previousAcceleration.equal(this.acceleration); }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/PositionIntegrator.js?");

/***/ }),

/***/ "./js/math/Random.js":
/*!***************************!*\
  !*** ./js/math/Random.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerlinNoise: () => (/* binding */ PerlinNoise),\n/* harmony export */   PseudoRandom: () => (/* binding */ PseudoRandom)\n/* harmony export */ });\n/* harmony import */ var _basics_Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../basics/Utils.js */ \"./js/basics/Utils.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.js */ \"./js/math/Utils.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector.js */ \"./js/math/Vector.js\");\n\n\n\nclass PseudoRandom {\n    static a = 1664525;\n    static c = 1013904223;\n    static m = Math.pow(2, 32);\n    seed;\n    a = PseudoRandom.a;\n    c = PseudoRandom.c;\n    m = PseudoRandom.m;\n    constructor(seed = Math.random()) {\n        this.seed = seed;\n    }\n    get() {\n        this.seed = (this.a * this.seed + this.c) % this.m;\n        return this.seed / this.m;\n    }\n    static get(seed = Math.random()) {\n        return ((PseudoRandom.a * seed + PseudoRandom.c) % PseudoRandom.m) / PseudoRandom.m;\n    }\n}\nclass PerlinNoise {\n    rng;\n    seed;\n    grid;\n    horizontalLoop;\n    verticalLoop;\n    depthLoop;\n    constructor(seed = Math.random(), horizontalLoop = 2048, verticalLoop = 2048, depthLoop = 2048) {\n        this.seed = seed;\n        this.horizontalLoop = horizontalLoop;\n        this.verticalLoop = verticalLoop;\n        this.depthLoop = depthLoop;\n        this.rng = new PseudoRandom(seed);\n        this.grid = [];\n        for (let x of (0,_basics_Utils_js__WEBPACK_IMPORTED_MODULE_0__.range)(horizontalLoop)) {\n            this.grid.push([]);\n            for (let y of (0,_basics_Utils_js__WEBPACK_IMPORTED_MODULE_0__.range)(verticalLoop)) {\n                this.grid[x].push([]);\n                for (let z of (0,_basics_Utils_js__WEBPACK_IMPORTED_MODULE_0__.range)(depthLoop)) {\n                    // let r = this.rng.get() * Math.PI * 2\n                    let s = this.seed ^ x ^ (y * 57) ^ (z * 29);\n                    let xv = Math.cos(s);\n                    let yv = Math.sin(s);\n                    let zv = PseudoRandom.get(s) * 2 - 1;\n                    let vec = new _Vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector(xv, yv, zv);\n                    this.grid[x][y].push(vec);\n                }\n            }\n        }\n    }\n    fade(t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n    getVector(ix, iy, iz) {\n        ix = ((ix % this.horizontalLoop) + this.horizontalLoop) % this.horizontalLoop;\n        iy = ((iy % this.verticalLoop) + this.verticalLoop) % this.verticalLoop;\n        iz = ((iz % this.depthLoop) + this.depthLoop) % this.depthLoop;\n        let vec = this.grid[ix][iy][iz];\n        return vec;\n    }\n    gradDotProduct(ix, iy, iz, x, y, z) {\n        let distanceVector = new _Vector_js__WEBPACK_IMPORTED_MODULE_2__.Vector(x - ix, y - iy, z - iz);\n        let grad = this.getVector(ix, iy, iz);\n        let product = distanceVector.dot(grad);\n        return product;\n    }\n    get(x, y, z = 0) {\n        let x0 = Math.floor(x);\n        let x1 = x0 + 1;\n        let y0 = Math.floor(y);\n        let y1 = y0 + 1;\n        let z0 = Math.floor(z);\n        let z1 = z0 + 1;\n        let sx = this.fade(x - x0);\n        let sy = this.fade(y - y0);\n        let sz = this.fade(z - z0);\n        let n0, n1, lpy0, lpy1, lpz0, lpz1, value;\n        n0 = this.gradDotProduct(x0, y0, z0, x, y, z);\n        n1 = this.gradDotProduct(x1, y0, z0, x, y, z);\n        lpy0 = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(n0, n1, sx);\n        n0 = this.gradDotProduct(x0, y1, z0, x, y, z);\n        n1 = this.gradDotProduct(x1, y1, z0, x, y, z);\n        lpy1 = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(n0, n1, sx);\n        lpz0 = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(lpy0, lpy1, sy);\n        n0 = this.gradDotProduct(x0, y0, z1, x, y, z);\n        n1 = this.gradDotProduct(x1, y0, z1, x, y, z);\n        lpy0 = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(n0, n1, sx);\n        n0 = this.gradDotProduct(x0, y1, z1, x, y, z);\n        n1 = this.gradDotProduct(x1, y1, z1, x, y, z);\n        lpy1 = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(n0, n1, sx);\n        lpz1 = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(lpy0, lpy1, sy);\n        value = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(lpz0, lpz1, sz);\n        return value;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/Random.js?");

/***/ }),

/***/ "./js/math/Timer.js":
/*!**************************!*\
  !*** ./js/math/Timer.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Timer: () => (/* binding */ Timer)\n/* harmony export */ });\n/**\n * The Timer class is used to mesure time easily\n */\nclass Timer {\n    begin;\n    /**\n     * Create a new timer starting from now or a given setpoint\n     *\n     * @param time\n     */\n    constructor(time = Date.now()) {\n        this.begin = time;\n    }\n    /**\n     * Reset the timer\n     */\n    reset() {\n        this.begin = Date.now();\n    }\n    /**\n     * Return the amount of time in ms since the timer was last reset\n     */\n    getTime() {\n        return Date.now() - this.begin;\n    }\n    /**\n     * Return true if the time since the last reset is greather that the given amount in ms\n     *\n     * @param {number} amount in ms\n     */\n    greaterThan(amount) {\n        return this.getTime() > amount;\n    }\n    /**\n     * Return true if the time since the last reset is less that the given amount in ms\n     *\n     * @param {number} amount\n     */\n    lessThan(amount) {\n        return this.getTime() < amount;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/Timer.js?");

/***/ }),

/***/ "./js/math/Transform.js":
/*!******************************!*\
  !*** ./js/math/Transform.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: () => (/* binding */ Transform)\n/* harmony export */ });\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector.js */ \"./js/math/Vector.js\");\n\nconst PI2 = Math.PI * 2;\nclass Transform {\n    translation = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    #rotation = 0;\n    scale = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n    constructor(translation = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector(0, 0, 0), rotation = 0, scale = new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector(1, 1, 1)) {\n        this.translation.copy(translation);\n        this.rotation = rotation;\n        this.scale.copy(scale);\n    }\n    /**\n    * Return the rotation of the object\n    *\n    * @returns {number}\n    */\n    get rotation() { return this.#rotation; }\n    /**\n     * Set the rotation of the object\n     * The angle is automatically converted into modulo 2.PI > 0\n     *\n     * @param {number} angle\n     */\n    set rotation(angle) {\n        this.#rotation = ((angle % PI2) + PI2) % PI2;\n    }\n    clear() {\n        this.translation.set(0, 0, 0);\n        this.rotation = 0;\n        this.scale.set(1, 1, 1);\n    }\n    isDefault() {\n        return this.translation.x === 0 && this.translation.y === 0 &&\n            this.#rotation == 0 &&\n            this.scale.x === 1 && this.scale.y === 1;\n    }\n    getMatrix() {\n        let cos = Math.cos(this.#rotation);\n        let sin = Math.sin(this.#rotation);\n        let sx = this.scale.x;\n        let sy = this.scale.y;\n        let x = this.translation.x;\n        let y = this.translation.y;\n        return [\n            cos * sx,\n            sin * sx,\n            -sin * sy,\n            cos * sy,\n            x,\n            y\n        ];\n    }\n    getInvertMatrix() {\n        let cos = Math.cos(this.#rotation);\n        let sin = Math.sin(this.#rotation);\n        let sx = this.scale.x;\n        let sy = this.scale.y;\n        let x = (-this.translation.x * cos + -this.translation.y * sin) / sx;\n        let y = (this.translation.x * sin + -this.translation.y * cos) / sy;\n        return [\n            cos / sx,\n            -sin / sy,\n            sin / sx,\n            cos / sy,\n            x,\n            y\n        ];\n    }\n    toString() {\n        let str = 'Transform( ';\n        if (this.translation.x !== 0 || this.translation.y !== 0)\n            str += this.translation.toString() + ' ';\n        if (this.rotation !== 0)\n            str += this.rotation + ' ';\n        if (this.scale.x !== 1 || this.scale.y !== 1)\n            str += this.scale.toString() + ' ';\n        str += ')';\n        return str;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/Transform.js?");

/***/ }),

/***/ "./js/math/TransformMatrix.js":
/*!************************************!*\
  !*** ./js/math/TransformMatrix.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransformMatrix: () => (/* binding */ TransformMatrix)\n/* harmony export */ });\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector.js */ \"./js/math/Vector.js\");\n\nclass TransformMatrix {\n    static default() { return [1, 0, 0, 1, 0, 0]; }\n    static multMat(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    /**\n     * Multiply the given matrix by the given Vector. Mutation safe\n     *\n     * @param m1\n     * @param vec\n     * @returns\n     */\n    static multVec(m1, vec) {\n        return new _Vector_js__WEBPACK_IMPORTED_MODULE_0__.Vector(m1[0] * vec.x + m1[2] * vec.y + m1[4], m1[1] * vec.x + m1[3] * vec.y + m1[5], 0);\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/TransformMatrix.js?");

/***/ }),

/***/ "./js/math/Utils.js":
/*!**************************!*\
  !*** ./js/math/Utils.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coserp: () => (/* binding */ coserp),\n/* harmony export */   cubicBezier: () => (/* binding */ cubicBezier),\n/* harmony export */   invLerp: () => (/* binding */ invLerp),\n/* harmony export */   invLerpArray: () => (/* binding */ invLerpArray),\n/* harmony export */   lerp: () => (/* binding */ lerp),\n/* harmony export */   lerpArray: () => (/* binding */ lerpArray),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   minmax: () => (/* binding */ minmax),\n/* harmony export */   quadBezier: () => (/* binding */ quadBezier)\n/* harmony export */ });\nfunction lerp(a, b, t) { return (1 - t) * a + t * b; }\nfunction invLerp(a, b, v) { return (v - a) / (b - a); }\nfunction lerpArray(a, b, t) {\n    let min = Math.min(a.length, b.length);\n    let result = [];\n    for (let index = 0; index < min; index++)\n        result.push(lerp(a[index], b[index], t));\n    return result;\n}\nfunction invLerpArray(a, b, t) {\n    let min = Math.min(a.length, b.length);\n    let result = [];\n    for (let index = 0; index < min; index++)\n        result.push(invLerp(a[index], b[index], t));\n    return result;\n}\nfunction coserp(a, b, t) {\n    let t2 = (1 - Math.cos(t * Math.PI)) / 2;\n    return (1 - t2) * a + t2 * b;\n}\nfunction map(nbr, sourceMin, sourceMax, targetMin, targetMax) {\n    let t = invLerp(sourceMin, sourceMax, nbr);\n    return lerp(targetMin, targetMax, t);\n}\nfunction minmax(min, value, max) {\n    return Math.max(min, Math.min(value, max));\n}\nfunction cubicBezier(p0, p1, p2, p3, t) {\n    t = minmax(0, t, 1);\n    const tt = t * t;\n    const mt = (1 - t);\n    const mtt = mt * mt;\n    const w0 = tt * t;\n    const w1 = 3 * mtt * t;\n    const w2 = 3 * mt * tt;\n    const w3 = mtt * mt;\n    let result = [];\n    for (let index = 0; index < p0.length; index++)\n        result.push(w0 * p0[index] + w1 * p1[index] + w2 * p2[index] + w3 * p3[index]);\n    return result;\n}\nfunction quadBezier(p0, p1, p2, t) {\n    let mt = (1 - t);\n    let w0 = mt * mt;\n    let w1 = 2 * mt * t;\n    let w2 = t * t;\n    let result = [];\n    for (let index = 0; index < p0.length; index++)\n        result.push(w0 * p0[index] + w1 * p1[index] + w2 * p2[index]);\n    return result;\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/Utils.js?");

/***/ }),

/***/ "./js/math/ValueToggle.js":
/*!********************************!*\
  !*** ./js/math/ValueToggle.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ValueToggle: () => (/* binding */ ValueToggle)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\nclass ValueToggle extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameComponent {\n    active = false;\n    #t = 0;\n    speed;\n    patternFunction;\n    #offValue;\n    #onValue;\n    constructor(patternFunction, speed = 1) {\n        super('valuetoggle');\n        this.drawEnabled = false;\n        this.speed = speed;\n        this.patternFunction = patternFunction;\n        this.#offValue = this.patternFunction(0);\n        this.#onValue = this.patternFunction(1);\n    }\n    get value() {\n        if (this.#t <= 0)\n            return this.#offValue;\n        if (this.#t >= 1)\n            return this.#onValue;\n        return this.patternFunction(this.#t);\n    }\n    on() { this.active = true; }\n    off() { this.active = false; }\n    set(active) { this.active = active; }\n    toggle() { this.active = !this.active; }\n    update(dt) {\n        if (this.active)\n            if (this.#t < 1)\n                this.#t += dt * this.speed;\n            else\n                this.#t = 1;\n        else if (this.#t > 0)\n            this.#t -= dt * this.speed;\n        else\n            this.#t = 0;\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/ValueToggle.js?");

/***/ }),

/***/ "./js/math/Vector.js":
/*!***************************!*\
  !*** ./js/math/Vector.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector: () => (/* binding */ Vector)\n/* harmony export */ });\n/**\n * class Vector represent a 3 dimentional vector\n * it also contains function that are used in 2d context for practical purposes\n */\nclass Vector {\n    x = 0;\n    y = 0;\n    z = 0;\n    /**\n     * Create a new 3D Vector\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     */\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    /**\n    * Set this vector values to the given values\n    *\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @returns {this}\n    */\n    set(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    }\n    /**\n     * Add the given vector to this vector\n     *\n     * @param {Vector} vector\n     * @returns {this}\n     */\n    add(vector = new Vector()) {\n        this.x += vector.x;\n        this.y += vector.y;\n        this.z += vector.z;\n        return this;\n    }\n    /**\n     * Add the given numbers to this vector\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @returns {this}\n     */\n    addS(x = 0, y = 0, z = 0) {\n        this.x += x;\n        this.y += y;\n        this.z += z;\n        return this;\n    }\n    /**\n     * Sub the given vector to this vector\n     *\n     * @param {Vector} vector\n     * @returns {this}\n     */\n    sub(vector = new Vector()) {\n        this.x -= vector.x;\n        this.y -= vector.y;\n        this.z -= vector.z;\n        return this;\n    }\n    /**\n    * Sub the given numbers to this vector\n    *\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @returns {this}\n    */\n    subS(x = 0, y = 0, z = 0) {\n        this.x -= x;\n        this.y -= y;\n        this.z -= z;\n        return this;\n    }\n    /**\n     * Multiply each of this vector value by each of the given vector value\n     *\n     * @param {Vector} vector\n     * @returns {this}\n     */\n    mult(vector) {\n        this.x *= vector.x;\n        this.y *= vector.y;\n        this.z *= vector.z;\n        return this;\n    }\n    /**\n     * Multiply this vector by a given value\n     *\n     * @param {number} n\n     * @returns {this}\n     */\n    multS(n) {\n        this.x *= n;\n        this.y *= n;\n        this.z *= n;\n        return this;\n    }\n    /**\n    * Divide each of this vector value by each of the given vector value\n    *\n    * @param {Vector} vector\n    * @returns {this}\n    */\n    div(vector) {\n        this.x /= vector.x;\n        this.y /= vector.y;\n        this.z /= vector.z;\n        return this;\n    }\n    /**\n     * Divide this vector by a given value\n     *\n     * @param {number} n\n     * @returns {this}\n     */\n    divS(n) {\n        this.x /= n;\n        this.y /= n;\n        this.z /= n;\n        return this;\n    }\n    /**\n     * Returns the result of the dot product between this vector and the given vector\n     *\n     * @param {Vector} vector\n     * @returns {number}\n     */\n    dot(vector) { return this.x * vector.x + this.y * vector.y + this.z * vector.z; }\n    /**\n     * Returns the length of this vector\n     *\n     * @returns {number}\n     */\n    length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }\n    /**\n     * Returns true if the length of this vector is 0\n     *\n     * @returns {boolean}\n     */\n    nil() { return this.x == 0 && this.y == 0 && this.z == 0; }\n    /**\n     * Normalizes this vector if it is not nil\n     *\n     * @returns {this}\n     */\n    normalize() {\n        if (!this.nil())\n            this.divS(this.length());\n        return this;\n    }\n    /**\n     * Rotates the current vector of a given angle on the x and y values\n     *\n     * @param {number} angle\n     * @returns {this}\n     */\n    rotate(angle) {\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        let x = cos * this.x - sin * this.y;\n        let y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    /**\n     * Rotate the current vector of a given angle arround a given position on the x and y values\n     *\n     * @param {Vector} position\n     * @param {number} angle\n     * @returns {this}\n     */\n    rotateAround(position, angle) {\n        this.sub(position);\n        this.rotate(angle);\n        this.add(position);\n        return this;\n    }\n    /**\n     * Returns the angle between this vector and the given vector\n     *\n     * @param vector\n     * @returns {number}\n     */\n    angleTo(vector) { return Math.acos(this.dot(vector) / (this.length() * vector.length())); }\n    /**\n     * Returns the angle on this vector on plane x, y\n     *\n     * @returns {number}\n     */\n    angle() {\n        let vec = this.clone().normalize();\n        return Math.acos(vec.x) * Math.sign(vec.y);\n    }\n    /**\n     * Returns the distance from this Vector position to the given Vector position\n     *\n     * @param {Vector} vector\n     * @returns {number}\n     */\n    distanceTo(vector) { return this.clone().sub(vector).length(); }\n    /**\n     * Copy the given vector values to this vector\n     *\n     * @param {Vector} vector\n     */\n    copy(vector) {\n        this.x = vector.x;\n        this.y = vector.y;\n        this.z = vector.z;\n        return this;\n    }\n    /**\n     * A new instance clone of this vector\n     *\n     * @returns {Vector}\n     */\n    clone() { return new Vector(this.x, this.y, this.z); }\n    /**\n     * Returns true if this vector values are equal to the given vector values\n     *\n     * @param {Vector} vector\n     * @returns {boolean}\n     */\n    equal(vector) { return this.x == vector.x && this.y == vector.y && this.z == vector.z; }\n    /**\n     * Returns true if this vector values are equal to the given values\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @returns {boolean}\n     */\n    equalS(x = 0, y = 0, z = 0) { return this.x == x && this.y == y && this.z == z; }\n    /**\n     * Converts this vector to a string\n     *\n     * @returns {string}\n     */\n    toString() { return `Vector(${this.x}, ${this.y}, ${this.z})`; }\n    /**\n     * Returns a new unit vector from the given angle\n     *\n     * @param {number} angle\n     * @returns {Vector}\n     */\n    static fromAngle(angle) { return new Vector(Math.cos(angle), Math.sin(angle)); }\n    static distanceBetween(a, b) { return a.distanceTo(b); }\n    exec(func) {\n        func(this);\n        return this;\n    }\n    round(n = 1) {\n        this.x = Math.round(this.x / n) * n;\n        this.y = Math.round(this.y / n) * n;\n        this.z = Math.round(this.z / n) * n;\n        return this;\n    }\n    floor(n = 1) {\n        this.x = Math.floor(this.x / n) * n;\n        this.y = Math.floor(this.y / n) * n;\n        this.z = Math.floor(this.z / n) * n;\n        return this;\n    }\n    ceil(n = 1) {\n        this.x = Math.ceil(this.x / n) * n;\n        this.y = Math.ceil(this.y / n) * n;\n        this.z = Math.ceil(this.z / n) * n;\n        return this;\n    }\n    abs() {\n        this.x = Math.abs(this.x);\n        this.y = Math.abs(this.y);\n        this.z = Math.abs(this.z);\n        return this;\n    }\n    projectOn(vector) {\n        let dot = this.dot(vector);\n        let normSquared = vector.x * vector.x + vector.y * vector.y + vector.z * vector.z;\n        let scalar = dot / normSquared;\n        return vector.clone().multS(scalar);\n    }\n    normal() {\n        return new Vector(-this.y, this.x);\n    }\n    to(vector) {\n        return vector.clone().sub(this);\n    }\n    arrayXY() { return [this.x, this.y]; }\n    arrayXYZ() { return [this.x, this.y, this.z]; }\n    neighbors(_8 = false) {\n        return (_8 ? this.units8() : this.units()).map((vector) => vector.add(this));\n    }\n    units() { return Vector.units(); }\n    static units() {\n        return [\n            new Vector(1, 0),\n            new Vector(-1, 0),\n            new Vector(0, 1),\n            new Vector(0, -1)\n        ];\n    }\n    units8() { return Vector.units8(); }\n    static units8() {\n        return [\n            ...this.units(),\n            new Vector(1, 1),\n            new Vector(-1, -1),\n            new Vector(1, -1),\n            new Vector(-1, 1)\n        ];\n    }\n}\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/Vector.js?");

/***/ }),

/***/ "./js/math/WaveFunctionCollapse.js":
/*!*****************************************!*\
  !*** ./js/math/WaveFunctionCollapse.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WFC: () => (/* binding */ WFC),\n/* harmony export */   WaveFunctionCollapse: () => (/* binding */ WaveFunctionCollapse)\n/* harmony export */ });\nclass WaveFunctionCollapse {\n    connectors = {};\n    connectorsLookupTable = null;\n    addConnector(rule) {\n        if (!this.connectors[rule.id])\n            this.connectors[rule.id] = [];\n        this.connectors[rule.id].push(...rule.connectors);\n        if (rule.allDirection) {\n            for (let i = 1; i <= 3; i++)\n                this.connectors[rule.id].push(...rule.connectors.map(connector => ({ side: (connector.side + i) % 4, connection: connector.connection })));\n        }\n    }\n    buildLookupTable() {\n        this.connectorsLookupTable = {};\n        for (let [id, connectorList] of Object.entries(this.connectors)) {\n            let lookup = [new Set(), new Set(), new Set(), new Set()];\n            for (let connector of connectorList)\n                for (let [nextid, nextconnectorList] of Object.entries(this.connectors))\n                    for (let nextconnector of nextconnectorList)\n                        if (WFC.areConnectionsCompatible(connector, nextconnector))\n                            lookup[connector.side].add(Number(nextid));\n            this.connectorsLookupTable[id] = lookup.map(e => [...e].sort((a, b) => a - b));\n        }\n    }\n    getAvailableOptions() {\n        return [...Object.entries(this.connectors)].map(([id]) => Number(id));\n    }\n    createSolution(width, height) {\n        return new WFC.Solution(width, height, this);\n    }\n    collapse(solution, x, y, idToUse) {\n        let index = solution.positionToIndex(x, y);\n        if (idToUse !== undefined)\n            solution.cells[index].options = [idToUse];\n        else\n            solution.cells[index].options = [solution.cells[index].options[Math.floor(Math.random() * solution.cells[index].options.length)]];\n        solution.cells[index].solved = true;\n        this.propagate(solution, x, y);\n    }\n    fullCollapse(solution, start) {\n        if (start)\n            this.collapse(solution, start.x, start.y, start.idToUse);\n        while (!solution.solved()) {\n            let cell = [...solution.cells].filter(cell => !cell.solved).sort((a, b) => a.options.length - b.options.length)[0];\n            let index = solution.cells.indexOf(cell);\n            let [x, y] = solution.indexToPosition(index);\n            this.collapse(solution, x, y);\n        }\n    }\n    surround(solution, id) {\n        for (let x = 0; x < solution.width; x++) {\n            this.collapse(solution, x, 0, id);\n            this.collapse(solution, x, solution.height - 1, id);\n        }\n        for (let y = 1; y < solution.width - 1; y++) {\n            this.collapse(solution, 0, y, id);\n            this.collapse(solution, solution.width - 1, y, id);\n        }\n    }\n    propagate(solution, x, y) {\n        // insert first point into open queue\n        let open = [[x, y]];\n        do {\n            // Sort open points per available options in ascending order\n            open.sort(([xa, ya], [xb, yb]) => {\n                let a = solution.cells[solution.positionToIndex(xa, ya)];\n                let b = solution.cells[solution.positionToIndex(xb, yb)];\n                return a.options.length - b.options.length;\n            });\n            // Find the list of points which have the same smallest amount of options left\n            let ties = open.filter(([x, y]) => solution.cells[solution.positionToIndex(x, y)].options.length === solution.cells[solution.positionToIndex(...open[0])].options.length);\n            // Pick one\n            let chosenOne = ties[Math.floor(Math.random() * ties.length)];\n            open.splice(open.indexOf(chosenOne), 1);\n            // Find cell\n            let cell = solution.cells[solution.positionToIndex(...chosenOne)];\n            // For each side\n            for (let side of [WFC.Side.TOP, WFC.Side.RIGHT, WFC.Side.BOTTOM, WFC.Side.LEFT]) {\n                let neighborPosition = solution.neighborOf(...chosenOne, side);\n                if (!neighborPosition)\n                    continue;\n                let [nx, ny] = neighborPosition;\n                let index = solution.positionToIndex(nx, ny);\n                // If maybe neighbor is outside the solution range, skip this side\n                if (!(0 <= nx && nx < solution.size[0] && 0 <= ny && ny < solution.size[1]))\n                    continue;\n                let neighbor = solution.cells[index];\n                if (neighbor.solved)\n                    continue;\n                let startLength = neighbor.options.length;\n                let nextOptions = [];\n                for (let option of cell.options) {\n                    let lookup = this.connectorsLookupTable[option][side];\n                    for (let neighborOption of neighbor.options) {\n                        if (lookup.includes(neighborOption))\n                            nextOptions.push(neighborOption);\n                    }\n                }\n                neighbor.options = [...new Set(nextOptions)];\n                let endLength = neighbor.options.length;\n                if (endLength <= 1)\n                    neighbor.solved = true;\n                if (startLength !== endLength)\n                    open.push([nx, ny]);\n            }\n        } while (open.length);\n    }\n}\nvar WFC;\n(function (WFC) {\n    let Side;\n    (function (Side) {\n        Side[Side[\"TOP\"] = 0] = \"TOP\";\n        Side[Side[\"RIGHT\"] = 1] = \"RIGHT\";\n        Side[Side[\"BOTTOM\"] = 2] = \"BOTTOM\";\n        Side[Side[\"LEFT\"] = 3] = \"LEFT\";\n    })(Side = WFC.Side || (WFC.Side = {}));\n    function areConnectionTripleMatching(connectionA, connectionB) {\n        if (connectionA.length !== connectionB.length)\n            return false;\n        for (let indexA = 0; indexA < connectionA.length; indexA++)\n            if (connectionA[indexA] !== connectionB[connectionA.length - 1 - indexA])\n                return false;\n        return true;\n    }\n    WFC.areConnectionTripleMatching = areConnectionTripleMatching;\n    function areConnectionsCompatible(connectionA, connectionB) {\n        if (connectionA.side !== (connectionB.side + 2) % 4)\n            return;\n        return areConnectionTripleMatching(connectionA.connection, connectionB.connection);\n    }\n    WFC.areConnectionsCompatible = areConnectionsCompatible;\n    /**\n     * Rotate the rule steps times to the right\n     */\n    function rotateRule(rule, newid, steps = 1) {\n        steps = ((steps % 4) + 4) % 4;\n        return {\n            id: newid ?? rule.id,\n            connectors: rule.connectors.map(connector => ({\n                side: (connector.side + steps) % 4,\n                connection: [...connector.connection]\n            }))\n        };\n    }\n    WFC.rotateRule = rotateRule;\n    function flipRule(rule, newid, direction = -1) {\n        if (direction !== -1) {\n            return {\n                id: newid ?? rule.id,\n                connectors: rule.connectors.map(connector => {\n                    let flip = (connector.side & 1) === (direction & 1);\n                    return {\n                        side: flip ? (connector.side + 2) % 4 : connector.side,\n                        connection: [...connector.connection].reverse()\n                    };\n                })\n            };\n        }\n        return {\n            id: newid ?? rule.id,\n            connectors: rule.connectors.map(connector => ({\n                side: connector.side,\n                connection: [...connector.connection]\n            }))\n        };\n    }\n    WFC.flipRule = flipRule;\n    class Solution {\n        size = [1, 1];\n        cells = [];\n        wfc;\n        constructor(width, height, wfc) {\n            if (width < 1 || height < 1)\n                throw 'Solution size cannot be less than 1x1';\n            this.size = [width, height];\n            this.wfc = wfc;\n            let options = wfc.getAvailableOptions();\n            for (let index = 0; index < width * height; index++)\n                this.cells.push({ options: [...options], solved: false });\n        }\n        get width() { return this.size[0]; }\n        get height() { return this.size[1]; }\n        solved() {\n            return this.cells.every(cell => cell.solved);\n        }\n        getCellAtIndex(index) { return this.cells[index]; }\n        getCellAtPosition(x, y) {\n            if (!this.containsPosition(x, y))\n                return null;\n            return this.cells[this.positionToIndex(x, y)] ?? null;\n        }\n        indexToPosition(index) {\n            return [index % this.width, Math.floor(index / this.width)];\n        }\n        positionToIndex(x, y) {\n            return x + y * this.width;\n        }\n        containsPosition(x, y) {\n            return 0 <= x && x < this.width && 0 <= y && y < this.height;\n        }\n        neighborOf(x, y, side) {\n            switch (side) {\n                case Side.TOP:\n                    y++;\n                    break;\n                case Side.RIGHT:\n                    x++;\n                    break;\n                case Side.BOTTOM:\n                    y--;\n                    break;\n                case Side.LEFT:\n                    x--;\n                    break;\n                default:\n                    y++;\n            }\n            if (this.containsPosition(x, y))\n                return [x, y];\n            return null;\n        }\n        clearCellsAtPositions(positions) {\n            for (let [x, y] of positions)\n                if (this.getCellAtPosition(x, y))\n                    this.getCellAtPosition(x, y).solved = false;\n            let options = this.wfc.getAvailableOptions();\n            for (let cell of this.cells)\n                if (!cell.solved)\n                    cell.options = [...options];\n            for (let [index, cell] of this.cells.entries())\n                if (cell.solved)\n                    this.wfc.propagate(this, ...this.indexToPosition(index));\n        }\n    }\n    WFC.Solution = Solution;\n})(WFC = WFC || (WFC = {}));\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/math/WaveFunctionCollapse.js?");

/***/ }),

/***/ "./js/physics/SoftBody.js":
/*!********************************!*\
  !*** ./js/physics/SoftBody.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SoftBody: () => (/* binding */ SoftBody)\n/* harmony export */ });\n/* harmony import */ var _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../2DGameEngine.js */ \"./js/2DGameEngine.js\");\n\nvar SoftBody;\n(function (SoftBody) {\n    class Solver extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n        constraints = [];\n        addConstraint(...constraints) {\n            for (let constraint of constraints) {\n                if (this.constraints.indexOf(constraint) !== -1)\n                    continue;\n                this.constraints.push(constraint);\n            }\n        }\n        removeConstraint(...constraints) {\n            for (let constraint of constraints) {\n                if (this.constraints.indexOf(constraint) === -1)\n                    continue;\n                this.constraints.splice(this.constraints.indexOf(constraint), 1);\n            }\n        }\n        integrableBodies = [];\n        addIntegrableBody(...integrableBodies) {\n            for (let integrableBody of integrableBodies) {\n                if (this.integrableBodies.indexOf(integrableBody) !== -1)\n                    continue;\n                this.integrableBodies.push(integrableBody);\n            }\n        }\n        removeIntegrableBody(...integrableBodies) {\n            for (let IntegrableBody of integrableBodies) {\n                if (this.integrableBodies.indexOf(IntegrableBody) === -1)\n                    continue;\n                this.integrableBodies.splice(this.integrableBodies.indexOf(IntegrableBody), 1);\n            }\n        }\n        collidableBodies = [];\n        addCollidableBody(...collidableBodies) {\n            for (let collidableBody of collidableBodies) {\n                if (this.collidableBodies.indexOf(collidableBody) !== -1)\n                    continue;\n                this.collidableBodies.push(collidableBody);\n            }\n        }\n        removeCollidableBody(...collidableBodies) {\n            for (let collidableBody of collidableBodies) {\n                if (this.collidableBodies.indexOf(collidableBody) === -1)\n                    continue;\n                this.collidableBodies.splice(this.collidableBodies.indexOf(collidableBody), 1);\n            }\n        }\n        physics(dt) {\n            for (let constraint of this.constraints)\n                constraint.applyConstraint();\n            for (let integrableBody of this.integrableBodies)\n                integrableBody.integrate(dt);\n            for (let collidableBody of this.collidableBodies)\n                for (let integrableBody of this.integrableBodies)\n                    if (collidableBody !== integrableBody) {\n                        let frixion;\n                        let absorption;\n                        if ('frixion' in integrableBody && 'absorption' in integrableBody) {\n                            frixion = Math.min(integrableBody.frixion, collidableBody.frixion);\n                            absorption = Math.max(integrableBody.absorption, collidableBody.absorption);\n                        }\n                        else {\n                            frixion = collidableBody.frixion;\n                            absorption = collidableBody.absorption;\n                        }\n                        for (let point of integrableBody.getPoints())\n                            this.resolveCollision(point, collidableBody, frixion, absorption);\n                    }\n        }\n        resolveCollision(point, collidableBody, frixion = collidableBody.frixion, absorption = collidableBody.absorption) {\n            if (collidableBody.containsPoint(point)) {\n                let AB = collidableBody.closestEdgeOfPoint(point);\n                this.resolveEdgeCollision(point, AB);\n                this.resolveEdgeCollisionVelocity(point, AB, frixion, absorption);\n            }\n        }\n        resolveEdgeCollision(P, [A, B]) {\n            this.resolveEdgeCollisionPosition(P, [A, B]);\n        }\n        resolveEdgeCollisionPosition({ position: P }, [{ position: A }, { position: B }]) {\n            let normal = A.to(B).normal();\n            let dir = P.to(B).projectOn(normal);\n            P.add(dir.clone().multS(2.1 / 3));\n            dir.multS(-1 / 3);\n            A.add(dir);\n            B.add(dir);\n        }\n        resolveEdgeCollisionVelocity(P, [A, B], frixion, absorption) {\n            let tangent = A.position.to(B.position);\n            let normal = tangent.normal();\n            let edgeVelocity = A.velocity.clone().add(B.velocity).divS(2);\n            let edgeTangentVelocity = edgeVelocity.projectOn(tangent);\n            let edgeNormalVelocity = edgeVelocity.projectOn(normal);\n            let pointTangentVelocity = P.velocity.projectOn(tangent);\n            let pointNormalVelocity = P.velocity.projectOn(normal);\n            P.velocity.copy(edgeNormalVelocity.multS(1 - absorption))\n                .add(pointTangentVelocity.multS(1 - frixion));\n            A.velocity.copy(pointNormalVelocity.multS(1 - absorption))\n                .add(edgeTangentVelocity.multS(1 - frixion));\n            B.velocity.copy(A.velocity);\n        }\n    }\n    SoftBody.Solver = Solver;\n    class Point {\n        position = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n        velocity = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n        acceleration = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n        freeze = false;\n        constructor(position = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector, velocity = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector, acceleration = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector, freeze = false) {\n            this.position = position;\n            this.velocity = velocity;\n            this.acceleration = acceleration;\n            this.freeze = freeze;\n        }\n        getPoints() {\n            return [this];\n        }\n        integrate(dt) {\n            this.position\n                .add(this.velocity.clone().multS(dt))\n                .add(this.acceleration.clone().multS(dt * dt * .5));\n            this.velocity.add(this.acceleration.clone().multS(dt));\n            this.acceleration.set(0, 0);\n        }\n    }\n    SoftBody.Point = Point;\n    class Shape extends _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.GameObject {\n        points;\n        frixion = 1;\n        absorption = 0;\n        constructor(points, frixion = 1, absorption = 0) {\n            super();\n            if (points.length < 3)\n                throw 'Shape cannot have less than 3 points';\n            this.addTag('SB.Shape');\n            this.points = points;\n            this.frixion = frixion;\n            this.absorption = absorption;\n        }\n        getPoints() {\n            return this.points;\n        }\n        getPointsCenter() {\n            return computeCenter(this.points);\n        }\n        integrate(dt) {\n            for (let point of this.points)\n                point.integrate(dt);\n        }\n        containsPoint(point) {\n            return new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Polygon(this.points.map(point => point.position)).containsVector(point.position);\n        }\n        distancePointToEdge(point, [A, B]) {\n            let vec = A.to(point);\n            let seg = A.to(B);\n            let seglen = seg.length();\n            let projection = vec.dot(seg) / seglen;\n            if (projection < 0)\n                return point.distanceTo(A);\n            else if (projection > seglen)\n                return point.distanceTo(B);\n            else\n                return vec.projectOn(seg.normal()).length();\n        }\n        closestEdgeOfPoint(point) {\n            let closestSegment_0 = -1;\n            let closestSegment_1 = -1;\n            let minLength = -1;\n            for (let index = 0; index < this.points.length; index++) {\n                let index_0 = index;\n                let index_1 = (index + 1) % this.points.length;\n                let p0 = this.points[index_0];\n                let p1 = this.points[index_1];\n                let dist = this.distancePointToEdge(point.position, [p0.position, p1.position]);\n                if (closestSegment_0 === -1 || dist < minLength) {\n                    closestSegment_0 = index_0;\n                    closestSegment_1 = index_1;\n                    minLength = dist;\n                }\n            }\n            return [this.points[closestSegment_0], this.points[closestSegment_1]];\n        }\n        addForce(force) {\n            for (let point of this.points)\n                point.acceleration.add(force);\n        }\n    }\n    SoftBody.Shape = Shape;\n    class Spring {\n        static stiffness = 100;\n        static damping = 1;\n        point_0;\n        point_1;\n        stiffness;\n        damping;\n        restLength;\n        constructor(point_0, point_1, stiffness = Spring.stiffness, damping = Spring.damping, restLength) {\n            if (point_0 === point_1)\n                throw ('Springs cannot have both end attached to the same point');\n            this.point_0 = point_0;\n            this.point_1 = point_1;\n            this.stiffness = stiffness;\n            this.damping = damping;\n            if (restLength === undefined)\n                this.relaxSpring();\n            else\n                this.restLength = restLength;\n        }\n        relaxSpring() {\n            this.restLength = this.point_0.position.distanceTo(this.point_1.position);\n        }\n        applyConstraint() {\n            if (this.point_0.freeze && this.point_1.freeze)\n                return;\n            if (this.point_0.position.distanceTo(this.point_1.position) === 0)\n                return;\n            let dir = this.point_0.position.to(this.point_1.position).normalize();\n            let currentLength = this.point_0.position.distanceTo(this.point_1.position);\n            let deltaLength = currentLength - this.restLength;\n            let force = this.stiffness * deltaLength;\n            let damping = this.point_0.velocity.to(this.point_1.velocity).projectOn(dir).multS(this.damping);\n            let forceVector = dir.clone().multS(force).add(damping);\n            if (!this.point_0.freeze && !this.point_1.freeze) {\n                forceVector.divS(2);\n                this.point_0.acceleration.add(forceVector);\n                forceVector.multS(-1);\n                this.point_1.acceleration.add(forceVector);\n            }\n            else if (!this.point_1.freeze) {\n                forceVector.multS(-1);\n                this.point_1.acceleration.add(forceVector);\n            }\n            else {\n                this.point_0.acceleration.add(forceVector);\n            }\n        }\n    }\n    SoftBody.Spring = Spring;\n    class Frame extends Shape {\n        freeze = false;\n        structure = [];\n        springs = [];\n        constructor(points, freeze = false, springStiffness, springDamping, frixion = 1, absorption = 0) {\n            super(points);\n            this.freeze = freeze;\n            this.frixion = frixion;\n            this.absorption = absorption;\n            for (let point of this.points) {\n                let framePoint = new Point(point.position.clone());\n                framePoint.freeze = freeze;\n                this.structure.push(framePoint);\n                let spring = new Spring(point, framePoint, springStiffness, springDamping, 0);\n                this.springs.push(spring);\n            }\n        }\n        applyConstraint() {\n            for (let spring of this.springs)\n                spring.applyConstraint();\n        }\n        getFrameCenter() {\n            return computeCenter(this.structure);\n        }\n        update(dt) {\n            if (!this.freeze) {\n                let pointsCenter = this.getPointsCenter();\n                let frameCenter = this.getFrameCenter();\n                let delta = frameCenter.to(pointsCenter);\n                for (let point of this.structure)\n                    point.position.add(delta);\n                let angle = 0;\n                for (let [index, point] of this.points.entries()) {\n                    let structPoint = this.structure[index];\n                    let pointAngle = pointsCenter.to(point.position).rotate(-pointsCenter.to(structPoint.position).angle()).angle();\n                    angle += pointAngle;\n                }\n                angle /= this.points.length;\n                for (let point of this.structure)\n                    point.position.rotateAround(pointsCenter, angle);\n            }\n        }\n    }\n    SoftBody.Frame = Frame;\n    function computeCenter(points) {\n        let center = new _2DGameEngine_js__WEBPACK_IMPORTED_MODULE_0__.Vector();\n        if (points.length === 0)\n            return center;\n        for (let point of points)\n            center.add(point.position);\n        center.divS(points.length);\n        return center;\n    }\n})(SoftBody = SoftBody || (SoftBody = {}));\n\n\n//# sourceURL=webpack://@kimiru/2dgameengine/./js/physics/SoftBody.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./examples/wfc/js/mainRigidBody.js");
/******/ 	
/******/ })()
;